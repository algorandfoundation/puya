contract BytesContract
{
  approval_program(): puyapy.UInt64
  {
    base_64: puyapy.Bytes = b64<"QmFzZSA2NCBlbmNvZGVk">
    assert(base_64 == 'Base 64 encoded')
    base_32: puyapy.Bytes = b32<"IJQXGZJAGMZCAZLOMNXWIZLE">
    assert(base_32 == 'Base 32 encoded')
    base_16: puyapy.Bytes = hex<"4261736520313620656E636F646564">
    assert(base_16 == 'Base 16 encoded')
    empty: puyapy.Bytes = ''
    assert(reinterpret_cast<bool>(len(base_64)), comment="Non empty bytes should be Truthy")
    assert(!(reinterpret_cast<bool>(len(empty))), comment="Empty bytes should be Falsy")
    assert('a' + 'b' == 'ab')
    c: puyapy.Bytes = 'c'
    c += 'd'
    assert(c == 'cd')
    abc: puyapy.Bytes = 'abc'
    assert(abc[0u] == 'a')
    assert(tmp$0: puyapy.Bytes := abc[select(len(tmp$0), 1u, 1u < len(tmp$0)):] == 'bc')
    assert(tmp$1: puyapy.Bytes := abc[select(len(tmp$1), 1u, 1u < len(tmp$1)):select(len(tmp$1), 1u, 1u < len(tmp$1))] == '')
    assert(tmp$2: puyapy.Bytes := abc[:select(len(tmp$2), 1u, 1u < len(tmp$2))] == 'a')
    assert(tmp$3: puyapy.Bytes := abc[:len(tmp$3) - select(len(tmp$3), 1u, 1u < len(tmp$3))] == 'ab')
    assert(tmp$4: puyapy.Bytes := abc[len(tmp$4) - select(len(tmp$4), 2u, 2u < len(tmp$4)):] == 'bc')
    assert(tmp$5: puyapy.Bytes := abc[len(tmp$5) - select(len(tmp$5), 2u, 2u < len(tmp$5)):len(tmp$5) - select(len(tmp$5), 1u, 1u < len(tmp$5))] == 'b')
    assert(tmp$6: puyapy.Bytes := '1234567'[select(len(tmp$6), 1u, 1u < len(tmp$6)):len(tmp$6) - select(len(tmp$6), 1u, 1u < len(tmp$6))] == '23456')
    assert(tmp$7: puyapy.Bytes := abc[len(tmp$7) - select(len(tmp$7), 10u, 10u < len(tmp$7)):select(len(tmp$7), 10u, 10u < len(tmp$7))] == 'abc')
    true: puyapy.Bytes = '1'
    false: puyapy.Bytes = ''
    x: bool = (!(reinterpret_cast<bool>(len(true)))) ? (true) : (true) == true
    assert(x)
    assert((!(reinterpret_cast<bool>(len(true)))) ? (true) : (true) == true)
    assert((!(reinterpret_cast<bool>(len(true)))) ? (true) : (false) == false)
    assert((!(reinterpret_cast<bool>(len(false)))) ? (false) : (true) == false)
    assert((!(reinterpret_cast<bool>(len(false)))) ? (false) : (false) == false)
    assert((reinterpret_cast<bool>(len(true))) ? (true) : (true) == true)
    assert((reinterpret_cast<bool>(len(true))) ? (true) : (false) == true)
    assert((reinterpret_cast<bool>(len(false))) ? (false) : (true) == true)
    assert((reinterpret_cast<bool>(len(false))) ? (false) : (false) == false)
    (a, b, c, d): tuple[puyapy.Bytes, puyapy.Bytes, puyapy.Bytes, puyapy.Bytes] = (hex<"00">, hex<"0F">, hex<"F0">, hex<"FF">)
    assert(a & b == a)
    assert(b | c == d)
    assert(b ^ d == c)
    y: puyapy.Bytes = a
    y &= d
    assert(y == a)
    y |= d
    assert(y == d)
    y ^= c
    assert(y == b)
    test_cases.stubs.bytes::check_slicing_with_uint64(abc)
    return 1u
  }
  
  clear_state_program(): bool
  {
    return true
  }
}

subroutine check_slicing_with_uint64(abc: puyapy.Bytes): None
{
  one: puyapy.UInt64 = 1u
  ten: puyapy.UInt64 = 10u
  assert(tmp$8: puyapy.Bytes := abc[select(len(tmp$8), tmp$9: puyapy.UInt64 := one, tmp$9 < len(tmp$8)):] == 'bc')
  assert(tmp$10: puyapy.Bytes := abc[select(len(tmp$10), tmp$11: puyapy.UInt64 := one, tmp$11 < len(tmp$10)):select(len(tmp$10), tmp$12: puyapy.UInt64 := one, tmp$12 < len(tmp$10))] == '')
  assert(tmp$13: puyapy.Bytes := abc[:select(len(tmp$13), tmp$14: puyapy.UInt64 := one, tmp$14 < len(tmp$13))] == 'a')
  assert(tmp$15: puyapy.Bytes := test_cases.stubs.bytes::one_to_seven()[select(len(tmp$15), tmp$16: puyapy.UInt64 := one, tmp$16 < len(tmp$15)):len(tmp$15) - select(len(tmp$15), 1u, 1u < len(tmp$15))] == '23456')
  assert(tmp$17: puyapy.Bytes := abc[select(len(tmp$17), tmp$18: puyapy.UInt64 := 0u, tmp$18 < len(tmp$17)):select(len(tmp$17), tmp$19: puyapy.UInt64 := ten, tmp$19 < len(tmp$17))] == 'abc')
}

subroutine one_to_seven(): puyapy.Bytes
{
  log('one_to_seven called')
  return '1234567'
}