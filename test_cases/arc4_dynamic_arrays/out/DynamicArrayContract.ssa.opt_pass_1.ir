contract test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract:
    program approval:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.approval_program() -> bool:
            block@0: // L24
                let array_data%0#1: bytes = 0x04
                let byte_array1#0: bytes = (concat array_data%0#1 0x05)
                let array_data%1#1: bytes = 0x2a
                let byte_array2#0: bytes = (concat array_data%1#1 0x50)
                let value_as_uint16%0#0: bytes = 0x0004
                let data_length%0#0: uint64 = 5u
                let current_tail_offset%0#1: uint64 = (+ 4u data_length%0#0)
                let value_as_bytes%1#0: bytes = (itob current_tail_offset%0#1)
                let value_as_uint16%1#0: bytes = ((extract 6 2) value_as_bytes%1#0)
                let encoded_tuple_buffer%0#2: bytes = (concat value_as_uint16%0#0 value_as_uint16%1#0)
                let data_length%1#0: uint64 = 5u
                let encoded_tuple_buffer%0#3: bytes = (concat encoded_tuple_buffer%0#2 "\x00\x03aye")
                let dynamic_struct1#0: bytes = (concat encoded_tuple_buffer%0#3 "\x00\x03bee")
                let value_as_uint16%2#0: bytes = 0x0004
                let data_length%2#0: uint64 = 7u
                let current_tail_offset%1#1: uint64 = (+ 4u data_length%2#0)
                let value_as_bytes%3#0: bytes = (itob current_tail_offset%1#1)
                let value_as_uint16%3#0: bytes = ((extract 6 2) value_as_bytes%3#0)
                let encoded_tuple_buffer%1#2: bytes = (concat value_as_uint16%2#0 value_as_uint16%3#0)
                let data_length%3#0: uint64 = 5u
                let encoded_tuple_buffer%1#3: bytes = (concat encoded_tuple_buffer%1#2 "\x00\x05Hello")
                let dynamic_struct2#0: bytes = (concat encoded_tuple_buffer%1#3 "\x00\x03aye")
                let value_as_uint16%4#0: bytes = 0x0004
                let array_data%2#1: bytes = (concat 0x0002 value_as_uint16%4#0)
                let element_length%0#0: uint64 = (len dynamic_struct1#0)
                let next_offset%0#1: uint64 = (+ 4u element_length%0#0)
                let value_as_bytes%5#0: bytes = (itob next_offset%0#1)
                let value_as_uint16%5#0: bytes = ((extract 6 2) value_as_bytes%5#0)
                let array_data%2#2: bytes = (concat array_data%2#1 value_as_uint16%5#0)
                let element_length%1#0: uint64 = (len dynamic_struct2#0)
                let array_data%2#3: bytes = (concat array_data%2#2 dynamic_struct1#0)
                let dynamic_array#0: bytes = (concat array_data%2#3 dynamic_struct2#0)
                (log dynamic_array#0)
                let array_length%0#0: uint64 = (extract_uint16 dynamic_array#0 0u)
                (assert array_length%0#0) // Index access is out of bounds
                let array_data_sans_header%0#0: bytes = ((extract 2 0) dynamic_array#0)
                let item_index_index%0#0: uint64 = 0u
                let item_index%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index_index%0#0)
                let item_length%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index%0#0)
                let item_length_plus_2%0#0: uint64 = (+ item_length%0#0 2u)
                let tmp%0#0: bytes = (extract3 array_data_sans_header%0#0 item_index%0#0 item_length_plus_2%0#0)
                (log tmp%0#0)
                let index_is_in_bounds%1#0: bool = (< 1u array_length%0#0)
                (assert index_is_in_bounds%1#0) // Index access is out of bounds
                let item_index_index%1#0: uint64 = 2u
                let item_index%1#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index_index%1#0)
                let item_length%1#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index%1#0)
                let item_length_plus_2%1#0: uint64 = (+ item_length%1#0 2u)
                let tmp%1#0: bytes = (extract3 array_data_sans_header%0#0 item_index%1#0 item_length_plus_2%1#0)
                (log tmp%1#0)
                let encoded_tuple_buffer%2#1: bytes = 0x0000000000000003
                let fixed1#0: bytes = (concat encoded_tuple_buffer%2#1 byte_array1#0)
                let encoded_tuple_buffer%3#1: bytes = 0x0000040000000000
                let fixed2#0: bytes = (concat encoded_tuple_buffer%3#1 byte_array2#0)
                let array_data%3#1: bytes = (concat 0x0002 fixed1#0)
                let dynamic_fixed#0: bytes = (concat array_data%3#1 fixed2#0)
                (log dynamic_fixed#0)
                let array_length%2#0: uint64 = (extract_uint16 dynamic_fixed#0 0u)
                (assert array_length%2#0) // Index access is out of bounds
                let array_data_sans_header%2#0: bytes = ((extract 2 0) dynamic_fixed#0)
                let item_index%2#0: uint64 = 0u
                let tmp%2#0: bytes = (extract3 array_data_sans_header%2#0 item_index%2#0 10u)
                (log tmp%2#0)
                let index_is_in_bounds%3#0: bool = (< 1u array_length%2#0)
                (assert index_is_in_bounds%3#0) // Index access is out of bounds
                let item_index%3#0: uint64 = 10u
                let tmp%3#0: bytes = (extract3 array_data_sans_header%2#0 item_index%3#0 10u)
                (log tmp%3#0)
                let encoded_tuple_buffer%4#1: bytes = 0x0000000000000003
                let value_as_uint16%6#0: bytes = 0x0012
                let encoded_tuple_buffer%4#2: bytes = (concat encoded_tuple_buffer%4#1 value_as_uint16%6#0)
                let data_length%4#0: uint64 = 5u
                let encoded_tuple_buffer%4#3: bytes = (concat encoded_tuple_buffer%4#2 0x0000040000000000)
                let mixed1#0: bytes = (concat encoded_tuple_buffer%4#3 "\x00\x03aye")
                let encoded_tuple_buffer%5#1: bytes = 0x0000040000000000
                let value_as_uint16%7#0: bytes = 0x0012
                let encoded_tuple_buffer%5#2: bytes = (concat encoded_tuple_buffer%5#1 value_as_uint16%7#0)
                let data_length%5#0: uint64 = 5u
                let encoded_tuple_buffer%5#3: bytes = (concat encoded_tuple_buffer%5#2 0x0000000000000003)
                let mixed2#0: bytes = (concat encoded_tuple_buffer%5#3 "\x00\x03bee")
                let value_as_uint16%8#0: bytes = 0x0004
                let array_data%4#1: bytes = (concat 0x0002 value_as_uint16%8#0)
                let element_length%2#0: uint64 = (len mixed1#0)
                let next_offset%1#1: uint64 = (+ 4u element_length%2#0)
                let value_as_bytes%9#0: bytes = (itob next_offset%1#1)
                let value_as_uint16%9#0: bytes = ((extract 6 2) value_as_bytes%9#0)
                let array_data%4#2: bytes = (concat array_data%4#1 value_as_uint16%9#0)
                let element_length%3#0: uint64 = (len mixed2#0)
                let array_data%4#3: bytes = (concat array_data%4#2 mixed1#0)
                let dynamic_mixed#0: bytes = (concat array_data%4#3 mixed2#0)
                (log dynamic_mixed#0)
                let array_length%4#0: uint64 = (extract_uint16 dynamic_mixed#0 0u)
                (assert array_length%4#0) // Index access is out of bounds
                let array_data_sans_header%4#0: bytes = ((extract 2 0) dynamic_mixed#0)
                let item_index_index%2#0: uint64 = 0u
                let item_index%4#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index_index%2#0)
                let item_length%2#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index%4#0)
                let item_length_plus_2%2#0: uint64 = (+ item_length%2#0 2u)
                let tmp%4#0: bytes = (extract3 array_data_sans_header%4#0 item_index%4#0 item_length_plus_2%2#0)
                (log tmp%4#0)
                let index_is_in_bounds%5#0: bool = (< 1u array_length%4#0)
                (assert index_is_in_bounds%5#0) // Index access is out of bounds
                let item_index_index%3#0: uint64 = 2u
                let item_index%5#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index_index%3#0)
                let item_length%3#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index%5#0)
                let item_length_plus_2%3#0: uint64 = (+ item_length%3#0 2u)
                let tmp%5#0: bytes = (extract3 array_data_sans_header%4#0 item_index%5#0 item_length_plus_2%3#0)
                (log tmp%5#0)
                return 1u
    
    program clear-state:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.clear_state_program() -> bool:
            block@0: // L56
                return 1u