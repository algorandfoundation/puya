contract test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract:
    program approval:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.approval_program() -> bool:
            block@0: // L24
                let dynamic_struct1#0: bytes = 0x0004000900036179650003626565
                let dynamic_struct2#0: bytes = 0x0004000b000548656c6c6f0003617965
                let element_length%0#0: uint64 = (len dynamic_struct1#0)
                let next_offset%0#1: uint64 = (+ 4u element_length%0#0)
                let value_as_bytes%5#0: bytes = (itob next_offset%0#1)
                let value_as_uint16%5#0: bytes = ((extract 6 2) value_as_bytes%5#0)
                let array_data%2#2: bytes = (concat 0x00020004 value_as_uint16%5#0)
                let array_data%2#3: bytes = (concat array_data%2#2 dynamic_struct1#0)
                let dynamic_array#0: bytes = (concat array_data%2#3 dynamic_struct2#0)
                (log dynamic_array#0)
                let array_length%0#0: uint64 = (extract_uint16 dynamic_array#0 0u)
                (assert array_length%0#0) // Index access is out of bounds
                let array_data_sans_header%0#0: bytes = ((extract 2 0) dynamic_array#0)
                let item_index%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 0u)
                let item_length%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index%0#0)
                let item_length_plus_2%0#0: uint64 = (+ item_length%0#0 2u)
                let tmp%0#0: bytes = (extract3 array_data_sans_header%0#0 item_index%0#0 item_length_plus_2%0#0)
                (log tmp%0#0)
                let index_is_in_bounds%1#0: bool = (< 1u array_length%0#0)
                (assert index_is_in_bounds%1#0) // Index access is out of bounds
                let item_index%1#0: uint64 = (extract_uint16 array_data_sans_header%0#0 2u)
                let item_length%1#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index%1#0)
                let item_length_plus_2%1#0: uint64 = (+ item_length%1#0 2u)
                let tmp%1#0: bytes = (extract3 array_data_sans_header%0#0 item_index%1#0 item_length_plus_2%1#0)
                (log tmp%1#0)
                (log 0x00020000000000000003040500000400000000002a50)
                let array_length%2#0: uint64 = 2u
                (assert array_length%2#0) // Index access is out of bounds
                let array_data_sans_header%2#0: bytes = 0x0000000000000003040500000400000000002a50
                let tmp%2#0: bytes = ((extract 0 10) array_data_sans_header%2#0)
                (log tmp%2#0)
                let index_is_in_bounds%3#0: bool = (< 1u array_length%2#0)
                (assert index_is_in_bounds%3#0) // Index access is out of bounds
                let tmp%3#0: bytes = ((extract 10 10) array_data_sans_header%2#0)
                (log tmp%3#0)
                let next_offset%1#1: uint64 = 27u
                let value_as_bytes%9#0: bytes = (itob next_offset%1#1)
                let value_as_uint16%9#0: bytes = ((extract 6 2) value_as_bytes%9#0)
                let array_data%4#2: bytes = (concat 0x00020004 value_as_uint16%9#0)
                let array_data%4#3: bytes = (concat array_data%4#2 0x0000000000000003001200000400000000000003617965)
                let dynamic_mixed#0: bytes = (concat array_data%4#3 0x0000040000000000001200000000000000030003626565)
                (log dynamic_mixed#0)
                let array_length%4#0: uint64 = (extract_uint16 dynamic_mixed#0 0u)
                (assert array_length%4#0) // Index access is out of bounds
                let array_data_sans_header%4#0: bytes = ((extract 2 0) dynamic_mixed#0)
                let item_index%4#0: uint64 = (extract_uint16 array_data_sans_header%4#0 0u)
                let item_length%2#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index%4#0)
                let item_length_plus_2%2#0: uint64 = (+ item_length%2#0 2u)
                let tmp%4#0: bytes = (extract3 array_data_sans_header%4#0 item_index%4#0 item_length_plus_2%2#0)
                (log tmp%4#0)
                let index_is_in_bounds%5#0: bool = (< 1u array_length%4#0)
                (assert index_is_in_bounds%5#0) // Index access is out of bounds
                let item_index%5#0: uint64 = (extract_uint16 array_data_sans_header%4#0 2u)
                let item_length%3#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index%5#0)
                let item_length_plus_2%3#0: uint64 = (+ item_length%3#0 2u)
                let tmp%5#0: bytes = (extract3 array_data_sans_header%4#0 item_index%5#0 item_length_plus_2%3#0)
                (log tmp%5#0)
                return 1u
    
    program clear-state:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.clear_state_program() -> bool:
            block@0: // L56
                return 1u