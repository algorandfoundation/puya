struct StaticStruct {
  a: arc4.uint64
  b: arc4.static_array<arc4.byte, 2>
}

struct DynamicStruct {
  a: arc4.string
  b: arc4.string
}

struct MixedSingleStruct {
  a: arc4.uint64
  b: arc4.string
  c: arc4.uint64
}

struct MixedMultipleStruct {
  a: arc4.uint64
  b: arc4.string
  c: arc4.uint64
  d: arc4.dynamic_array<arc4.uint16>
  e: arc4.uint64
}

struct NestedDynamicStruct {
  one: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>
  two: arc4.struct<a:arc4.string,b:arc4.string>
  three: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>
  four: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>
  five: arc4.struct<a:arc4.string,b:arc4.string>
}

contract DynamicArrayContract
{
  abimethod test_static_elements(): void
  {
    byte_array1: arc4.static_array<arc4.byte, 2> = new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte1(), test_cases.arc4_dynamic_arrays.contract::get_byte2())
    byte_array2: arc4.static_array<arc4.byte, 2> = new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte3(), test_cases.arc4_dynamic_arrays.contract::get_byte4())
    struct1: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=byte_array1.copy())
    struct2: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint2(), b=byte_array2.copy())
    array: arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>> = new arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>>(struct1.copy(), struct1.copy())
    array[1u]: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = struct2.copy()
    log(array)
    log(array[0u])
    log(array[1u])
    assert(array.pop() == struct2)
    assert(array.pop() == struct1)
  }
  
  abimethod test_dynamic_elements(): void
  {
    struct1: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string1(), b=test_cases.arc4_dynamic_arrays.contract::get_string2())
    struct2: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string3(), b=test_cases.arc4_dynamic_arrays.contract::get_string1())
    array: arc4.dynamic_array<arc4.struct<a:arc4.string,b:arc4.string>> = new arc4.dynamic_array<arc4.struct<a:arc4.string,b:arc4.string>>(struct1.copy(), struct1.copy())
    array.extend((struct1.copy()))
    array[1u]: arc4.struct<a:arc4.string,b:arc4.string> = struct2.copy()
    log(array)
    log(array[0u])
    log(array[1u])
    log(array[2u])
    assert(array.pop() == struct1)
    log(array)
    assert(array.pop() == struct2)
    log(array)
    assert(array.pop() == struct1)
    log(array)
  }
  
  abimethod test_mixed_single_dynamic_elements(): void
  {
    struct1: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=test_cases.arc4_dynamic_arrays.contract::get_string1(), c=test_cases.arc4_dynamic_arrays.contract::get_uint2())
    struct2: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint2(), b=test_cases.arc4_dynamic_arrays.contract::get_string2(), c=test_cases.arc4_dynamic_arrays.contract::get_uint1())
    array: arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64>> = new arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64>>()
    array.extend((struct2.copy()))
    array.extend((struct2.copy()))
    array[0u]: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64> = struct1.copy()
    log(array)
    log(array[0u])
    log(array[1u])
    assert(array.pop() == struct2)
    assert(array.pop() == struct1)
  }
  
  abimethod test_mixed_multiple_dynamic_elements(): void
  {
    struct1: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=test_cases.arc4_dynamic_arrays.contract::get_string1(), c=test_cases.arc4_dynamic_arrays.contract::get_uint2(), d=test_cases.arc4_dynamic_arrays.contract::get_u16_arr1(), e=test_cases.arc4_dynamic_arrays.contract::get_uint1())
    struct2: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint2(), b=test_cases.arc4_dynamic_arrays.contract::get_string2(), c=test_cases.arc4_dynamic_arrays.contract::get_uint1(), d=test_cases.arc4_dynamic_arrays.contract::get_u16_arr2(), e=test_cases.arc4_dynamic_arrays.contract::get_uint2())
    array: arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>> = new arc4.dynamic_array<arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>>(struct1.copy(), struct1.copy())
    array[1u]: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = struct2.copy()
    log(array)
    log(array[0u])
    log(array[1u])
    assert(array.pop() == struct2)
    assert(array.pop() == struct1)
  }
  
  abimethod test_nested_struct_replacement(): void
  {
    one: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte1(), test_cases.arc4_dynamic_arrays.contract::get_byte2()))
    two: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string1(), b=test_cases.arc4_dynamic_arrays.contract::get_string2())
    three: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint2(), b=new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte2(), test_cases.arc4_dynamic_arrays.contract::get_byte1()))
    four: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=test_cases.arc4_dynamic_arrays.contract::get_string1(), c=test_cases.arc4_dynamic_arrays.contract::get_uint2(), d=test_cases.arc4_dynamic_arrays.contract::get_u16_arr1(), e=test_cases.arc4_dynamic_arrays.contract::get_uint1())
    five: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string1(), b=test_cases.arc4_dynamic_arrays.contract::get_string2())
    struct1: arc4.struct<one:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,two:arc4.struct<a:arc4.string,b:arc4.string>,three:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,four:arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,five:arc4.struct<a:arc4.string,b:arc4.string>> = new arc4.struct<one:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,two:arc4.struct<a:arc4.string,b:arc4.string>,three:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,four:arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,five:arc4.struct<a:arc4.string,b:arc4.string>>(one=one.copy(), two=two.copy(), three=three.copy(), four=four.copy(), five=five.copy())
    struct2: arc4.struct<one:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,two:arc4.struct<a:arc4.string,b:arc4.string>,three:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,four:arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,five:arc4.struct<a:arc4.string,b:arc4.string>> = new arc4.struct<one:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,two:arc4.struct<a:arc4.string,b:arc4.string>,three:arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,four:arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,five:arc4.struct<a:arc4.string,b:arc4.string>>(one=one.copy(), two=new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string2(), b=test_cases.arc4_dynamic_arrays.contract::get_string1()), three=three.copy(), four=four.copy(), five=five.copy())
    struct2.two: arc4.struct<a:arc4.string,b:arc4.string> = two.copy()
    assert(reinterpret_cast<bytes>(struct1) == reinterpret_cast<bytes>(struct2), comment="struct1 does not match struct2")
  }
  
  abimethod test_nested_tuple_modification(): void
  {
    one: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte1(), test_cases.arc4_dynamic_arrays.contract::get_byte2()))
    two: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string1(), b=test_cases.arc4_dynamic_arrays.contract::get_string2())
    three: arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>> = new arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>(a=test_cases.arc4_dynamic_arrays.contract::get_uint2(), b=new arc4.static_array<arc4.byte, 2>(test_cases.arc4_dynamic_arrays.contract::get_byte2(), test_cases.arc4_dynamic_arrays.contract::get_byte1()))
    four1: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=test_cases.arc4_dynamic_arrays.contract::get_string1(), c=test_cases.arc4_dynamic_arrays.contract::get_uint2(), d=test_cases.arc4_dynamic_arrays.contract::get_u16_arr1(), e=test_cases.arc4_dynamic_arrays.contract::get_uint1())
    four2: arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64> = new arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>(a=test_cases.arc4_dynamic_arrays.contract::get_uint1(), b=test_cases.arc4_dynamic_arrays.contract::get_string1(), c=test_cases.arc4_dynamic_arrays.contract::get_uint2(), d=test_cases.arc4_dynamic_arrays.contract::get_u16_arr1() + (123arc4u16), e=test_cases.arc4_dynamic_arrays.contract::get_uint1())
    five: arc4.struct<a:arc4.string,b:arc4.string> = new arc4.struct<a:arc4.string,b:arc4.string>(a=test_cases.arc4_dynamic_arrays.contract::get_string1(), b=test_cases.arc4_dynamic_arrays.contract::get_string2())
    tup1: arc4.tuple<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.string,b:arc4.string>,arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,arc4.struct<a:arc4.string,b:arc4.string>> = arc4_encode((one.copy(), two.copy(), three.copy(), four1.copy(), five.copy()), arc4.tuple<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.string,b:arc4.string>,arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,arc4.struct<a:arc4.string,b:arc4.string>>)
    tup2: arc4.tuple<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.string,b:arc4.string>,arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,arc4.struct<a:arc4.string,b:arc4.string>> = arc4_encode((one.copy(), two.copy(), three.copy(), four2.copy(), five.copy()), arc4.tuple<arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.string,b:arc4.string>,arc4.struct<a:arc4.uint64,b:arc4.static_array<arc4.byte, 2>>,arc4.struct<a:arc4.uint64,b:arc4.string,c:arc4.uint64,d:arc4.dynamic_array<arc4.uint16>,e:arc4.uint64>,arc4.struct<a:arc4.string,b:arc4.string>>)
    tup2[3].d.pop()
    assert(reinterpret_cast<bytes>(tup1) == reinterpret_cast<bytes>(tup2), comment="tup1 does not match tup2")
  }
}

subroutine get_string1(): arc4.string
{
  return arc4_encode('a', arc4.string)
}

subroutine get_string2(): arc4.string
{
  return arc4_encode('bee', arc4.string)
}

subroutine get_string3(): arc4.string
{
  return arc4_encode('Hello World', arc4.string)
}

subroutine get_uint1(): arc4.uint64
{
  return 3arc4u64
}

subroutine get_uint2(): arc4.uint64
{
  return 4398046511104arc4u64
}

subroutine get_byte1(): arc4.byte
{
  return 4arc4u8
}

subroutine get_byte2(): arc4.byte
{
  return 5arc4u8
}

subroutine get_byte3(): arc4.byte
{
  return 42arc4u8
}

subroutine get_byte4(): arc4.byte
{
  return 255arc4u8
}

subroutine get_u16_arr1(): arc4.dynamic_array<arc4.uint16>
{
  return new arc4.dynamic_array<arc4.uint16>(65535arc4u16, 0arc4u16, 42arc4u16)
}

subroutine get_u16_arr2(): arc4.dynamic_array<arc4.uint16>
{
  return new arc4.dynamic_array<arc4.uint16>(1arc4u16, 2arc4u16, 3arc4u16, 4arc4u16)
}