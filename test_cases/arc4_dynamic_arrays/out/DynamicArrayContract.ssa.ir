contract test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract:
    program approval:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.approval_program() -> bool:
            block@0: // L24
                let string1#0: bytes = "\x00\x03aye"
                let string2#0: bytes = "\x00\x03bee"
                let string3#0: bytes = "\x00\x05Hello"
                let uint1#0: bytes = 0x0000000000000003
                let uint2#0: bytes = 0x0000040000000000
                let array_data%0#0: bytes = 0x
                let array_data%0#1: bytes = (concat array_data%0#0 0x04)
                let array_data%0#2: bytes = (concat array_data%0#1 0x05)
                let byte_array1#0: bytes = array_data%0#2
                let array_data%1#0: bytes = 0x
                let array_data%1#1: bytes = (concat array_data%1#0 0x2a)
                let array_data%1#2: bytes = (concat array_data%1#1 0x50)
                let byte_array2#0: bytes = array_data%1#2
                let current_tail_offset%0#0: uint64 = 4u
                let encoded_tuple_buffer%0#0: bytes = 0x
                let value_as_bytes%0#0: bytes = (itob current_tail_offset%0#0)
                let value_as_uint16%0#0: bytes = ((extract 6 2) value_as_bytes%0#0)
                let encoded_tuple_buffer%0#1: bytes = (concat encoded_tuple_buffer%0#0 value_as_uint16%0#0)
                let data_length%0#0: uint64 = (len string1#0)
                let current_tail_offset%0#1: uint64 = (+ current_tail_offset%0#0 data_length%0#0)
                let value_as_bytes%1#0: bytes = (itob current_tail_offset%0#1)
                let value_as_uint16%1#0: bytes = ((extract 6 2) value_as_bytes%1#0)
                let encoded_tuple_buffer%0#2: bytes = (concat encoded_tuple_buffer%0#1 value_as_uint16%1#0)
                let data_length%1#0: uint64 = (len string2#0)
                let current_tail_offset%0#2: uint64 = (+ current_tail_offset%0#1 data_length%1#0)
                let encoded_tuple_buffer%0#3: bytes = (concat encoded_tuple_buffer%0#2 string1#0)
                let encoded_tuple_buffer%0#4: bytes = (concat encoded_tuple_buffer%0#3 string2#0)
                let dynamic_struct1#0: bytes = encoded_tuple_buffer%0#4
                let current_tail_offset%1#0: uint64 = 4u
                let encoded_tuple_buffer%1#0: bytes = 0x
                let value_as_bytes%2#0: bytes = (itob current_tail_offset%1#0)
                let value_as_uint16%2#0: bytes = ((extract 6 2) value_as_bytes%2#0)
                let encoded_tuple_buffer%1#1: bytes = (concat encoded_tuple_buffer%1#0 value_as_uint16%2#0)
                let data_length%2#0: uint64 = (len string3#0)
                let current_tail_offset%1#1: uint64 = (+ current_tail_offset%1#0 data_length%2#0)
                let value_as_bytes%3#0: bytes = (itob current_tail_offset%1#1)
                let value_as_uint16%3#0: bytes = ((extract 6 2) value_as_bytes%3#0)
                let encoded_tuple_buffer%1#2: bytes = (concat encoded_tuple_buffer%1#1 value_as_uint16%3#0)
                let data_length%3#0: uint64 = (len string1#0)
                let current_tail_offset%1#2: uint64 = (+ current_tail_offset%1#1 data_length%3#0)
                let encoded_tuple_buffer%1#3: bytes = (concat encoded_tuple_buffer%1#2 string3#0)
                let encoded_tuple_buffer%1#4: bytes = (concat encoded_tuple_buffer%1#3 string1#0)
                let dynamic_struct2#0: bytes = encoded_tuple_buffer%1#4
                let copy%0#0: bytes = dynamic_struct1#0
                let copy%1#0: bytes = dynamic_struct2#0
                let array_data%2#0: bytes = 0x0002
                let next_offset%0#0: uint64 = 4u
                let value_as_bytes%4#0: bytes = (itob next_offset%0#0)
                let value_as_uint16%4#0: bytes = ((extract 6 2) value_as_bytes%4#0)
                let array_data%2#1: bytes = (concat array_data%2#0 value_as_uint16%4#0)
                let element_length%0#0: uint64 = (len copy%0#0)
                let next_offset%0#1: uint64 = (+ next_offset%0#0 element_length%0#0)
                let value_as_bytes%5#0: bytes = (itob next_offset%0#1)
                let value_as_uint16%5#0: bytes = ((extract 6 2) value_as_bytes%5#0)
                let array_data%2#2: bytes = (concat array_data%2#1 value_as_uint16%5#0)
                let element_length%1#0: uint64 = (len copy%1#0)
                let next_offset%0#2: uint64 = (+ next_offset%0#1 element_length%1#0)
                let array_data%2#3: bytes = (concat array_data%2#2 copy%0#0)
                let array_data%2#4: bytes = (concat array_data%2#3 copy%1#0)
                let dynamic_array#0: bytes = array_data%2#4
                (log dynamic_array#0)
                let array_length%0#0: uint64 = (extract_uint16 dynamic_array#0 0u)
                let index_is_in_bounds%0#0: bool = (< 0u array_length%0#0)
                (assert index_is_in_bounds%0#0) // Index access is out of bounds
                let array_data_sans_header%0#0: bytes = ((extract 2 0) dynamic_array#0)
                let item_index_index%0#0: uint64 = (* 0u 2u)
                let item_index%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index_index%0#0)
                let item_length%0#0: uint64 = (extract_uint16 array_data_sans_header%0#0 item_index%0#0)
                let item_length_plus_2%0#0: uint64 = (+ item_length%0#0 2u)
                let tmp%0#0: bytes = (extract3 array_data_sans_header%0#0 item_index%0#0 item_length_plus_2%0#0)
                (log tmp%0#0)
                let array_length%1#0: uint64 = (extract_uint16 dynamic_array#0 0u)
                let index_is_in_bounds%1#0: bool = (< 1u array_length%1#0)
                (assert index_is_in_bounds%1#0) // Index access is out of bounds
                let array_data_sans_header%1#0: bytes = ((extract 2 0) dynamic_array#0)
                let item_index_index%1#0: uint64 = (* 1u 2u)
                let item_index%1#0: uint64 = (extract_uint16 array_data_sans_header%1#0 item_index_index%1#0)
                let item_length%1#0: uint64 = (extract_uint16 array_data_sans_header%1#0 item_index%1#0)
                let item_length_plus_2%1#0: uint64 = (+ item_length%1#0 2u)
                let tmp%1#0: bytes = (extract3 array_data_sans_header%1#0 item_index%1#0 item_length_plus_2%1#0)
                (log tmp%1#0)
                let current_tail_offset%2#0: uint64 = 10u
                let encoded_tuple_buffer%2#0: bytes = 0x
                let encoded_tuple_buffer%2#1: bytes = (concat encoded_tuple_buffer%2#0 uint1#0)
                let encoded_tuple_buffer%2#2: bytes = (concat encoded_tuple_buffer%2#1 byte_array1#0)
                let fixed1#0: bytes = encoded_tuple_buffer%2#2
                let current_tail_offset%3#0: uint64 = 10u
                let encoded_tuple_buffer%3#0: bytes = 0x
                let encoded_tuple_buffer%3#1: bytes = (concat encoded_tuple_buffer%3#0 uint2#0)
                let encoded_tuple_buffer%3#2: bytes = (concat encoded_tuple_buffer%3#1 byte_array2#0)
                let fixed2#0: bytes = encoded_tuple_buffer%3#2
                let copy%2#0: bytes = fixed1#0
                let copy%3#0: bytes = fixed2#0
                let array_data%3#0: bytes = 0x0002
                let array_data%3#1: bytes = (concat array_data%3#0 copy%2#0)
                let array_data%3#2: bytes = (concat array_data%3#1 copy%3#0)
                let dynamic_fixed#0: bytes = array_data%3#2
                (log dynamic_fixed#0)
                let array_length%2#0: uint64 = (extract_uint16 dynamic_fixed#0 0u)
                let index_is_in_bounds%2#0: bool = (< 0u array_length%2#0)
                (assert index_is_in_bounds%2#0) // Index access is out of bounds
                let array_data_sans_header%2#0: bytes = ((extract 2 0) dynamic_fixed#0)
                let item_index%2#0: uint64 = (* 0u 10u)
                let tmp%2#0: bytes = (extract3 array_data_sans_header%2#0 item_index%2#0 10u)
                (log tmp%2#0)
                let array_length%3#0: uint64 = (extract_uint16 dynamic_fixed#0 0u)
                let index_is_in_bounds%3#0: bool = (< 1u array_length%3#0)
                (assert index_is_in_bounds%3#0) // Index access is out of bounds
                let array_data_sans_header%3#0: bytes = ((extract 2 0) dynamic_fixed#0)
                let item_index%3#0: uint64 = (* 1u 10u)
                let tmp%3#0: bytes = (extract3 array_data_sans_header%3#0 item_index%3#0 10u)
                (log tmp%3#0)
                let current_tail_offset%4#0: uint64 = 18u
                let encoded_tuple_buffer%4#0: bytes = 0x
                let encoded_tuple_buffer%4#1: bytes = (concat encoded_tuple_buffer%4#0 uint1#0)
                let value_as_bytes%6#0: bytes = (itob current_tail_offset%4#0)
                let value_as_uint16%6#0: bytes = ((extract 6 2) value_as_bytes%6#0)
                let encoded_tuple_buffer%4#2: bytes = (concat encoded_tuple_buffer%4#1 value_as_uint16%6#0)
                let data_length%4#0: uint64 = (len string1#0)
                let current_tail_offset%4#1: uint64 = (+ current_tail_offset%4#0 data_length%4#0)
                let encoded_tuple_buffer%4#3: bytes = (concat encoded_tuple_buffer%4#2 uint2#0)
                let encoded_tuple_buffer%4#4: bytes = (concat encoded_tuple_buffer%4#3 string1#0)
                let mixed1#0: bytes = encoded_tuple_buffer%4#4
                let current_tail_offset%5#0: uint64 = 18u
                let encoded_tuple_buffer%5#0: bytes = 0x
                let encoded_tuple_buffer%5#1: bytes = (concat encoded_tuple_buffer%5#0 uint2#0)
                let value_as_bytes%7#0: bytes = (itob current_tail_offset%5#0)
                let value_as_uint16%7#0: bytes = ((extract 6 2) value_as_bytes%7#0)
                let encoded_tuple_buffer%5#2: bytes = (concat encoded_tuple_buffer%5#1 value_as_uint16%7#0)
                let data_length%5#0: uint64 = (len string2#0)
                let current_tail_offset%5#1: uint64 = (+ current_tail_offset%5#0 data_length%5#0)
                let encoded_tuple_buffer%5#3: bytes = (concat encoded_tuple_buffer%5#2 uint1#0)
                let encoded_tuple_buffer%5#4: bytes = (concat encoded_tuple_buffer%5#3 string2#0)
                let mixed2#0: bytes = encoded_tuple_buffer%5#4
                let copy%4#0: bytes = mixed1#0
                let copy%5#0: bytes = mixed2#0
                let array_data%4#0: bytes = 0x0002
                let next_offset%1#0: uint64 = 4u
                let value_as_bytes%8#0: bytes = (itob next_offset%1#0)
                let value_as_uint16%8#0: bytes = ((extract 6 2) value_as_bytes%8#0)
                let array_data%4#1: bytes = (concat array_data%4#0 value_as_uint16%8#0)
                let element_length%2#0: uint64 = (len copy%4#0)
                let next_offset%1#1: uint64 = (+ next_offset%1#0 element_length%2#0)
                let value_as_bytes%9#0: bytes = (itob next_offset%1#1)
                let value_as_uint16%9#0: bytes = ((extract 6 2) value_as_bytes%9#0)
                let array_data%4#2: bytes = (concat array_data%4#1 value_as_uint16%9#0)
                let element_length%3#0: uint64 = (len copy%5#0)
                let next_offset%1#2: uint64 = (+ next_offset%1#1 element_length%3#0)
                let array_data%4#3: bytes = (concat array_data%4#2 copy%4#0)
                let array_data%4#4: bytes = (concat array_data%4#3 copy%5#0)
                let dynamic_mixed#0: bytes = array_data%4#4
                (log dynamic_mixed#0)
                let array_length%4#0: uint64 = (extract_uint16 dynamic_mixed#0 0u)
                let index_is_in_bounds%4#0: bool = (< 0u array_length%4#0)
                (assert index_is_in_bounds%4#0) // Index access is out of bounds
                let array_data_sans_header%4#0: bytes = ((extract 2 0) dynamic_mixed#0)
                let item_index_index%2#0: uint64 = (* 0u 2u)
                let item_index%4#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index_index%2#0)
                let item_length%2#0: uint64 = (extract_uint16 array_data_sans_header%4#0 item_index%4#0)
                let item_length_plus_2%2#0: uint64 = (+ item_length%2#0 2u)
                let tmp%4#0: bytes = (extract3 array_data_sans_header%4#0 item_index%4#0 item_length_plus_2%2#0)
                (log tmp%4#0)
                let array_length%5#0: uint64 = (extract_uint16 dynamic_mixed#0 0u)
                let index_is_in_bounds%5#0: bool = (< 1u array_length%5#0)
                (assert index_is_in_bounds%5#0) // Index access is out of bounds
                let array_data_sans_header%5#0: bytes = ((extract 2 0) dynamic_mixed#0)
                let item_index_index%3#0: uint64 = (* 1u 2u)
                let item_index%5#0: uint64 = (extract_uint16 array_data_sans_header%5#0 item_index_index%3#0)
                let item_length%3#0: uint64 = (extract_uint16 array_data_sans_header%5#0 item_index%5#0)
                let item_length_plus_2%3#0: uint64 = (+ item_length%3#0 2u)
                let tmp%5#0: bytes = (extract3 array_data_sans_header%5#0 item_index%5#0 item_length_plus_2%3#0)
                (log tmp%5#0)
                return 1u
    
    program clear-state:
        subroutine test_cases.arc4_dynamic_arrays.contract.DynamicArrayContract.clear_state_program() -> bool:
            block@0: // L56
                return 1u