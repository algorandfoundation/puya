#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock 0x 0x151f7c75 0x0000 0x00 0x0002 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 0x000a 0x62696775696e74 0x000200000000000000010000000000000002 0x000200040007000161000162 "imm_fixed_arr"
    // array/immutable.py:93
    // class ImmutableArrayContract(arc4.ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@31
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x44d42f99 0xb7eaa60b 0x743d70ed 0x1c7e0494 0xa2d5860b 0xe05fc564 0x1e092b83 0x01310262 0xc8654a98 0x89d196f8 0x6cb7c991 0x9898bf02 0xf6b61ee8 0x60b86a7b 0x73ad283f 0x529dfae9 0x206d514f 0xe06465e2 0xec0300a2 0xecdf14af 0x511aca64 0x29852e4f 0x6d4aa358 0xb7cb96bd // method "test_uint64_array()void", method "test_biguint_array()void", method "test_bool_array(uint64)void", method "test_fixed_size_tuple_array()void", method "test_fixed_size_named_tuple_array()void", method "test_dynamic_sized_tuple_array()void", method "test_dynamic_sized_named_tuple_array()void", method "test_implicit_conversion_log(uint64[])void", method "test_implicit_conversion_emit(uint64[])void", method "test_nested_array(uint64,uint64[][])uint64[]", method "test_bit_packed_tuples()void", method "sum_uints_and_lengths_and_trues(uint64[],bool[],(uint64,bool,bool)[],(uint64,string)[])(uint64,uint64,uint64,uint64)", method "test_uint64_return(uint64)uint64[]", method "test_bool_return(uint64)bool[]", method "test_tuple_return(uint64)(uint64,bool,bool)[]", method "test_dynamic_tuple_return(uint64)(uint64,string)[]", method "test_convert_to_array_and_back((uint64,bool,bool)[],uint64)(uint64,bool,bool)[]", method "test_concat_with_arc4_tuple((uint64,uint64))uint64[]", method "test_concat_with_native_tuple((uint64,uint64))uint64[]", method "test_dynamic_concat_with_arc4_tuple((string,string))string[]", method "test_dynamic_concat_with_native_tuple((string,string))string[]", method "test_concat_immutable_dynamic((uint64,string)[],(uint64,string)[])(uint64,string)[]", method "test_immutable_arc4((uint64,uint64)[])(uint64,uint64)[]", method "test_imm_fixed_arr()(uint64,uint64)[3]"
    txna ApplicationArgs 0
    match test_uint64_array test_biguint_array test_bool_array test_fixed_size_tuple_array test_fixed_size_named_tuple_array test_dynamic_sized_tuple_array test_dynamic_sized_named_tuple_array test_implicit_conversion_log test_implicit_conversion_emit test_nested_array test_bit_packed_tuples sum_uints_and_lengths_and_trues test_uint64_return test_bool_return test_tuple_return test_dynamic_tuple_return test_convert_to_array_and_back test_concat_with_arc4_tuple test_concat_with_native_tuple test_dynamic_concat_with_arc4_tuple test_dynamic_concat_with_native_tuple test_concat_immutable_dynamic test_immutable_arc4 test_imm_fixed_arr
    err

main___algopy_default_create@31:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// _puya_lib.arc4.dynamic_array_pop_fixed_size(array: bytes, fixed_byte_size: uint64) -> bytes, bytes:
dynamic_array_pop_fixed_size:
    proto 2 2
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    itob
    extract 6 0
    frame_dig -2
    swap
    replace2 0
    dup
    len
    frame_dig -1
    -
    dup2
    frame_dig -1
    extract3
    uncover 2
    intc_0 // 0
    uncover 3
    substring3
    retsub


// _puya_lib.arc4.dynamic_array_pop_dynamic_element(array: bytes) -> bytes, bytes:
dynamic_array_pop_dynamic_element:
    proto 1 2
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    dup
    intc_2 // 2
    *
    dup
    frame_dig -1
    extract 2 0
    dup
    cover 2
    dup
    uncover 2
    extract_uint16
    dup
    uncover 2
    dup
    len
    swap
    cover 2
    substring3
    bytec_0 // 0x
    intc_0 // 0

dynamic_array_pop_dynamic_element_for_header@1:
    frame_dig 6
    frame_dig 1
    <
    bz dynamic_array_pop_dynamic_element_after_for@4
    frame_dig 2
    frame_dig 6
    dup
    cover 2
    extract_uint16
    intc_2 // 2
    -
    itob
    extract 6 2
    frame_dig 5
    swap
    concat
    frame_bury 5
    intc_2 // 2
    +
    frame_bury 6
    b dynamic_array_pop_dynamic_element_for_header@1

dynamic_array_pop_dynamic_element_after_for@4:
    frame_dig 0
    itob
    extract 6 2
    frame_dig 5
    concat
    frame_dig 1
    intc_2 // 2
    +
    frame_dig 2
    swap
    frame_dig 3
    substring3
    concat
    frame_dig 4
    frame_bury 0
    frame_bury 1
    retsub


// _puya_lib.arc4.dynamic_array_concat_bits(array: bytes, new_items_bytes: bytes, new_items_count: uint64, read_step: uint64) -> bytes:
dynamic_array_concat_bits:
    proto 4 1
    bytec_0 // ""
    dupn 2
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dupn 2
    frame_dig -2
    +
    dup
    itob
    extract 6 0
    frame_dig -4
    swap
    replace2 0
    cover 2
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    uncover 2
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    cover 2
    <
    bz dynamic_array_concat_bits_after_if_else@2
    frame_dig 6
    frame_dig 5
    -
    bzero
    frame_dig 4
    swap
    concat
    frame_bury 4

dynamic_array_concat_bits_after_if_else@2:
    intc_0 // 0
    frame_bury 0
    frame_dig 3
    pushint 16 // 16
    +
    dup
    frame_bury 2
    frame_dig -2
    +
    frame_bury 1

dynamic_array_concat_bits_while_top@3:
    frame_dig 2
    frame_dig 1
    <
    bz dynamic_array_concat_bits_after_while@5
    frame_dig -3
    frame_dig 0
    dup
    cover 2
    getbit
    frame_dig 4
    frame_dig 2
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 4
    intc_1 // 1
    +
    frame_bury 2
    frame_dig -1
    +
    frame_bury 0
    b dynamic_array_concat_bits_while_top@3

dynamic_array_concat_bits_after_while@5:
    frame_dig 4
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_0 // 0

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@4
    frame_dig 3
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 4
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 3
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@4:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_0 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_0 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_0 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// test_cases.array.immutable.sum_imm_fixed(arr: bytes) -> uint64:
sum_imm_fixed:
    // array/immutable.py:479-480
    // @subroutine
    // def sum_imm_fixed(arr: NativeStruct3) -> UInt64:
    proto 1 1
    // array/immutable.py:481
    // total = UInt64(0)
    intc_0 // 0
    dup

sum_imm_fixed_for_header@1:
    // array/immutable.py:482
    // for item in arr:
    frame_dig 1
    pushint 3 // 3
    <
    bz sum_imm_fixed_after_for@4
    // array/immutable.py:482-483
    // for item in arr:
    //     total += item.foo
    frame_dig 1
    dup
    pushint 16 // 16
    *
    frame_dig -1
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    // array/immutable.py:483
    // total += item.foo
    dup
    // array/immutable.py:482-483
    // for item in arr:
    //     total += item.foo
    intc_0 // 0
    // array/immutable.py:483
    // total += item.foo
    extract_uint64
    frame_dig 0
    +
    // array/immutable.py:484
    // total += item.bar
    swap
    intc_3 // 8
    extract_uint64
    +
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 1
    b sum_imm_fixed_for_header@1

sum_imm_fixed_after_for@4:
    // array/immutable.py:485
    // return total
    retsub


// test_cases.array.immutable.times(n: uint64) -> bytes:
times:
    // array/immutable.py:488-489
    // @subroutine
    // def times(n: UInt64) -> String:
    proto 1 1
    // array/immutable.py:490
    // result = String()
    bytec_0 // ""
    // array/immutable.py:491
    // for _i in urange(n):
    intc_0 // 0

times_for_header@1:
    // array/immutable.py:491
    // for _i in urange(n):
    frame_dig 1
    frame_dig -1
    <
    bz times_after_for@4
    // array/immutable.py:492
    // result += String(" ")
    frame_dig 0
    pushbytes " "
    concat
    frame_bury 0
    // array/immutable.py:491
    // for _i in urange(n):
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b times_for_header@1

times_after_for@4:
    // array/immutable.py:493
    // return result
    retsub


// test_cases.array.immutable.add_x(arr: bytes, x: uint64) -> bytes:
add_x:
    // array/immutable.py:496-497
    // @subroutine
    // def add_x(arr: ImmutableArray[UInt64], x: UInt64) -> ImmutableArray[UInt64]:
    proto 2 1
    // array/immutable.py:498
    // for i in urange(x):
    intc_0 // 0

add_x_for_header@1:
    // array/immutable.py:498
    // for i in urange(x):
    frame_dig 0
    frame_dig -1
    <
    bz add_x_after_for@4
    // array/immutable.py:499
    // arr = arr.append(i)
    frame_dig 0
    dup
    itob
    frame_dig -2
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury -2
    // array/immutable.py:498
    // for i in urange(x):
    intc_1 // 1
    +
    frame_bury 0
    b add_x_for_header@1

add_x_after_for@4:
    // array/immutable.py:500
    // return arr
    frame_dig -2
    swap
    retsub


// test_cases.array.immutable.ImmutableArrayContract.test_uint64_array[routing]() -> void:
test_uint64_array:
    // array/immutable.py:99
    // arr = arr.append(UInt64(42))
    pushbytes 0x0001000000000000002a
    // array/immutable.py:103
    // arr = add_x(arr, UInt64(5))
    pushint 5 // 5
    callsub add_x
    // array/immutable.py:104
    // assert arr.length == 6
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 6 // 6
    ==
    assert
    // array/immutable.py:105
    // assert arr[-1] == 4
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 4 // 4
    ==
    assert
    // array/immutable.py:107
    // arr = arr.append(UInt64(43))
    pushint 43 // 43
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dupn 2
    // array/immutable.py:108
    // assert arr.length == 7
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 7 // 7
    ==
    assert
    // array/immutable.py:109
    // assert arr[-1] == 43
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 43 // 43
    ==
    assert
    intc_2 // 2
    // array/immutable.py:110
    // assert arr[0] == 42
    extract_uint64
    pushint 42 // 42
    ==
    assert
    // array/immutable.py:505
    // for _i in urange(x):
    intc_0 // 0

test_uint64_array_for_header@2:
    // array/immutable.py:505
    // for _i in urange(x):
    dup
    // array/immutable.py:112
    // arr = pop_x(arr, UInt64(3))
    pushint 3 // 3
    // array/immutable.py:505
    // for _i in urange(x):
    <
    bz test_uint64_array_after_for@4
    // array/immutable.py:506
    // arr = arr.pop()
    dig 1
    intc_3 // 8
    callsub dynamic_array_pop_fixed_size
    bury 3
    pop
    // array/immutable.py:505
    // for _i in urange(x):
    dup
    intc_1 // 1
    +
    bury 1
    b test_uint64_array_for_header@2

test_uint64_array_after_for@4:
    // array/immutable.py:113
    // assert arr.length == 4
    dig 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    // array/immutable.py:114
    // assert arr[-1] == 2
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    intc_2 // 2
    ==
    assert
    // array/immutable.py:116
    // arr = add_x(arr, UInt64(10))
    pushint 10 // 10
    callsub add_x
    // array/immutable.py:117
    // assert arr.length == 14
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 14 // 14
    ==
    assert
    // array/immutable.py:118
    // assert arr[-1] == 9
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 9 // 9
    ==
    assert
    // array/immutable.py:120
    // arr = arr.append(UInt64(44))
    pushint 44 // 44
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    // array/immutable.py:121
    // assert arr.length == 15
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 15 // 15
    ==
    assert
    // array/immutable.py:122
    // assert arr[-1] == 44
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 44 // 44
    ==
    assert
    // array/immutable.py:124
    // arr = arr.replace(2, UInt64(23))
    pushint 23 // 23
    itob
    replace2 18 // on error: index access is out of bounds
    // array/immutable.py:125
    // assert arr.length == 15
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 15 // 15
    ==
    assert
    // array/immutable.py:126
    // assert arr[2] == 23
    dup
    pushint 18 // 18
    extract_uint64
    pushint 23 // 23
    ==
    assert
    // array/immutable.py:128
    // self.a = arr
    pushbytes "a"
    swap
    app_global_put
    // array/immutable.py:94
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_biguint_array[routing]() -> void:
test_biguint_array:
    // array/immutable.py:135
    // arr = arr.append(BigUInt(Txn.num_app_args - 1))
    txn NumAppArgs
    intc_1 // 1
    -
    itob
    pushint 64 // 64
    bzero
    dup
    cover 2
    b|
    // array/immutable.py:132
    // arr = ImmutableArray[BigUInt]()
    bytec_2 // 0x0000
    // array/immutable.py:135
    // arr = arr.append(BigUInt(Txn.num_app_args - 1))
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0001
    replace2 0
    dupn 2
    // array/immutable.py:136
    // assert arr.length == 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_1 // 1
    ==
    assert
    // array/immutable.py:137
    // assert arr[-1] == 0
    intc_1 // 1
    -
    swap
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec_0 // 0x
    b==
    assert
    // array/immutable.py:512
    // for i in urange(x):
    intc_0 // 0

test_biguint_array_for_header@2:
    // array/immutable.py:512
    // for i in urange(x):
    dup
    // array/immutable.py:139
    // arr = add_xb(arr, UInt64(5))
    pushint 5 // 5
    // array/immutable.py:512
    // for i in urange(x):
    <
    bz test_biguint_array_after_for@4
    // array/immutable.py:513
    // arr = arr.append(BigUInt(i))
    dupn 2
    itob
    dig 4
    b|
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    // array/immutable.py:512
    // for i in urange(x):
    intc_1 // 1
    +
    bury 1
    b test_biguint_array_for_header@2

test_biguint_array_after_for@4:
    // array/immutable.py:140
    // assert arr.length == 6
    dig 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 6 // 6
    ==
    assert
    // array/immutable.py:141
    // assert arr[-1] == 4
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0x04
    b==
    assert
    // array/immutable.py:143
    // arr = arr.append(BigUInt(2**512 - 1) - Txn.num_app_args)
    txn NumAppArgs
    itob
    bytec 5 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    swap
    b-
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    dig 5
    b|
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    // array/immutable.py:144
    // assert arr.length == 7
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 7 // 7
    ==
    assert
    // array/immutable.py:145
    // assert arr[-1] == 2**512 - 2
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
    b==
    assert
    // array/immutable.py:146
    // assert arr[0] == 0
    dig 1
    extract 2 64
    bytec_0 // 0x
    b==
    assert
    // array/immutable.py:148
    // arr = arr.append(BigUInt(2**512 - 1))
    swap
    bytec 5 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    // array/immutable.py:149
    // assert arr.length == 8
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_3 // 8
    ==
    assert
    // array/immutable.py:150
    // assert arr[-1] == 2**512 - 1
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec 5 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    b==
    assert
    // array/immutable.py:151
    // assert arr[0] == 0
    dup
    extract 2 64
    bytec_0 // 0x
    b==
    assert
    // array/immutable.py:153
    // Box(ImmutableArray[BigUInt], key=b"biguint").value = arr
    bytec 7 // 0x62696775696e74
    box_del
    pop
    bytec 7 // 0x62696775696e74
    swap
    box_put
    // array/immutable.py:130
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_bool_array[routing]() -> void:
test_bool_array:
    bytec_0 // ""
    // array/immutable.py:155
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // array/immutable.py:157
    // arr = ImmutableArray[bool]()
    bytec_2 // 0x0000
    // array/immutable.py:160
    // for i in urange(length):
    intc_0 // 0

test_bool_array_for_header@2:
    // array/immutable.py:160
    // for i in urange(length):
    dup
    dig 3
    <
    bz test_bool_array_after_for@5
    // array/immutable.py:161
    // arr = arr.append(i == Txn.num_app_args)
    txn NumAppArgs
    dig 1
    dup
    uncover 2
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 3
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 3
    // array/immutable.py:160
    // for i in urange(length):
    intc_1 // 1
    +
    bury 1
    b test_bool_array_for_header@2

test_bool_array_after_for@5:
    // array/immutable.py:163
    // assert arr.length == length
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 5
    dig 3
    dup
    cover 2
    ==
    assert
    // array/immutable.py:165
    // if length > 0:
    bz test_bool_array_after_if_else@7
    // array/immutable.py:166
    // assert not arr[0], "expected element 0 to be False"
    dig 3
    assert // index access is out of bounds
    dig 1
    pushint 16 // 16
    getbit
    !
    assert // expected element 0 to be False

test_bool_array_after_if_else@7:
    // array/immutable.py:167
    // if length > 1:
    dig 2
    intc_1 // 1
    >
    bz test_bool_array_after_if_else@9
    // array/immutable.py:168
    // assert not arr[1], "expected element 1 to be False"
    intc_1 // 1
    dig 4
    <
    assert // index access is out of bounds
    dig 1
    pushint 17 // 17
    getbit
    !
    assert // expected element 1 to be False

test_bool_array_after_if_else@9:
    // array/immutable.py:169
    // if length > 2:
    dig 2
    intc_2 // 2
    >
    bz test_bool_array_after_if_else@11
    // array/immutable.py:170
    // assert arr[2], "expected element 2 to be True"
    intc_2 // 2
    dig 4
    <
    assert // index access is out of bounds
    dig 1
    pushint 18 // 18
    getbit
    assert // expected element 2 to be True

test_bool_array_after_if_else@11:
    // array/immutable.py:171
    // if length > 3:
    dig 2
    pushint 3 // 3
    >
    bz test_bool_array_after_if_else@13
    // array/immutable.py:172
    // assert not arr[length - 1], "expected last element to be False"
    dig 2
    intc_1 // 1
    -
    dup
    dig 5
    <
    assert // index access is out of bounds
    pushint 16 // 16
    +
    dig 2
    swap
    getbit
    !
    assert // expected last element to be False

test_bool_array_after_if_else@13:
    // array/immutable.py:174
    // self.g = arr
    pushbytes "g"
    dig 2
    app_global_put
    // array/immutable.py:175
    // if length:
    dig 2
    bz test_bool_array_after_if_else@15
    dig 3
    intc_1 // 1
    -
    dup
    itob
    extract 6 0
    dig 3
    swap
    replace2 0
    dig 1
    pushint 16 // 16
    +
    intc_0 // 0
    setbit
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    intc_0 // 0
    swap
    substring3
    // array/immutable.py:177
    // assert arr.length == length - 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dig 3
    intc_1 // 1
    -
    ==
    assert

test_bool_array_after_if_else@15:
    // array/immutable.py:155
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_fixed_size_tuple_array[routing]() -> void:
test_fixed_size_tuple_array:
    // array/immutable.py:181
    // arr = ImmutableArray[tuple[UInt64, UInt64]]()
    bytec_2 // 0x0000
    // array/immutable.py:184
    // for i in urange(5):
    intc_0 // 0

test_fixed_size_tuple_array_for_header@2:
    // array/immutable.py:184
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_fixed_size_tuple_array_after_for@5
    // array/immutable.py:185
    // arr = arr.append((i + 1, i + 2))
    dupn 2
    intc_1 // 1
    +
    swap
    intc_2 // 2
    +
    dig 1
    itob
    swap
    itob
    concat
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    bury 1
    b test_fixed_size_tuple_array_for_header@2

test_fixed_size_tuple_array_after_for@5:
    // array/immutable.py:187
    // assert arr.length == 5
    dig 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:188
    // assert arr[0] == (UInt64(1), UInt64(2))
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    // array/immutable.py:189
    // assert arr[-1] == (UInt64(5), UInt64(6))
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 5 // 5
    ==
    swap
    pushint 6 // 6
    ==
    &&
    assert
    // array/immutable.py:191
    // arr = arr.pop()
    pushint 16 // 16
    callsub dynamic_array_pop_fixed_size
    bury 1
    // array/immutable.py:192
    // assert arr.length == 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    // array/immutable.py:193
    // assert arr[0] == (UInt64(1), UInt64(2))
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    // array/immutable.py:194
    // assert arr[-1] == (UInt64(4), UInt64(5))
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 4 // 4
    ==
    swap
    pushint 5 // 5
    ==
    &&
    assert
    // array/immutable.py:195
    // self.c = arr
    pushbytes "c"
    swap
    app_global_put
    // array/immutable.py:179
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_fixed_size_named_tuple_array[routing]() -> void:
test_fixed_size_named_tuple_array:
    // array/immutable.py:199
    // arr = ImmutableArray[MyTuple]()
    bytec_2 // 0x0000
    // array/immutable.py:202
    // for i in urange(5):
    intc_0 // 0

test_fixed_size_named_tuple_array_for_header@2:
    // array/immutable.py:202
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_fixed_size_named_tuple_array_after_for@5
    // array/immutable.py:203
    // arr = arr.append(MyTuple(foo=i, bar=i % 2 == 0, baz=i * 3 % 2 == 0))
    dupn 2
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    *
    intc_2 // 2
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    // array/immutable.py:202
    // for i in urange(5):
    intc_1 // 1
    +
    bury 1
    b test_fixed_size_named_tuple_array_for_header@2

test_fixed_size_named_tuple_array_after_for@5:
    // array/immutable.py:205
    // assert arr.length == 5
    dig 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:206
    // foo, bar, baz = arr[0]
    dup
    extract 2 9
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    // array/immutable.py:207
    // assert foo == 0
    uncover 2
    !
    assert
    // array/immutable.py:208
    // assert bar
    swap
    assert
    // array/immutable.py:209
    // assert baz
    assert
    // array/immutable.py:210
    // self.d = arr
    pushbytes "d"
    swap
    app_global_put
    // array/immutable.py:197
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_dynamic_sized_tuple_array[routing]() -> void:
test_dynamic_sized_tuple_array:
    bytec_0 // ""
    // array/immutable.py:214
    // arr = ImmutableArray[tuple[UInt64, Bytes]]()
    bytec_2 // 0x0000
    // array/immutable.py:217
    // for i in urange(5):
    intc_0 // 0

test_dynamic_sized_tuple_array_for_header@2:
    // array/immutable.py:217
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_dynamic_sized_tuple_array_after_for@5
    // array/immutable.py:218
    // arr = arr.append((i + 1, op.bzero(i)))
    dupn 2
    intc_1 // 1
    +
    swap
    bzero
    dig 3
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 6 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 3
    bury 1
    b test_dynamic_sized_tuple_array_for_header@2

test_dynamic_sized_tuple_array_after_for@5:
    // array/immutable.py:220
    // assert arr.length == 5
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 4
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:221
    // for i in urange(5):
    intc_0 // 0
    bury 1

test_dynamic_sized_tuple_array_for_header@6:
    // array/immutable.py:221
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_dynamic_sized_tuple_array_after_for@9
    // array/immutable.py:222
    // assert arr[i][0] == i + 1, "expected 1st element to be correct"
    dig 1
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 6
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    uncover 3
    uncover 3
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    // array/immutable.py:223
    // assert arr[i][1].length == i, "expected 2nd element to be correct"
    len
    uncover 2
    ==
    assert // expected 2nd element to be correct
    bury 1
    b test_dynamic_sized_tuple_array_for_header@6

test_dynamic_sized_tuple_array_after_for@9:
    // array/immutable.py:225
    // arr = arr.pop()
    dig 1
    callsub dynamic_array_pop_dynamic_element
    bury 1
    // array/immutable.py:226
    // assert arr.length == 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    // array/immutable.py:227
    // assert arr[0] == (UInt64(1), op.bzero(0)), "expected 1, 0"
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    intc_0 // 0
    bzero
    uncover 2
    ==
    &&
    assert // expected 1, 0
    // array/immutable.py:228
    // assert arr[-1] == (UInt64(4), op.bzero(3)), "expected 4, 3"
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    pushint 3 // 3
    bzero
    uncover 2
    ==
    &&
    assert // expected 4, 3
    // array/immutable.py:229
    // self.e = arr
    pushbytes "e"
    swap
    app_global_put
    // array/immutable.py:212
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_dynamic_sized_named_tuple_array[routing]() -> void:
test_dynamic_sized_named_tuple_array:
    bytec_0 // ""
    // array/immutable.py:233
    // arr = ImmutableArray[MyDynamicSizedTuple]()
    bytec_2 // 0x0000
    // array/immutable.py:236
    // for i in urange(5):
    intc_0 // 0

test_dynamic_sized_named_tuple_array_for_header@2:
    // array/immutable.py:236
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_dynamic_sized_named_tuple_array_after_for@5
    // array/immutable.py:237
    // arr = arr.append(MyDynamicSizedTuple(foo=i + 1, bar=times(i)))
    dupn 2
    intc_1 // 1
    +
    swap
    callsub times
    dig 3
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 6 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 3
    bury 1
    b test_dynamic_sized_named_tuple_array_for_header@2

test_dynamic_sized_named_tuple_array_after_for@5:
    // array/immutable.py:239
    // assert arr.length == 5
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 4
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:240
    // for i in urange(5):
    intc_0 // 0
    bury 1

test_dynamic_sized_named_tuple_array_for_header@6:
    // array/immutable.py:240
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_dynamic_sized_named_tuple_array_after_for@9
    // array/immutable.py:241
    // assert arr[i][0] == i + 1, "expected 1st element to be correct"
    dig 1
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 6
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    uncover 3
    uncover 3
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    // array/immutable.py:242
    // assert arr[i][1] == times(i), "expected 2nd element to be correct"
    uncover 2
    callsub times
    ==
    assert // expected 2nd element to be correct
    bury 1
    b test_dynamic_sized_named_tuple_array_for_header@6

test_dynamic_sized_named_tuple_array_after_for@9:
    // array/immutable.py:244
    // arr = arr.pop()
    dig 1
    callsub dynamic_array_pop_dynamic_element
    bury 1
    // array/immutable.py:245
    // assert arr.length == 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    // array/immutable.py:246
    // assert arr[0] == MyDynamicSizedTuple(UInt64(1), String()), "expected 1, 0"
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    swap
    bytec_0 // ""
    ==
    &&
    assert // expected 1, 0
    // array/immutable.py:247
    // assert arr[-1] == MyDynamicSizedTuple(UInt64(4), String("   ")), "expected 4, 3"
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    swap
    pushbytes "   "
    ==
    &&
    assert // expected 4, 3
    // array/immutable.py:248
    // self.f = arr
    pushbytes "f"
    swap
    app_global_put
    // array/immutable.py:231
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_implicit_conversion_log[routing]() -> void:
test_implicit_conversion_log:
    // array/immutable.py:250
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    // array/immutable.py:252
    // log(arr)
    log
    // array/immutable.py:250
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_implicit_conversion_emit[routing]() -> void:
test_implicit_conversion_emit:
    // array/immutable.py:254
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    // array/immutable.py:256
    // arc4.emit("emit_test", arr)
    pushbytes 0xfa40c0530002
    swap
    concat
    log
    // array/immutable.py:254
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_nested_array[routing]() -> void:
test_nested_array:
    intc_0 // 0
    dupn 2
    bytec_0 // ""
    dupn 6
    // array/immutable.py:258
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 2
    *
    swap
    dup
    len
    swap
    extract 2 0
    intc_0 // 0

test_nested_array_for_header@1:
    // array/immutable.py:258
    // @arc4.abimethod()
    dup
    dig 5
    <
    bz test_nested_array_after_for@4
    dupn 2
    intc_2 // 2
    *
    dig 3
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 7
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    +
    bury 5
    intc_1 // 1
    +
    bury 1
    b test_nested_array_for_header@1

test_nested_array_after_for@4:
    // array/immutable.py:258
    // @arc4.abimethod()
    dig 3
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.dynamic_array<uint64>>
    // array/immutable.py:262-263
    // # add n new arrays
    // for i in urange(arr_to_add):
    intc_0 // 0
    bury 12

test_nested_array_for_header@6:
    // array/immutable.py:262-263
    // # add n new arrays
    // for i in urange(arr_to_add):
    dig 11
    dig 7
    <
    bz test_nested_array_after_for@13
    // array/immutable.py:264
    // extra_arr = ImmutableArray[UInt64]()
    bytec_2 // 0x0000
    bury 17
    // array/immutable.py:265
    // for j in urange(i):
    intc_0 // 0
    bury 9

test_nested_array_for_header@8:
    // array/immutable.py:265
    // for j in urange(i):
    dig 8
    dig 12
    <
    bz test_nested_array_after_for@11
    // array/immutable.py:266
    // extra_arr = extra_arr.append(j)
    dig 8
    dup
    itob
    dig 18
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 18
    // array/immutable.py:265
    // for j in urange(i):
    intc_1 // 1
    +
    bury 9
    b test_nested_array_for_header@8

test_nested_array_after_for@11:
    // array/immutable.py:267
    // arr = arr.append(extra_arr)
    dig 5
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 4 // 0x0002
    dig 19
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 6
    // array/immutable.py:262-263
    // # add n new arrays
    // for i in urange(arr_to_add):
    dig 11
    intc_1 // 1
    +
    bury 12
    b test_nested_array_for_header@6

test_nested_array_after_for@13:
    // array/immutable.py:269-270
    // # sum inner arrays and return an array containing sums
    // totals = ImmutableArray[UInt64]()
    bytec_2 // 0x0000
    bury 15
    // array/immutable.py:271
    // for inner_arr in arr:
    dig 5
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 14
    intc_0 // 0
    bury 11

test_nested_array_for_header@14:
    // array/immutable.py:271
    // for inner_arr in arr:
    dig 10
    dig 14
    <
    bz test_nested_array_after_for@17
    dig 5
    extract 2 0
    dig 11
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    extract3
    dup
    bury 17
    // array/immutable.py:519
    // total = UInt64()
    intc_0 // 0
    bury 9
    // array/immutable.py:520
    // for i in arr:
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 13
    intc_0 // 0
    bury 10

test_nested_array_for_header@19:
    // array/immutable.py:520
    // for i in arr:
    dig 9
    dig 13
    <
    bz test_nested_array_after_for@21
    dig 15
    extract 2 0
    dig 10
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    // array/immutable.py:521
    // total += i
    dig 9
    +
    bury 9
    intc_1 // 1
    +
    bury 10
    b test_nested_array_for_header@19

test_nested_array_after_for@21:
    // array/immutable.py:272
    // totals = totals.append(sum_arr(inner_arr))
    dig 7
    itob
    dig 15
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 15
    dig 10
    intc_1 // 1
    +
    bury 11
    b test_nested_array_for_header@14

test_nested_array_after_for@17:
    // array/immutable.py:258
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    dig 15
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_bit_packed_tuples[routing]() -> void:
test_bit_packed_tuples:
    // array/immutable.py:278
    // arr2 = ImmutableArray[TwoBoolTuple]()
    bytec_2 // 0x0000
    // array/immutable.py:279-281
    // arr7 = ImmutableArray[SevenBoolTuple]()
    // arr8 = ImmutableArray[EightBoolTuple]()
    // arr9 = ImmutableArray[NineBoolTuple]()
    dupn 3
    // array/immutable.py:287
    // for i in urange(5):
    intc_0 // 0

test_bit_packed_tuples_for_header@2:
    // array/immutable.py:287
    // for i in urange(5):
    dup
    pushint 5 // 5
    <
    bz test_bit_packed_tuples_after_for@5
    // array/immutable.py:288
    // arr2 = arr2.append(TwoBoolTuple(a=i == 0, b=i == 1))
    dupn 2
    !
    dig 1
    intc_1 // 1
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    intc_1 // 1
    uncover 2
    setbit
    dig 6
    dup
    cover 2
    dig 1
    concat // on error: max array length exceeded
    uncover 2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 7
    // array/immutable.py:292
    // bar=i + 1,
    dig 1
    intc_1 // 1
    +
    // array/immutable.py:295
    // c=i == 2,
    dig 2
    intc_2 // 2
    ==
    // array/immutable.py:296
    // d=i == 3,
    dig 3
    pushint 3 // 3
    ==
    // array/immutable.py:297
    // e=i == 4,
    dig 4
    pushint 4 // 4
    ==
    // array/immutable.py:298
    // f=i == 5,
    dig 5
    pushint 5 // 5
    ==
    // array/immutable.py:299
    // g=i == 6,
    dig 6
    pushint 6 // 6
    ==
    // array/immutable.py:289-301
    // arr7 = arr7.append(
    //     SevenBoolTuple(
    //         foo=i,
    //         bar=i + 1,
    //         a=i == 0,
    //         b=i == 1,
    //         c=i == 2,
    //         d=i == 3,
    //         e=i == 4,
    //         f=i == 5,
    //         g=i == 6,
    //     )
    // )
    dig 7
    itob
    uncover 7
    intc_2 // 2
    uncover 7
    setbit
    pushint 3 // 3
    uncover 6
    setbit
    pushint 4 // 4
    uncover 5
    setbit
    pushint 5 // 5
    uncover 4
    setbit
    pushint 6 // 6
    uncover 3
    setbit
    dup2
    concat
    dig 3
    itob
    swap
    dig 1
    concat
    dig 9
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 9
    // array/immutable.py:313
    // h=i == 7,
    dig 4
    pushint 7 // 7
    ==
    // array/immutable.py:302-315
    // arr8 = arr8.append(
    //     EightBoolTuple(
    //         foo=i,
    //         bar=i + 1,
    //         a=i == 0,
    //         b=i == 1,
    //         c=i == 2,
    //         d=i == 3,
    //         e=i == 4,
    //         f=i == 5,
    //         g=i == 6,
    //         h=i == 7,
    //     )
    // )
    uncover 2
    pushint 7 // 7
    uncover 2
    setbit
    uncover 2
    swap
    concat
    dup
    dig 2
    concat
    dig 7
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 7
    // array/immutable.py:328
    // i=i == 8,
    uncover 3
    intc_3 // 8
    ==
    // array/immutable.py:316-330
    // arr9 = arr9.append(
    //     NineBoolTuple(
    //         foo=i,
    //         bar=i + 1,
    //         a=i == 0,
    //         b=i == 1,
    //         c=i == 2,
    //         d=i == 3,
    //         e=i == 4,
    //         f=i == 5,
    //         g=i == 6,
    //         h=i == 7,
    //         i=i == 8,
    //     )
    // )
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    swap
    concat
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    bury 1
    b test_bit_packed_tuples_for_header@2

test_bit_packed_tuples_after_for@5:
    // array/immutable.py:332
    // assert arr2.length == 5
    dig 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:333
    // assert arr7.length == 5
    dig 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:334
    // assert arr8.length == 5
    dig 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:335
    // assert arr9.length == 5
    dig 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    // array/immutable.py:336
    // self.bool2 = arr2
    pushbytes "bool2"
    uncover 4
    app_global_put
    // array/immutable.py:337
    // self.bool7 = arr7
    pushbytes "bool7"
    uncover 3
    app_global_put
    // array/immutable.py:338
    // self.bool8 = arr8
    pushbytes "bool8"
    uncover 2
    app_global_put
    // array/immutable.py:339
    // self.bool9 = arr9
    pushbytes "bool9"
    swap
    app_global_put
    // array/immutable.py:276
    // @arc4.abimethod()
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.sum_uints_and_lengths_and_trues[routing]() -> void:
sum_uints_and_lengths_and_trues:
    bytec_0 // ""
    dupn 8
    // array/immutable.py:341
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    txna ApplicationArgs 2
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<bool>
    txna ApplicationArgs 3
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    pushint 9 // 9
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyTuple>
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 2
    *
    swap
    dup
    len
    swap
    extract 2 0
    intc_0 // 0

sum_uints_and_lengths_and_trues_for_header@1:
    // array/immutable.py:341
    // @arc4.abimethod()
    dup
    dig 5
    <
    bz sum_uints_and_lengths_and_trues_after_for@4
    dupn 2
    intc_2 // 2
    *
    dig 3
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 7
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    dig 1
    len
    substring3
    dup
    len
    dig 1
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    swap
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    +
    bury 5
    intc_1 // 1
    +
    bury 1
    b sum_uints_and_lengths_and_trues_for_header@1

sum_uints_and_lengths_and_trues_after_for@4:
    // array/immutable.py:341
    // @arc4.abimethod()
    dig 3
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    // array/immutable.py:349
    // sum1 = sum2 = sum3 = sum4 = UInt64()
    intc_0 // 0
    bury 13
    intc_0 // 0
    bury 14
    intc_0 // 0
    bury 15
    intc_0 // 0
    bury 16
    intc_0 // 0
    bury 19

sum_uints_and_lengths_and_trues_for_header@6:
    // array/immutable.py:350
    // for i in arr1:
    dig 18
    dig 10
    <
    bz sum_uints_and_lengths_and_trues_after_for@9
    dig 10
    extract 2 0
    dig 19
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    // array/immutable.py:351
    // sum1 += i
    dig 17
    +
    bury 17
    intc_1 // 1
    +
    bury 19
    b sum_uints_and_lengths_and_trues_for_header@6

sum_uints_and_lengths_and_trues_after_for@9:
    intc_0 // 0
    bury 18

sum_uints_and_lengths_and_trues_for_header@10:
    // array/immutable.py:352
    // for b in arr2:
    dig 17
    dig 8
    <
    bz sum_uints_and_lengths_and_trues_after_for@15
    dig 17
    pushint 16 // 16
    +
    dig 9
    swap
    getbit
    // array/immutable.py:353
    // if b:
    bz sum_uints_and_lengths_and_trues_after_if_else@13
    // array/immutable.py:354
    // sum2 += 1
    dig 14
    intc_1 // 1
    +
    bury 15

sum_uints_and_lengths_and_trues_after_if_else@13:
    dig 17
    intc_1 // 1
    +
    bury 18
    b sum_uints_and_lengths_and_trues_for_header@10

sum_uints_and_lengths_and_trues_after_for@15:
    intc_0 // 0
    bury 17

sum_uints_and_lengths_and_trues_for_header@16:
    // array/immutable.py:355
    // for tup in arr3:
    dig 16
    dig 6
    <
    bz sum_uints_and_lengths_and_trues_after_for@23
    dig 6
    extract 2 0
    dig 17
    pushint 9 // 9
    *
    pushint 9 // 9
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    bury 14
    // array/immutable.py:356
    // sum3 += tup.foo
    dig 15
    uncover 2
    +
    bury 15
    // array/immutable.py:357
    // if tup.bar:
    bz sum_uints_and_lengths_and_trues_after_if_else@19
    // array/immutable.py:358
    // sum3 += 1
    dig 13
    intc_1 // 1
    +
    bury 14

sum_uints_and_lengths_and_trues_after_if_else@19:
    // array/immutable.py:359
    // if tup.baz:
    dig 11
    bz sum_uints_and_lengths_and_trues_after_if_else@21
    // array/immutable.py:360
    // sum3 += 1
    dig 13
    intc_1 // 1
    +
    bury 14

sum_uints_and_lengths_and_trues_after_if_else@21:
    dig 16
    intc_1 // 1
    +
    bury 17
    b sum_uints_and_lengths_and_trues_for_header@16

sum_uints_and_lengths_and_trues_after_for@23:
    intc_0 // 0
    bury 20

sum_uints_and_lengths_and_trues_for_header@24:
    // array/immutable.py:361
    // for idx, dyn_tup in uenumerate(arr4):
    dig 19
    dig 5
    <
    bz sum_uints_and_lengths_and_trues_after_for@27
    dig 19
    dup
    intc_2 // 2
    *
    dig 3
    dup
    cover 3
    swap
    extract_uint16
    dig 1
    intc_1 // 1
    +
    dig 8
    dig 1
    - // on error: index access is out of bounds
    dig 4
    len
    dig 2
    intc_2 // 2
    *
    dig 6
    swap
    extract_uint16
    uncover 2
    select
    uncover 4
    uncover 3
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    // array/immutable.py:362
    // sum4 += dyn_tup.foo
    dig 16
    uncover 2
    +
    // array/immutable.py:363
    // sum4 += dyn_tup.bar.bytes.length
    swap
    len
    swap
    dig 1
    +
    bury 16
    // array/immutable.py:364
    // assert dyn_tup.bar.bytes.length == idx, "expected string length to match index"
    uncover 2
    ==
    assert // expected string length to match index
    bury 20
    b sum_uints_and_lengths_and_trues_for_header@24

sum_uints_and_lengths_and_trues_after_for@27:
    // array/immutable.py:341
    // @arc4.abimethod()
    dig 15
    itob
    dig 15
    itob
    concat
    dig 14
    itob
    concat
    dig 13
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_uint64_return[routing]() -> void:
test_uint64_return:
    // array/immutable.py:368
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // array/immutable.py:370
    // arr = ImmutableArray((UInt64(1), UInt64(2), UInt64(3)))
    pushbytes 0x0003000000000000000100000000000000020000000000000003
    // array/immutable.py:371
    // for i in urange(append):
    intc_0 // 0

test_uint64_return_for_header@2:
    // array/immutable.py:371
    // for i in urange(append):
    dup
    dig 3
    <
    bz test_uint64_return_after_for@5
    // array/immutable.py:372
    // arr = arr.append(i)
    dupn 2
    itob
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    // array/immutable.py:371
    // for i in urange(append):
    intc_1 // 1
    +
    bury 1
    b test_uint64_return_for_header@2

test_uint64_return_after_for@5:
    // array/immutable.py:368
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_bool_return[routing]() -> void:
test_bool_return:
    // array/immutable.py:375
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // array/immutable.py:377
    // arr = ImmutableArray((True, False, True, False, True))
    pushbytes 0x0005a8
    // array/immutable.py:378
    // for i in urange(append):
    intc_0 // 0

test_bool_return_for_header@2:
    // array/immutable.py:378
    // for i in urange(append):
    dup
    dig 3
    <
    bz test_bool_return_after_for@5
    // array/immutable.py:379
    // arr = arr.append(i % 2 == 0)
    dupn 2
    intc_2 // 2
    %
    !
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 3
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 3
    // array/immutable.py:378
    // for i in urange(append):
    intc_1 // 1
    +
    bury 1
    b test_bool_return_for_header@2

test_bool_return_after_for@5:
    // array/immutable.py:375
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_tuple_return[routing]() -> void:
test_tuple_return:
    // array/immutable.py:382
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // array/immutable.py:384
    // arr = ImmutableArray((MyTuple(UInt64(), True, False),))
    pushbytes 0x0001000000000000000080
    // array/immutable.py:385
    // for i in urange(append):
    intc_0 // 0

test_tuple_return_for_header@2:
    // array/immutable.py:385
    // for i in urange(append):
    dup
    dig 3
    <
    bz test_tuple_return_after_for@5
    // array/immutable.py:386
    // arr = arr.append(MyTuple(foo=i, bar=i % 2 == 0, baz=i % 3 == 0))
    dupn 2
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 3
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 3
    // array/immutable.py:385
    // for i in urange(append):
    intc_1 // 1
    +
    bury 1
    b test_tuple_return_for_header@2

test_tuple_return_after_for@5:
    // array/immutable.py:382
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_dynamic_tuple_return[routing]() -> void:
test_dynamic_tuple_return:
    // array/immutable.py:389
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // array/immutable.py:391
    // arr = ImmutableArray((MyDynamicSizedTuple(UInt64(), String("Hello")),))
    pushbytes 0x000100020000000000000000000a000548656c6c6f
    // array/immutable.py:392
    // for i in urange(append):
    intc_0 // 0

test_dynamic_tuple_return_for_header@2:
    // array/immutable.py:392
    // for i in urange(append):
    dup
    dig 3
    <
    bz test_dynamic_tuple_return_after_for@5
    // array/immutable.py:393
    // arr = arr.append(MyDynamicSizedTuple(i, times(i)))
    dupn 2
    callsub times
    dig 3
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 6 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 3
    // array/immutable.py:392
    // for i in urange(append):
    intc_1 // 1
    +
    bury 1
    b test_dynamic_tuple_return_for_header@2

test_dynamic_tuple_return_after_for@5:
    // array/immutable.py:389
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    dig 2
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_convert_to_array_and_back[routing]() -> void:
test_convert_to_array_and_back:
    // array/immutable.py:396
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 9 // 9
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyTuple>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    // array/immutable.py:401
    // mutable.extend(arr)
    extract 2 0
    // array/immutable.py:402
    // for i in urange(append):
    intc_0 // 0

test_convert_to_array_and_back_for_header@2:
    // array/immutable.py:402
    // for i in urange(append):
    dup
    dig 3
    <
    bz test_convert_to_array_and_back_after_for@5
    // array/immutable.py:403
    // mutable.append(MyTuple(foo=i, bar=i % 2 == 0, baz=i % 3 == 0))
    dupn 2
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 4
    cover 3
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    uncover 2
    swap
    concat // on error: max array length exceeded
    bury 3
    // array/immutable.py:402
    // for i in urange(append):
    intc_1 // 1
    +
    bury 1
    b test_convert_to_array_and_back_for_header@2

test_convert_to_array_and_back_after_for@5:
    dig 1
    // array/immutable.py:404
    // return mutable.freeze()
    dup
    len
    pushint 9 // 9
    /
    itob
    extract 6 2
    swap
    concat
    // array/immutable.py:396
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_concat_with_arc4_tuple[routing]() -> void:
test_concat_with_arc4_tuple:
    // array/immutable.py:406
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64>
    // array/immutable.py:410
    // prefix = ImmutableArray((arc4.UInt64(1), arc4.UInt64(2)))
    bytec 8 // 0x000200000000000000010000000000000002
    // array/immutable.py:411
    // result = prefix + arg
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    // array/immutable.py:406
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_concat_with_native_tuple[routing]() -> void:
test_concat_with_native_tuple:
    // array/immutable.py:414
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64>
    dup
    extract 0 8
    swap
    extract 8 8
    // array/immutable.py:419
    // result = prefix + arg
    concat
    // array/immutable.py:418
    // prefix = ImmutableArray((arc4.UInt64(1), arc4.UInt64(2)))
    bytec 8 // 0x000200000000000000010000000000000002
    // array/immutable.py:419
    // result = prefix + arg
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0004
    replace2 0
    // array/immutable.py:414
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_dynamic_concat_with_arc4_tuple[routing]() -> void:
test_dynamic_concat_with_arc4_tuple:
    // array/immutable.py:422
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 4 // 4
    ==
    assert // invalid tail pointer at index 0 of ((len+utf8[]),(len+utf8[]))
    dig 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 6 // 6
    +
    dig 2
    intc_2 // 2
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 1 of ((len+utf8[]),(len+utf8[]))
    dig 3
    swap
    dig 3
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    +
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>>
    // array/immutable.py:427
    // result = prefix + arg
    extract 4 0
    // array/immutable.py:426
    // prefix = ImmutableArray((arc4.String("a"), arc4.String("b")))
    bytec 9 // 0x000200040007000161000162
    // array/immutable.py:427
    // result = prefix + arg
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    // array/immutable.py:422
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_dynamic_concat_with_native_tuple[routing]() -> void:
test_dynamic_concat_with_native_tuple:
    // array/immutable.py:430
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 4 // 4
    ==
    assert // invalid tail pointer at index 0 of ((len+utf8[]),(len+utf8[]))
    dig 2
    dig 1
    dig 3
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 6 // 6
    +
    dig 3
    intc_2 // 2
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 1 of ((len+utf8[]),(len+utf8[]))
    dig 4
    dig 1
    dig 5
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    uncover 3
    +
    uncover 4
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>>
    cover 3
    substring3
    // array/immutable.py:435
    // result = prefix + arg
    swap
    concat
    // array/immutable.py:434
    // prefix = ImmutableArray((arc4.String("a"), arc4.String("b")))
    bytec 9 // 0x000200040007000161000162
    // array/immutable.py:435
    // result = prefix + arg
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    // array/immutable.py:430
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_concat_immutable_dynamic[routing]() -> void:
test_concat_immutable_dynamic:
    intc_0 // 0
    bytec_0 // ""
    dupn 3
    // array/immutable.py:438
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 2
    *
    swap
    dup
    len
    swap
    extract 2 0
    intc_0 // 0

test_concat_immutable_dynamic_for_header@1:
    // array/immutable.py:438
    // @arc4.abimethod()
    dup
    dig 5
    <
    bz test_concat_immutable_dynamic_after_for@4
    dupn 2
    intc_2 // 2
    *
    dig 3
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 7
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    dig 1
    len
    substring3
    dup
    len
    dig 1
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    swap
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    +
    bury 5
    intc_1 // 1
    +
    bury 1
    b test_concat_immutable_dynamic_for_header@1

test_concat_immutable_dynamic_after_for@4:
    // array/immutable.py:438
    // @arc4.abimethod()
    dig 3
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 11
    intc_2 // 2
    *
    bury 8
    dup
    len
    bury 7
    extract 2 0
    bury 10
    intc_0 // 0
    bury 8

test_concat_immutable_dynamic_for_header@5:
    // array/immutable.py:438
    // @arc4.abimethod()
    dig 7
    dig 9
    <
    bz test_concat_immutable_dynamic_after_for@8
    dig 7
    dup
    intc_2 // 2
    *
    dig 11
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 10
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    dig 1
    len
    substring3
    dup
    len
    dig 1
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    swap
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    +
    bury 8
    intc_1 // 1
    +
    bury 8
    b test_concat_immutable_dynamic_for_header@5

test_concat_immutable_dynamic_after_for@8:
    // array/immutable.py:438
    // @arc4.abimethod()
    dig 6
    intc_2 // 2
    +
    dig 6
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    // array/immutable.py:442
    // return imm1 + imm2
    dig 4
    dig 2
    dig 10
    dig 12
    callsub dynamic_array_concat_dynamic_element
    // array/immutable.py:438
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_immutable_arc4[routing]() -> void:
test_immutable_arc4:
    // array/immutable.py:444
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 16 // 16
    *
    intc_2 // 2
    +
    dig 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyStruct>
    // array/immutable.py:446
    // assert imm, "expected non empty array"
    dup
    assert // expected non empty array
    // array/immutable.py:447
    // imm = imm.replace(imm.length - 1, imm[0])
    intc_1 // 1
    -
    dig 1
    extract 2 16
    swap
    pushint 16 // 16
    *
    intc_2 // 2
    +
    swap
    replace3 // on error: index access is out of bounds
    // array/immutable.py:444
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// test_cases.array.immutable.ImmutableArrayContract.test_imm_fixed_arr[routing]() -> void:
test_imm_fixed_arr:
    bytec_0 // ""
    // array/immutable.py:452
    // arr1 = zero_bytes(NativeStruct3)
    pushint 48 // 48
    bzero
    dup
    // array/immutable.py:453
    // struct12 = NativeStruct(Txn.num_app_args + 1, Txn.num_app_args + 2)
    txn NumAppArgs
    intc_1 // 1
    +
    txn NumAppArgs
    intc_2 // 2
    +
    swap
    itob
    swap
    itob
    concat
    dup
    cover 2
    // array/immutable.py:454
    // arr2 = NativeStruct3((struct12, struct12, struct12))
    dup
    dig 1
    concat
    swap
    concat
    dup
    cover 2
    // array/immutable.py:456
    // assert arr1 != arr2, "expected arrays to be different"
    !=
    assert // expected arrays to be different
    // array/immutable.py:459
    // for i in urange(3):
    intc_0 // 0

test_imm_fixed_arr_for_header@2:
    // array/immutable.py:459
    // for i in urange(3):
    dup
    pushint 3 // 3
    <
    bz test_imm_fixed_arr_after_for@5
    // array/immutable.py:460
    // arr1 = arr1.replace(i, struct12)
    dupn 2
    pushint 16 // 16
    *
    dig 5
    swap
    dig 5
    replace3 // on error: index access is out of bounds
    bury 5
    // array/immutable.py:459
    // for i in urange(3):
    intc_1 // 1
    +
    bury 1
    b test_imm_fixed_arr_for_header@2

test_imm_fixed_arr_after_for@5:
    // array/immutable.py:462
    // assert arr1 == arr2, "expected arrays to be the same"
    dig 3
    dig 2
    ==
    assert // expected arrays to be the same
    intc_0 // 0
    bury 5

test_imm_fixed_arr_for_header@6:
    // array/immutable.py:464
    // for struct_it in arr1:
    dig 4
    pushint 3 // 3
    <
    bz test_imm_fixed_arr_after_for@9
    dig 4
    dup
    pushint 16 // 16
    *
    dig 5
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    // array/immutable.py:465
    // assert struct_it == struct12, "expected items on iteration to be the same"
    dig 4
    ==
    assert // expected items on iteration to be the same
    intc_1 // 1
    +
    bury 5
    b test_imm_fixed_arr_for_header@6

test_imm_fixed_arr_after_for@9:
    // array/immutable.py:467
    // self.imm_fixed_arr = arr1
    bytec 10 // "imm_fixed_arr"
    dig 4
    dup
    cover 2
    app_global_put
    // array/immutable.py:471
    // assert sum_imm_fixed(mut_arr.freeze()) == 15, "expected sum to be 15"
    dup
    callsub sum_imm_fixed
    pushint 15 // 15
    ==
    assert // expected sum to be 15
    // array/immutable.py:473
    // mut_arr[0] = NativeStruct(UInt64(), UInt64())
    pushbytes 0x00000000000000000000000000000000
    replace2 0 // on error: index access is out of bounds
    // array/immutable.py:474
    // assert sum_imm_fixed(mut_arr.freeze()) == 10, "expected sum to be 10"
    callsub sum_imm_fixed
    pushint 10 // 10
    ==
    assert // expected sum to be 10
    // array/immutable.py:476
    // return self.imm_fixed_arr
    intc_0 // 0
    bytec 10 // "imm_fixed_arr"
    app_global_get_ex
    assert // check self.imm_fixed_arr exists
    // array/immutable.py:450
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
