#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 8 0 1 5 512
    bytecblock 0x 0x0000000000000000 0x0000000000000004
    pushbytes 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    store 0

main_block@0:

main_block@1:
    // array/uint64.py:4
    // class Contract(arc4.ARC4Contract):
    txn NumAppArgs
    intc_1 // 0
    !=
    bz main_bare_routing@15

main_abi_routing@2:
    // array/uint64.py:4
    // class Contract(arc4.ARC4Contract):
    txna ApplicationArgs 0
    pushbytes 0xa33be873 // method "test_array()void"
    pushbytes 0xe0c378e9 // method "test_array_extend()void"
    pushbytes 0x366f509d // method "test_array_multiple_append()void"
    pushbytes 0x58351a50 // method "overhead()void"
    pushbytes 0xfa99e984 // method "test_array_too_long()void"
    pushbytes 0xa20e440f // method "test_array_copy_and_extend()void"
    pushbytes 0x179ac3f9 // method "test_array_evaluation_order()void"
    pushbytes 0xf17f6f0a // method "test_allocations(uint64)void"
    pushbytes 0x845e1b4e // method "test_iteration()void"
    pushbytes 0x7621cfd1 // method "test_quicksort()void"
    uncover 10
    match main_test_array_route@3 main_test_array_extend_route@4 main_test_array_multiple_append_route@5 main_overhead_route@6 main_test_array_too_long_route@7 main_test_array_copy_and_extend_route@8 main_test_array_evaluation_order_route@9 main_test_allocations_route@10 main_test_iteration_route@11 main_test_quicksort_route@12

main_switch_case_default@13:

main_switch_case_next@14:

main_after_if_else@19:
    // array/uint64.py:4
    // class Contract(arc4.ARC4Contract):
    intc_1 // 0

main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20:
    return

main_test_quicksort_route@12:
    // array/uint64.py:156
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_quicksort
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_iteration_route@11:
    // array/uint64.py:122
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_iteration
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_allocations_route@10:
    // array/uint64.py:116
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // array/uint64.py:4
    // class Contract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // array/uint64.py:116
    // @arc4.abimethod()
    callsub test_allocations
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_evaluation_order_route@9:
    // array/uint64.py:97
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array_evaluation_order
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_copy_and_extend_route@8:
    // array/uint64.py:75
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array_copy_and_extend
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_too_long_route@7:
    // array/uint64.py:66
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array_too_long
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_overhead_route@6:
    // array/uint64.py:62
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub overhead
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_multiple_append_route@5:
    // array/uint64.py:53
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array_multiple_append
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_extend_route@4:
    // array/uint64.py:41
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array_extend
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_test_array_route@3:
    // array/uint64.py:5
    // @arc4.abimethod()
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub test_array
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20

main_bare_routing@15:
    // array/uint64.py:4
    // class Contract(arc4.ARC4Contract):
    txn OnCompletion
    intc_1 // 0
    swap
    match main___algopy_default_create@16

main_switch_case_default@17:

main_switch_case_next@18:
    b main_after_if_else@19

main___algopy_default_create@16:
    txn ApplicationID
    intc_1 // 0
    ==
    assert // can only call when creating

main_block@21:

main_after_inlined_test_cases.array.uint64.Contract.__algopy_default_create@22:
    intc_2 // 1
    b main_after_inlined_test_cases.array.uint64.Contract.__puya_arc4_router__@20


// test_cases.array.uint64.quicksort_window(arr: uint64, window_left: uint64, window_right: uint64) -> void:
quicksort_window:
    // array/uint64.py:174-175
    // @subroutine
    // def quicksort_window(arr: Array[UInt64], window_left: UInt64, window_right: UInt64) -> None:
    proto 3 0
    bytec_0 // ""
    dup

quicksort_window_block@0:
    // array/uint64.py:176
    // left = window_left
    frame_dig -2
    // array/uint64.py:177
    // right = window_right
    frame_dig -1
    // array/uint64.py:178
    // pivot = arr[(window_left + window_right) // 2]
    dup2
    +
    pushint 2 // 2
    /
    frame_dig -3
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi

quicksort_window_while_top@1:
    frame_dig 2
    frame_bury 0
    frame_dig 3
    frame_bury 1
    // array/uint64.py:179-181
    // # partition window around pivot, so everything to the left is less
    // # and everything to the right is more or equal
    // while True:
    intc_2 // 1
    bz quicksort_window_after_while@22

quicksort_window_while_body@2:

quicksort_window_while_top@3:
    // array/uint64.py:182-183
    // # move left of window towards pivot
    // while arr[left] < pivot:
    frame_dig -3
    loads
    frame_dig 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig 4
    <
    bz quicksort_window_after_while@5

quicksort_window_while_body@4:
    // array/uint64.py:184
    // left += 1
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    b quicksort_window_while_top@3

quicksort_window_after_while@5:

quicksort_window_while_top@6:
    // array/uint64.py:185-186
    // # move right of window towards pivot
    // while pivot < arr[right]:
    frame_dig -3
    loads
    frame_dig 3
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig 4
    >
    bz quicksort_window_after_while@10

quicksort_window_while_body@7:
    // array/uint64.py:187-188
    // # break out of loop if right would go negative
    // if not right:
    frame_dig 3
    intc_1 // 0
    ==
    bz quicksort_window_after_if_else@9

quicksort_window_if_body@8:

quicksort_window_block@21:
    frame_dig 2
    frame_bury 0
    frame_dig 3
    frame_bury 1

quicksort_window_after_while@22:
    frame_dig 0
    frame_bury 2
    frame_dig 1
    dup
    frame_bury 3
    // array/uint64.py:218-219
    // # sort left half of window
    // if window_left < right:
    frame_dig -2
    >
    bz quicksort_window_after_if_else@24

quicksort_window_if_body@23:
    // array/uint64.py:220
    // quicksort_window(arr, window_left, right)
    frame_dig -3
    frame_dig -2
    frame_dig 3
    callsub quicksort_window

quicksort_window_after_if_else@24:
    // array/uint64.py:221-222
    // # sort right half of window
    // if left < window_right:
    frame_dig 2
    frame_dig -1
    <
    bz quicksort_window_after_if_else@26

quicksort_window_if_body@25:
    // array/uint64.py:223
    // quicksort_window(arr, left, window_right)
    frame_dig -3
    frame_dig 2
    frame_dig -1
    callsub quicksort_window

quicksort_window_after_if_else@26:
    retsub

quicksort_window_after_if_else@9:
    // array/uint64.py:190
    // right -= 1
    frame_dig 3
    intc_2 // 1
    -
    frame_bury 3
    b quicksort_window_while_top@6

quicksort_window_after_while@10:
    // array/uint64.py:192-193
    // # if window isn't empty then swap values and move window in
    // if left < right:
    frame_dig 2
    frame_dig 3
    <
    bz quicksort_window_after_if_else@16

quicksort_window_if_body@11:
    // array/uint64.py:194
    // arr[left], arr[right] = arr[right], arr[left]
    frame_dig -3
    loads
    frame_dig 3
    dup
    cover 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -3
    loads
    frame_dig 2
    dup
    cover 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    cover 2
    frame_dig -3
    loads
    dig 1
    intc_0 // 8
    *
    uncover 3
    itob
    bytec_0 // 0x
    swap
    concat
    uncover 2
    uncover 2
    uncover 2
    replace3
    frame_dig -3
    swap
    stores
    frame_dig -3
    loads
    dig 3
    intc_0 // 8
    *
    uncover 3
    itob
    bytec_0 // 0x
    swap
    concat
    uncover 2
    uncover 2
    uncover 2
    replace3
    frame_dig -3
    swap
    stores
    // array/uint64.py:195
    // left += 1
    intc_2 // 1
    +
    frame_bury 2
    // array/uint64.py:196-197
    // # break out of loop if right would go negative
    // if not right:
    intc_1 // 0
    ==
    bz quicksort_window_after_if_else@13

quicksort_window_if_body@12:
    frame_dig 2
    frame_bury 0
    frame_dig 3
    frame_bury 1
    // array/uint64.py:198
    // break
    b quicksort_window_after_while@22

quicksort_window_after_if_else@13:
    // array/uint64.py:199
    // right -= 1
    frame_dig 3
    intc_2 // 1
    -
    dup
    frame_bury 3
    // array/uint64.py:200-201
    // # explicit continue to avoid hitting outer break
    // if left <= right:
    frame_dig 2
    >=
    bz quicksort_window_after_if_else@15

quicksort_window_if_body@14:
    // array/uint64.py:202
    // continue
    b quicksort_window_while_top@1

quicksort_window_after_if_else@15:
    frame_dig 2
    frame_bury 0
    frame_dig 3
    frame_bury 1
    // array/uint64.py:203-205
    // # loop always ends in this scenario
    // # and an explict break consumes fewer ops
    // break
    b quicksort_window_after_while@22

quicksort_window_after_if_else@16:
    // array/uint64.py:206-207
    // # if window is just one item, don't bother swapping, but still adjust window
    // if left == right:
    frame_dig 2
    frame_dig 3
    ==
    bz quicksort_window_after_if_else@20

quicksort_window_if_body@17:
    // array/uint64.py:208
    // left += 1
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    // array/uint64.py:209-210
    // # don't decrement right if it would go negative
    // if right:
    frame_dig 3
    dup
    intc_1 // 0
    !=
    swap
    frame_bury 1
    bz quicksort_window_after_if_else@19

quicksort_window_if_body@18:
    // array/uint64.py:211
    // right -= 1
    frame_dig 3
    intc_2 // 1
    -
    frame_bury 1

quicksort_window_after_if_else@19:
    frame_dig 1
    frame_dig 2
    frame_bury 0
    frame_bury 1
    // array/uint64.py:212-214
    // # loop always ends in this scenario
    // # and an explict break consumes fewer ops
    // break
    b quicksort_window_after_while@22

quicksort_window_after_if_else@20:
    b quicksort_window_block@21


// test_cases.array.uint64.return_ref(arr: uint64, arr2: uint64) -> uint64:
return_ref:
    // array/uint64.py:226-227
    // @subroutine
    // def return_ref(arr: Array[UInt64], arr2: Array[UInt64]) -> Array[UInt64]:
    proto 2 1

return_ref_block@0:
    // array/uint64.py:228
    // arr.append(UInt64(99))
    pushint 99 // 99
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig -2
    loads
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    swap
    stores
    // array/uint64.py:229
    // arr2.append(UInt64(100))
    pushint 100 // 100
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig -1
    loads
    swap
    concat // on error: max array length exceeded
    frame_dig -1
    swap
    stores
    // array/uint64.py:230
    // return arr
    frame_dig -2
    retsub


// test_cases.array.uint64.add_x(arr: uint64, x: uint64) -> void:
add_x:
    // array/uint64.py:233-234
    // @subroutine
    // def add_x(arr: Array[UInt64], x: UInt64) -> None:
    proto 2 0

add_x_block@0:
    // array/uint64.py:235
    // for i in urange(x):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

add_x_for_header@1:
    // array/uint64.py:235
    // for i in urange(x):
    frame_dig 0
    frame_dig -1
    <
    bz add_x_after_for@4

add_x_for_body@2:
    // array/uint64.py:236
    // arr.append(i)
    frame_dig 0
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig -2
    loads
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    swap
    stores

add_x_for_footer@3:
    // array/uint64.py:235
    // for i in urange(x):
    frame_dig 0
    intc_2 // 1
    +
    frame_bury 0
    b add_x_for_header@1

add_x_after_for@4:
    retsub


// test_cases.array.uint64.pop_x(arr: uint64, x: uint64, expected: uint64) -> void:
pop_x:
    // array/uint64.py:239-240
    // @subroutine
    // def pop_x(arr: Array[UInt64], x: UInt64, expected: UInt64) -> None:
    proto 3 0

pop_x_block@0:
    // array/uint64.py:241
    // for _i in urange(x):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

pop_x_for_header@1:
    // array/uint64.py:241
    // for _i in urange(x):
    frame_dig 0
    frame_dig -2
    <
    bz pop_x_after_for@4

pop_x_for_body@2:
    // array/uint64.py:242
    // popped = arr.pop()
    frame_dig -3
    loads
    dup
    len
    intc_0 // 8
    -
    dup
    intc_0 // 8
    /
    swap
    dig 2
    intc_1 // 0
    uncover 2
    extract3
    cover 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    swap
    frame_dig -3
    swap
    stores
    // array/uint64.py:243
    // assert popped == expected
    frame_dig -1
    ==
    assert
    // array/uint64.py:244
    // expected -= 1
    frame_dig -1
    intc_2 // 1
    -
    frame_bury -1

pop_x_for_footer@3:
    // array/uint64.py:241
    // for _i in urange(x):
    frame_dig 0
    intc_2 // 1
    +
    frame_bury 0
    b pop_x_for_header@1

pop_x_after_for@4:
    retsub


// test_cases.array.uint64.append_length_and_return(arr: uint64) -> uint64:
append_length_and_return:
    // array/uint64.py:247-248
    // @subroutine
    // def append_length_and_return(arr: Array[UInt64]) -> Array[UInt64]:
    proto 1 1

append_length_and_return_block@0:
    // array/uint64.py:249
    // arr.append(arr.length)
    frame_dig -1
    loads
    len
    intc_0 // 8
    /
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig -1
    loads
    swap
    concat // on error: max array length exceeded
    frame_dig -1
    swap
    stores
    // array/uint64.py:250
    // return arr
    frame_dig -1
    retsub


// test_cases.array.uint64.Contract.test_array() -> void:
test_array:

test_array_block@0:
    // array/uint64.py:7
    // arr = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:8
    // assert arr.length == 0
    dup
    loads
    len
    intc_0 // 8
    /
    intc_1 // 0
    ==
    assert
    // array/uint64.py:10
    // arr.append(UInt64(42))
    pushint 42 // 42
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:11
    // assert arr.length == 1
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    ==
    assert
    // array/uint64.py:12
    // assert arr[-1] == 42
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 42 // 42
    ==
    assert
    // array/uint64.py:14
    // add_x(arr, UInt64(5))
    dup
    intc_3 // 5
    callsub add_x
    // array/uint64.py:15
    // assert arr.length == 6
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 6 // 6
    ==
    assert
    // array/uint64.py:16
    // assert arr[-1] == 4
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 4 // 4
    ==
    assert
    // array/uint64.py:18
    // pop_x(arr, x=UInt64(3), expected=UInt64(4))
    dup
    pushint 3 // 3
    pushint 4 // 4
    callsub pop_x
    // array/uint64.py:19
    // assert arr.length == 3
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 3 // 3
    ==
    assert
    // array/uint64.py:20
    // assert arr[-1] == 1
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_2 // 1
    ==
    assert
    // array/uint64.py:22
    // arr.append(UInt64(43))
    pushint 43 // 43
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:23
    // assert arr.length == 4
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 4 // 4
    ==
    assert
    // array/uint64.py:24
    // assert arr[-1] == 43
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 43 // 43
    ==
    assert
    // array/uint64.py:25
    // assert arr[0] == 42
    dup
    loads
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 42 // 42
    ==
    assert
    // array/uint64.py:27
    // add_x(arr, UInt64(10))
    dup
    pushint 10 // 10
    callsub add_x
    // array/uint64.py:28
    // assert arr.length == 14
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 14 // 14
    ==
    assert
    // array/uint64.py:29
    // assert arr[-1] == 9
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 9 // 9
    ==
    assert
    // array/uint64.py:31
    // arr.append(UInt64(44))
    pushint 44 // 44
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:32
    // assert arr.length == 15
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 15 // 15
    ==
    assert
    // array/uint64.py:33
    // assert arr[-1] == 44
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 44 // 44
    ==
    assert
    // array/uint64.py:35
    // return_ref(arr, arr)[0] += 2
    dup
    dig 1
    callsub return_ref
    dup
    loads
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    dig 1
    loads
    swap
    pushint 2 // 2
    +
    intc_1 // 0
    intc_0 // 8
    *
    swap
    itob
    bytec_0 // 0x
    swap
    concat
    uncover 2
    uncover 2
    uncover 2
    replace3
    stores
    // array/uint64.py:36
    // assert arr.length == 17
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 17 // 17
    ==
    assert
    // array/uint64.py:37
    // assert arr[0] == 44
    dup
    loads
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 44 // 44
    ==
    assert
    // array/uint64.py:38
    // assert arr[-2] == 99
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 2 // 2
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 99 // 99
    ==
    assert
    // array/uint64.py:39
    // assert arr[-1] == 100
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    swap
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 100 // 100
    ==
    assert
    retsub


// test_cases.array.uint64.Contract.test_array_extend() -> void:
test_array_extend:

test_array_extend_block@0:
    // array/uint64.py:43
    // arr = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:44
    // add_x(arr, UInt64(1))
    dup
    intc_2 // 1
    callsub add_x
    // array/uint64.py:45
    // arr2 = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:46
    // arr2.append(UInt64(1))
    intc_2 // 1
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:47
    // arr2.append(UInt64(2))
    pushint 2 // 2
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:48
    // arr2.append(UInt64(3))
    pushint 3 // 3
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:50
    // arr.extend(arr2)
    loads
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:51
    // assert arr.length == 4
    loads
    len
    intc_0 // 8
    /
    pushint 4 // 4
    ==
    assert
    retsub


// test_cases.array.uint64.Contract.test_array_multiple_append() -> void:
test_array_multiple_append:

test_array_multiple_append_block@0:
    // array/uint64.py:55
    // arr = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:56
    // add_x(arr, UInt64(1))
    dup
    intc_2 // 1
    callsub add_x
    // array/uint64.py:57
    // arr.append(UInt64(1))
    intc_2 // 1
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:58
    // arr.append(UInt64(2))
    pushint 2 // 2
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:59
    // arr.append(UInt64(3))
    pushint 3 // 3
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:60
    // assert arr.length == 4
    loads
    len
    intc_0 // 8
    /
    pushint 4 // 4
    ==
    assert
    retsub


// test_cases.array.uint64.Contract.overhead() -> void:
overhead:

overhead_block@0:
    retsub


// test_cases.array.uint64.Contract.test_array_too_long() -> void:
test_array_too_long:
    // array/uint64.py:66-67
    // @arc4.abimethod()
    // def test_array_too_long(self) -> None:
    proto 0 0

test_array_too_long_block@0:
    // array/uint64.py:68
    // array = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:69
    // for i in urange(512):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

test_array_too_long_for_header@1:
    // array/uint64.py:69
    // for i in urange(512):
    frame_dig 1
    intc 4 // 512
    <
    bz test_array_too_long_after_for@4

test_array_too_long_for_body@2:
    // array/uint64.py:70
    // array.append(i)
    frame_dig 1
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 0
    dup
    cover 2
    loads
    swap
    concat // on error: max array length exceeded
    stores

test_array_too_long_for_footer@3:
    // array/uint64.py:69
    // for i in urange(512):
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b test_array_too_long_for_header@1

test_array_too_long_after_for@4:
    // array/uint64.py:71
    // assert array.length == 512, "array is expected length"
    frame_dig 0
    dup
    loads
    len
    intc_0 // 8
    /
    intc 4 // 512
    ==
    assert // array is expected length
    // array/uint64.py:73
    // array.append(UInt64(512))  # this will fail
    intc 4 // 512
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    stores
    retsub


// test_cases.array.uint64.Contract.test_array_copy_and_extend() -> void:
test_array_copy_and_extend:
    // array/uint64.py:75-76
    // @arc4.abimethod()
    // def test_array_copy_and_extend(self) -> None:
    proto 0 0

test_array_copy_and_extend_block@0:
    // array/uint64.py:77
    // array = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:78
    // for i in urange(5):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

test_array_copy_and_extend_for_header@1:
    // array/uint64.py:78
    // for i in urange(5):
    frame_dig 1
    intc_3 // 5
    <
    bz test_array_copy_and_extend_after_for@4

test_array_copy_and_extend_for_body@2:
    // array/uint64.py:79
    // array.append(i)
    frame_dig 1
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 0
    dup
    cover 2
    loads
    swap
    concat // on error: max array length exceeded
    stores

test_array_copy_and_extend_for_footer@3:
    // array/uint64.py:78
    // for i in urange(5):
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b test_array_copy_and_extend_for_header@1

test_array_copy_and_extend_after_for@4:
    // array/uint64.py:80
    // array2 = array.copy()
    callsub _puya_lib.mem.new_slot
    frame_dig 0
    dup
    cover 2
    loads
    dig 1
    swap
    stores
    swap
    // array/uint64.py:82
    // array.append(UInt64(5))
    intc_3 // 5
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:83
    // assert array.length == 6
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 6 // 6
    ==
    assert
    // array/uint64.py:84
    // assert array[-1] == 5, "expected 5"
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_3 // 5
    ==
    assert // expected 5
    // array/uint64.py:86
    // assert array2.length == 5
    dig 1
    loads
    len
    intc_0 // 8
    /
    intc_3 // 5
    ==
    assert
    // array/uint64.py:87
    // assert array2[-1] == 4, "expected 4"
    dig 1
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 2
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 4 // 4
    ==
    assert // expected 4
    // array/uint64.py:89
    // array.extend(array2)
    dig 1
    loads
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:90
    // assert array.length == 11
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 11 // 11
    ==
    assert
    // array/uint64.py:91
    // assert array2.length == 5
    swap
    loads
    len
    intc_0 // 8
    /
    intc_3 // 5
    ==
    assert
    // array/uint64.py:92
    // assert array[-1] == 4, "expected 4"
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 4 // 4
    ==
    assert // expected 4
    // array/uint64.py:93
    // assert array[4] == 4, "expected 4"
    dup
    loads
    pushint 4 // 4
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 4 // 4
    ==
    assert // expected 4
    // array/uint64.py:94
    // assert array[5] == 5, "expected 4"
    dup
    loads
    intc_3 // 5
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_3 // 5
    ==
    assert // expected 4
    // array/uint64.py:95
    // assert array[6] == 0, "expected 4"
    loads
    pushint 6 // 6
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_1 // 0
    ==
    assert // expected 4
    retsub


// test_cases.array.uint64.Contract.test_array_evaluation_order() -> void:
test_array_evaluation_order:

test_array_evaluation_order_block@0:
    // array/uint64.py:99
    // arr = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:100
    // arr.append(UInt64(3))
    pushint 3 // 3
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    dig 1
    loads
    swap
    concat // on error: max array length exceeded
    dig 1
    swap
    stores
    // array/uint64.py:101
    // append_length_and_return(arr).extend(append_length_and_return(arr))
    dup
    callsub append_length_and_return
    swap
    dup
    callsub append_length_and_return
    loads
    dig 2
    loads
    swap
    concat // on error: max array length exceeded
    uncover 2
    swap
    stores
    // array/uint64.py:102
    // assert arr.length == 6
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 6 // 6
    ==
    assert
    // array/uint64.py:103
    // assert arr[0] == 3
    dup
    loads
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 3 // 3
    ==
    assert
    // array/uint64.py:104
    // assert arr[1] == 1
    dup
    loads
    intc_2 // 1
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_2 // 1
    ==
    assert
    // array/uint64.py:105
    // assert arr[2] == 2
    dup
    loads
    pushint 2 // 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 2 // 2
    ==
    assert
    // array/uint64.py:106
    // assert arr[3] == 3
    dup
    loads
    pushint 3 // 3
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 3 // 3
    ==
    assert
    // array/uint64.py:107
    // assert arr[4] == 1
    dup
    loads
    pushint 4 // 4
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    intc_2 // 1
    ==
    assert
    // array/uint64.py:108
    // assert arr[5] == 2
    dup
    loads
    intc_3 // 5
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 2 // 2
    ==
    assert
    // array/uint64.py:110
    // arr[append_length_and_return(arr)[0]] = append_length_and_return(arr)[-1]
    dup
    callsub append_length_and_return
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    cover 2
    loads
    cover 2
    dup
    callsub append_length_and_return
    loads
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    dig 1
    loads
    swap
    uncover 3
    intc_0 // 8
    *
    uncover 4
    swap
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    swap
    intc_0 // 8
    *
    swap
    itob
    bytec_0 // 0x
    swap
    concat
    uncover 2
    uncover 2
    uncover 2
    replace3
    dig 1
    swap
    stores
    // array/uint64.py:111
    // assert arr.length == 8
    dup
    loads
    len
    intc_0 // 8
    /
    intc_0 // 8
    ==
    assert
    // array/uint64.py:112
    // assert arr[6] == 6
    dup
    loads
    pushint 6 // 6
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 6 // 6
    ==
    assert
    // array/uint64.py:113
    // assert arr[7] == 7
    dup
    loads
    pushint 7 // 7
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 7 // 7
    ==
    assert
    // array/uint64.py:114
    // assert arr[3] == 6
    loads
    pushint 3 // 3
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    pushint 6 // 6
    ==
    assert
    retsub


// test_cases.array.uint64.Contract.test_allocations(num: uint64) -> void:
test_allocations:
    // array/uint64.py:116-117
    // @arc4.abimethod()
    // def test_allocations(self, num: UInt64) -> None:
    proto 1 0

test_allocations_block@0:
    // array/uint64.py:118
    // for _i in urange(num):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

test_allocations_for_header@1:
    // array/uint64.py:118
    // for _i in urange(num):
    frame_dig 0
    frame_dig -1
    <
    bz test_allocations_after_for@4

test_allocations_for_body@2:
    // array/uint64.py:119
    // alloc_test = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:120
    // add_x(alloc_test, UInt64(1))
    intc_2 // 1
    callsub add_x

test_allocations_for_footer@3:
    // array/uint64.py:118
    // for _i in urange(num):
    frame_dig 0
    intc_2 // 1
    +
    frame_bury 0
    b test_allocations_for_header@1

test_allocations_after_for@4:
    retsub


// test_cases.array.uint64.Contract.test_iteration() -> void:
test_iteration:
    // array/uint64.py:122-123
    // @arc4.abimethod()
    // def test_iteration(self) -> None:
    proto 0 0
    intc_1 // 0
    bytec_0 // ""
    dupn 7

test_iteration_block@0:
    // array/uint64.py:124
    // arr = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:125
    // for val in urange(5):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0

test_iteration_for_header@1:
    // array/uint64.py:125
    // for val in urange(5):
    frame_dig 10
    intc_3 // 5
    <
    bz test_iteration_after_for@4

test_iteration_for_body@2:
    // array/uint64.py:126
    // arr.append(val)
    frame_dig 10
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 9
    dup
    cover 2
    loads
    swap
    concat // on error: max array length exceeded
    stores

test_iteration_for_footer@3:
    // array/uint64.py:125
    // for val in urange(5):
    frame_dig 10
    intc_2 // 1
    +
    frame_bury 10
    b test_iteration_for_header@1

test_iteration_after_for@4:
    // array/uint64.py:127
    // assert arr.length == 5, "expected array of length 5"
    frame_dig 9
    dup
    loads
    len
    intc_0 // 8
    /
    intc_3 // 5
    ==
    assert // expected array of length 5
    // array/uint64.py:129-130
    // # iterate
    // last = UInt64(0)
    intc_1 // 0
    frame_bury 6
    // array/uint64.py:131
    // for value in arr:
    loads
    len
    intc_0 // 8
    /
    frame_bury 1
    intc_1 // 0
    frame_bury 4

test_iteration_for_header@5:
    // array/uint64.py:131
    // for value in arr:
    frame_dig 4
    frame_dig 1
    <
    bz test_iteration_after_for@8

test_iteration_for_body@6:
    // array/uint64.py:131
    // for value in arr:
    frame_dig 9
    loads
    frame_dig 4
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // array/uint64.py:132
    // assert value >= last, "array is not sorted"
    dup
    frame_dig 6
    >=
    assert // array is not sorted
    // array/uint64.py:133
    // last = value
    frame_bury 6

test_iteration_for_footer@7:
    frame_dig 4
    intc_2 // 1
    +
    frame_bury 4
    b test_iteration_for_header@5

test_iteration_after_for@8:
    // array/uint64.py:135-136
    // # enumerate
    // for idx, value in uenumerate(arr):
    frame_dig 9
    loads
    len
    intc_0 // 8
    /
    frame_bury 2
    intc_1 // 0
    frame_bury 5

test_iteration_for_header@9:
    // array/uint64.py:135-136
    // # enumerate
    // for idx, value in uenumerate(arr):
    frame_dig 5
    frame_dig 2
    <
    bz test_iteration_after_for@12

test_iteration_for_body@10:
    // array/uint64.py:135-136
    // # enumerate
    // for idx, value in uenumerate(arr):
    frame_dig 9
    loads
    frame_dig 5
    dup
    cover 2
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // array/uint64.py:137
    // assert value == idx, "incorrect array value"
    ==
    assert // incorrect array value

test_iteration_for_footer@11:
    frame_dig 5
    intc_2 // 1
    +
    frame_bury 5
    b test_iteration_for_header@9

test_iteration_after_for@12:
    // array/uint64.py:139-140
    // # reverse
    // for value in reversed(arr):
    frame_dig 9
    loads
    len
    intc_0 // 8
    /
    frame_bury 8

test_iteration_for_header@13:
    // array/uint64.py:139-140
    // # reverse
    // for value in reversed(arr):
    frame_dig 8
    intc_1 // 0
    >
    bz test_iteration_after_for@16

test_iteration_for_body@14:
    frame_dig 8
    intc_2 // 1
    -
    dup
    frame_bury 8
    // array/uint64.py:139-140
    // # reverse
    // for value in reversed(arr):
    frame_dig 9
    loads
    swap
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // array/uint64.py:141
    // assert value <= last, "array is not sorted"
    dup
    frame_dig 6
    <=
    assert // array is not sorted
    // array/uint64.py:142
    // last = value
    frame_bury 6

test_iteration_for_footer@15:
    b test_iteration_for_header@13

test_iteration_after_for@16:
    // array/uint64.py:144
    // arc4_arr = arc4.DynamicArray[arc4.UInt64]()
    pushbytes 0x0000
    bytec_0 // 0x
    concat
    frame_bury 0
    // array/uint64.py:145
    // native_arr = Array[arc4.UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    frame_bury 7
    // array/uint64.py:146
    // for i in urange(5):
    intc_2 // 1
    assert // Step cannot be zero
    intc_1 // 0
    frame_bury 3

test_iteration_for_header@17:
    // array/uint64.py:146
    // for i in urange(5):
    frame_dig 3
    intc_3 // 5
    <
    bz test_iteration_after_for@20

test_iteration_for_body@18:
    // array/uint64.py:147
    // arc4_arr.append(arc4.UInt64(i))
    frame_dig 0
    extract 2 0
    frame_dig 3
    dup
    cover 2
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    concat
    dup
    len
    intc_0 // 8
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // array/uint64.py:148
    // native_arr.append(arc4.UInt64(i))
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 7
    dup
    cover 2
    loads
    swap
    concat // on error: max array length exceeded
    stores

test_iteration_for_footer@19:
    // array/uint64.py:146
    // for i in urange(5):
    frame_dig 3
    intc_2 // 1
    +
    frame_bury 3
    b test_iteration_for_header@17

test_iteration_after_for@20:
    // array/uint64.py:149
    // combined_arr = arc4_arr + native_arr
    frame_dig 0
    extract 2 0
    frame_dig 7
    loads
    concat
    dup
    len
    intc_0 // 8
    /
    itob
    extract 6 2
    swap
    concat
    // array/uint64.py:150
    // assert combined_arr.length == 10
    dup
    intc_1 // 0
    extract_uint16
    pushint 10 // 10
    ==
    assert
    // array/uint64.py:151
    // assert combined_arr[0] == 0
    dup
    extract 2 0
    intc_1 // 0
    intc_0 // 8
    *
    intc_0 // 8
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x0000000000000000
    b==
    assert
    // array/uint64.py:152
    // assert combined_arr[4] == 4
    dup
    extract 2 0
    pushint 4 // 4
    intc_0 // 8
    *
    intc_0 // 8
    extract3 // on error: Index access is out of bounds
    bytec_2 // 0x0000000000000004
    b==
    assert
    // array/uint64.py:153
    // assert combined_arr[5] == 0
    dup
    extract 2 0
    intc_3 // 5
    intc_0 // 8
    *
    intc_0 // 8
    extract3 // on error: Index access is out of bounds
    bytec_1 // 0x0000000000000000
    b==
    assert
    // array/uint64.py:154
    // assert combined_arr[9] == 4
    extract 2 0
    pushint 9 // 9
    intc_0 // 8
    *
    intc_0 // 8
    extract3 // on error: Index access is out of bounds
    bytec_2 // 0x0000000000000004
    b==
    assert
    retsub


// test_cases.array.uint64.Contract.test_quicksort() -> void:
test_quicksort:
    // array/uint64.py:156-157
    // @arc4.abimethod()
    // def test_quicksort(self) -> None:
    proto 0 0
    bytec_0 // ""
    dupn 2

test_quicksort_block@0:
    // array/uint64.py:158-159
    // # create pseudo random array from sender address
    // rnd = Array[UInt64]()
    callsub _puya_lib.mem.new_slot
    dup
    bytec_0 // 0x
    stores
    // array/uint64.py:160
    // for b in Txn.sender.bytes:
    txn Sender
    dup
    len
    intc_1 // 0

test_quicksort_for_header@1:
    // array/uint64.py:160
    // for b in Txn.sender.bytes:
    frame_dig 6
    frame_dig 5
    <
    bz test_quicksort_after_for@4

test_quicksort_for_body@2:
    // array/uint64.py:160
    // for b in Txn.sender.bytes:
    frame_dig 4
    frame_dig 6
    intc_2 // 1
    extract3
    // array/uint64.py:161
    // rnd.append(op.btoi(b))
    btoi
    itob
    bytec_0 // 0x
    swap
    concat
    bytec_0 // 0x
    swap
    concat
    frame_dig 3
    dup
    cover 2
    loads
    swap
    concat // on error: max array length exceeded
    stores

test_quicksort_for_footer@3:
    frame_dig 6
    intc_2 // 1
    +
    frame_bury 6
    b test_quicksort_for_header@1

test_quicksort_after_for@4:
    // array/uint64.py:162
    // assert rnd.length == 32, "expected array of length 32"
    frame_dig 3
    dup
    loads
    len
    intc_0 // 8
    /
    pushint 32 // 32
    ==
    assert // expected array of length 32
    // array/uint64.py:164-165
    // # sort the array
    // quicksort_window(rnd, UInt64(0), rnd.length - 1)
    dup
    loads
    len
    intc_0 // 8
    /
    intc_2 // 1
    -
    dig 1
    intc_1 // 0
    uncover 2
    callsub quicksort_window
    // array/uint64.py:167-168
    // # array should now be in ascending order
    // last = UInt64(0)
    intc_1 // 0
    frame_bury 2
    // array/uint64.py:169
    // for value in rnd:
    loads
    len
    intc_0 // 8
    /
    frame_bury 0
    intc_1 // 0
    frame_bury 1

test_quicksort_for_header@5:
    // array/uint64.py:169
    // for value in rnd:
    frame_dig 1
    frame_dig 0
    <
    bz test_quicksort_after_for@8

test_quicksort_for_body@6:
    // array/uint64.py:169
    // for value in rnd:
    frame_dig 3
    loads
    frame_dig 1
    intc_0 // 8
    *
    intc_0 // 8
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // array/uint64.py:170
    // assert value >= last, "array is not sorted"
    dup
    frame_dig 2
    >=
    assert // array is not sorted
    // array/uint64.py:171
    // last = value
    frame_bury 2

test_quicksort_for_footer@7:
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b test_quicksort_for_header@5

test_quicksort_after_for@8:
    retsub


// _puya_lib.mem.new_slot() -> uint64:
_puya_lib.mem.new_slot:

_puya_lib.mem.new_slot@entry:
    load 0
    bitlen
    load 0
    pushint 256 // 256
    dig 2
    -
    intc_1 // 0
    setbit // on error: no available slots
    store 0
    retsub
