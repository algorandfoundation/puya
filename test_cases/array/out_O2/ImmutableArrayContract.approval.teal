#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock 0x0000 0x151f7c75 0x 0x00 0x0002 0x000a 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff "imm_fixed_arr" 0x000200040007000161000162 0x000200000000000000010000000000000002 0x62696775696e74
    intc_0 // 0
    dupn 13
    bytec_2 // ""
    dupn 25
    txn NumAppArgs
    bz main___algopy_default_create@31
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x44d42f99 0xb7eaa60b 0x743d70ed 0x1c7e0494 0xa2d5860b 0xe05fc564 0x1e092b83 0x01310262 0xc8654a98 0x89d196f8 0x6cb7c991 0x9898bf02 0xf6b61ee8 0x60b86a7b 0x73ad283f 0x529dfae9 0x206d514f 0xe06465e2 0xec0300a2 0xecdf14af 0x511aca64 0x29852e4f 0x6d4aa358 0xb7cb96bd // method "test_uint64_array()void", method "test_biguint_array()void", method "test_bool_array(uint64)void", method "test_fixed_size_tuple_array()void", method "test_fixed_size_named_tuple_array()void", method "test_dynamic_sized_tuple_array()void", method "test_dynamic_sized_named_tuple_array()void", method "test_implicit_conversion_log(uint64[])void", method "test_implicit_conversion_emit(uint64[])void", method "test_nested_array(uint64,uint64[][])uint64[]", method "test_bit_packed_tuples()void", method "sum_uints_and_lengths_and_trues(uint64[],bool[],(uint64,bool,bool)[],(uint64,string)[])(uint64,uint64,uint64,uint64)", method "test_uint64_return(uint64)uint64[]", method "test_bool_return(uint64)bool[]", method "test_tuple_return(uint64)(uint64,bool,bool)[]", method "test_dynamic_tuple_return(uint64)(uint64,string)[]", method "test_convert_to_array_and_back((uint64,bool,bool)[],uint64)(uint64,bool,bool)[]", method "test_concat_with_arc4_tuple((uint64,uint64))uint64[]", method "test_concat_with_native_tuple((uint64,uint64))uint64[]", method "test_dynamic_concat_with_arc4_tuple((string,string))string[]", method "test_dynamic_concat_with_native_tuple((string,string))string[]", method "test_concat_immutable_dynamic((uint64,string)[],(uint64,string)[])(uint64,string)[]", method "test_immutable_arc4((uint64,uint64)[])(uint64,uint64)[]", method "test_imm_fixed_arr()(uint64,uint64)[3]"
    txna ApplicationArgs 0
    match main_test_uint64_array_route@4 main_test_biguint_array_route@5 main_test_bool_array_route@6 main_test_fixed_size_tuple_array_route@7 main_test_fixed_size_named_tuple_array_route@8 main_test_dynamic_sized_tuple_array_route@9 main_test_dynamic_sized_named_tuple_array_route@10 main_test_implicit_conversion_log_route@11 main_test_implicit_conversion_emit_route@12 main_test_nested_array_route@13 main_test_bit_packed_tuples_route@14 main_sum_uints_and_lengths_and_trues_route@15 main_test_uint64_return_route@16 main_test_bool_return_route@17 main_test_tuple_return_route@18 main_test_dynamic_tuple_return_route@19 main_test_convert_to_array_and_back_route@20 main_test_concat_with_arc4_tuple_route@21 main_test_concat_with_native_tuple_route@22 main_test_dynamic_concat_with_arc4_tuple_route@23 main_test_dynamic_concat_with_native_tuple_route@24 main_test_concat_immutable_dynamic_route@25 main_test_immutable_arc4_route@26 main_test_imm_fixed_arr_route@27
    err

main_test_imm_fixed_arr_route@27:
    pushint 48 // 48
    bzero
    dup
    bury 39
    txn NumAppArgs
    intc_1 // 1
    +
    txn NumAppArgs
    intc_2 // 2
    +
    swap
    itob
    swap
    itob
    concat
    dup
    bury 30
    dup
    dig 1
    concat
    swap
    concat
    dup
    bury 39
    !=
    assert // expected arrays to be different
    intc_0 // 0
    bury 14

main_for_header@35:
    dig 13
    pushint 3 // 3
    <
    bz main_after_for@37
    dig 13
    dup
    pushint 16 // 16
    *
    dig 39
    swap
    dig 30
    replace3 // on error: index access is out of bounds
    bury 39
    intc_1 // 1
    +
    bury 14
    b main_for_header@35

main_after_for@37:
    dig 37
    dig 37
    ==
    assert // expected arrays to be the same
    intc_0 // 0
    bury 12

main_for_header@38:
    dig 11
    pushint 3 // 3
    <
    bz main_after_for@40
    dig 11
    dup
    pushint 16 // 16
    *
    dig 39
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dig 29
    ==
    assert // expected items on iteration to be the same
    intc_1 // 1
    +
    bury 12
    b main_for_header@38

main_after_for@40:
    bytec 7 // "imm_fixed_arr"
    dig 38
    dup
    cover 2
    app_global_put
    dup
    callsub sum_imm_fixed
    pushint 15 // 15
    ==
    assert // expected sum to be 15
    pushbytes 0x00000000000000000000000000000000
    replace2 0 // on error: index access is out of bounds
    callsub sum_imm_fixed
    pushint 10 // 10
    ==
    assert // expected sum to be 10
    intc_0 // 0
    bytec 7 // "imm_fixed_arr"
    app_global_get_ex
    assert // check self.imm_fixed_arr exists
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_immutable_arc4_route@26:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 16 // 16
    *
    intc_2 // 2
    +
    dig 2
    len
    ==
    assert // invalid number of bytes for (len+(uint64,uint64)[])
    dup
    assert // expected non empty array
    intc_1 // 1
    -
    dig 1
    extract 2 16
    swap
    pushint 16 // 16
    *
    intc_2 // 2
    +
    swap
    replace3 // on error: index access is out of bounds
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_immutable_dynamic_route@25:
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dig 1
    intc_0 // 0
    extract_uint16
    uncover 2
    extract 2 0
    dig 2
    extract 2 0
    uncover 3
    intc_0 // 0
    extract_uint16
    swap
    callsub dynamic_array_concat_dynamic_element
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_concat_with_native_tuple_route@24:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    dig 2
    len
    swap
    cover 3
    substring3
    concat
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_concat_with_arc4_tuple_route@23:
    txna ApplicationArgs 1
    extract 4 0
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_with_native_tuple_route@22:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for (uint64,uint64)
    dup
    extract 0 8
    swap
    extract 8 8
    concat
    bytec 9 // 0x000200000000000000010000000000000002
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0004
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_with_arc4_tuple_route@21:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for (uint64,uint64)
    bytec 9 // 0x000200000000000000010000000000000002
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_convert_to_array_and_back_route@20:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1,bool1)[])
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 18
    extract 2 0
    bury 29
    intc_0 // 0
    bury 14

main_for_header@55:
    dig 13
    dig 17
    <
    bz main_after_for@57
    dig 13
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 31
    cover 3
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    uncover 2
    swap
    concat // on error: max array length exceeded
    bury 30
    intc_1 // 1
    +
    bury 14
    b main_for_header@55

main_after_for@57:
    dig 28
    dup
    len
    pushint 9 // 9
    /
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_tuple_return_route@19:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 17
    pushbytes 0x000100020000000000000000000a000548656c6c6f
    bury 39
    intc_0 // 0
    bury 14

main_for_header@60:
    dig 13
    dig 17
    <
    bz main_after_for@77
    dig 13
    dup
    callsub times
    dig 40
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@60

main_after_for@77:
    bytec_1 // 0x151f7c75
    dig 39
    concat
    log
    intc_1 // 1
    return

main_test_tuple_return_route@18:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 17
    pushbytes 0x0001000000000000000080
    bury 39
    intc_0 // 0
    bury 14

main_for_header@65:
    dig 13
    dig 17
    <
    bz main_after_for@77
    dig 13
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@65

main_test_bool_return_route@17:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 17
    pushbytes 0x0005a8
    bury 39
    intc_0 // 0
    bury 14

main_for_header@70:
    dig 13
    dig 17
    <
    bz main_after_for@77
    dig 13
    dup
    intc_2 // 2
    %
    !
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 40
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@70

main_test_uint64_return_route@16:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 17
    pushbytes 0x0003000000000000000100000000000000020000000000000003
    bury 39
    intc_0 // 0
    bury 14

main_for_header@75:
    dig 13
    dig 17
    <
    bz main_after_for@77
    dig 13
    dup
    itob
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@75

main_sum_uints_and_lengths_and_trues_route@15:
    txna ApplicationArgs 1
    dup
    bury 39
    dup
    intc_0 // 0
    extract_uint16
    dup
    bury 23
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    txna ApplicationArgs 2
    dup
    bury 38
    dup
    intc_0 // 0
    extract_uint16
    dup
    bury 22
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+bool1[])
    txna ApplicationArgs 3
    dup
    bury 37
    dup
    intc_0 // 0
    extract_uint16
    dup
    bury 21
    pushint 9 // 9
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for (len+(uint64,bool1,bool1)[])
    txna ApplicationArgs 4
    bury 35
    intc_0 // 0
    bury 3
    intc_0 // 0
    bury 4
    intc_0 // 0
    bury 5
    intc_0 // 0
    bury 6
    intc_0 // 0
    bury 12

main_for_header@80:
    dig 11
    dig 21
    <
    bz main_after_for@82
    dig 37
    extract 2 0
    dig 12
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 7
    +
    bury 7
    intc_1 // 1
    +
    bury 12
    b main_for_header@80

main_after_for@82:
    intc_0 // 0
    bury 10

main_for_header@83:
    dig 9
    dig 20
    <
    bz main_after_for@87
    dig 9
    pushint 16 // 16
    +
    dig 37
    swap
    getbit
    bz main_after_if_else@86
    dig 4
    intc_1 // 1
    +
    bury 5

main_after_if_else@86:
    dig 9
    intc_1 // 1
    +
    bury 10
    b main_for_header@83

main_after_for@87:
    intc_0 // 0
    bury 9

main_for_header@88:
    dig 8
    dig 19
    <
    bz main_after_for@94
    dig 35
    extract 2 0
    dig 9
    pushint 9 // 9
    *
    pushint 9 // 9
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    bury 3
    dig 5
    uncover 2
    +
    bury 5
    bz main_after_if_else@91
    dig 3
    intc_1 // 1
    +
    bury 4

main_after_if_else@91:
    dup
    bz main_after_if_else@93
    dig 3
    intc_1 // 1
    +
    bury 4

main_after_if_else@93:
    dig 8
    intc_1 // 1
    +
    bury 9
    b main_for_header@88

main_after_for@94:
    dig 34
    intc_0 // 0
    extract_uint16
    bury 18
    intc_0 // 0
    bury 13

main_for_header@95:
    dig 12
    dig 18
    <
    bz main_after_for@97
    dig 34
    extract 2 0
    dig 13
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 21
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    dig 6
    uncover 2
    +
    swap
    len
    swap
    dig 1
    +
    bury 6
    uncover 2
    ==
    assert // expected string length to match index
    bury 13
    b main_for_header@95

main_after_for@97:
    dig 5
    itob
    dig 5
    itob
    concat
    dig 4
    itob
    concat
    dig 3
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_bit_packed_tuples_route@14:
    bytec_0 // 0x0000
    bury 37
    bytec_0 // 0x0000
    bury 34
    bytec_0 // 0x0000
    bury 33
    bytec_0 // 0x0000
    bury 32
    intc_0 // 0
    bury 14

main_for_header@100:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@102
    dig 13
    dup
    !
    dig 1
    intc_1 // 1
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    intc_1 // 1
    uncover 2
    setbit
    dig 38
    dup
    cover 2
    dig 1
    concat // on error: max array length exceeded
    uncover 2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 39
    dig 1
    intc_1 // 1
    +
    dig 2
    intc_2 // 2
    ==
    dig 3
    pushint 3 // 3
    ==
    dig 4
    pushint 4 // 4
    ==
    dig 5
    pushint 5 // 5
    ==
    dig 6
    pushint 6 // 6
    ==
    dig 7
    itob
    uncover 7
    intc_2 // 2
    uncover 7
    setbit
    pushint 3 // 3
    uncover 6
    setbit
    pushint 4 // 4
    uncover 5
    setbit
    pushint 5 // 5
    uncover 4
    setbit
    pushint 6 // 6
    uncover 3
    setbit
    dup2
    concat
    dig 3
    itob
    swap
    dig 1
    concat
    dig 39
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 39
    dig 4
    pushint 7 // 7
    ==
    uncover 2
    pushint 7 // 7
    uncover 2
    setbit
    uncover 2
    swap
    concat
    dup
    dig 2
    concat
    dig 37
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 37
    uncover 3
    intc_3 // 8
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    swap
    concat
    dig 33
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 33
    bury 14
    b main_for_header@100

main_after_for@102:
    dig 36
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 34
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 34
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 34
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    pushbytes "bool2"
    uncover 4
    app_global_put
    pushbytes "bool7"
    uncover 3
    app_global_put
    pushbytes "bool8"
    uncover 2
    app_global_put
    pushbytes "bool9"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_nested_array_route@13:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 16
    txna ApplicationArgs 2
    bury 39
    intc_0 // 0
    bury 14

main_for_header@105:
    dig 13
    dig 16
    <
    bz main_after_for@110
    bytec_0 // 0x0000
    bury 31
    intc_0 // 0
    bury 8

main_for_header@107:
    dig 7
    dig 14
    <
    bz main_after_for@109
    dig 7
    dup
    itob
    dig 32
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 32
    intc_1 // 1
    +
    bury 8
    b main_for_header@107

main_after_for@109:
    dig 38
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 4 // 0x0002
    dig 33
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 39
    dig 13
    intc_1 // 1
    +
    bury 14
    b main_for_header@105

main_after_for@110:
    bytec_0 // 0x0000
    bury 27
    dig 38
    intc_0 // 0
    extract_uint16
    bury 23
    intc_0 // 0
    bury 12

main_for_header@111:
    dig 11
    dig 23
    <
    bz main_after_for@113
    dig 38
    extract 2 0
    dig 12
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    extract3
    dup
    bury 31
    intc_0 // 0
    bury 3
    intc_0 // 0
    extract_uint16
    bury 22
    intc_0 // 0
    bury 11

main_for_header@160:
    dig 10
    dig 22
    <
    bz main_after_for@162
    dig 29
    extract 2 0
    dig 11
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 3
    +
    bury 3
    intc_1 // 1
    +
    bury 11
    b main_for_header@160

main_after_for@162:
    dig 1
    itob
    dig 27
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 27
    dig 11
    intc_1 // 1
    +
    bury 12
    b main_for_header@111

main_after_for@113:
    bytec_1 // 0x151f7c75
    dig 27
    concat
    log
    intc_1 // 1
    return

main_test_implicit_conversion_emit_route@12:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    pushbytes 0xfa40c0530002
    swap
    concat
    log
    intc_1 // 1
    return

main_test_implicit_conversion_log_route@11:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for (len+uint64[])
    log
    intc_1 // 1
    return

main_test_dynamic_sized_named_tuple_array_route@10:
    bytec_0 // 0x0000
    bury 39
    intc_0 // 0
    bury 14

main_for_header@120:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@122
    dig 13
    dup
    intc_1 // 1
    +
    swap
    callsub times
    dig 40
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 40
    bury 14
    b main_for_header@120

main_after_for@122:
    dig 38
    intc_0 // 0
    extract_uint16
    dup
    bury 25
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 14

main_for_header@123:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@125
    dig 38
    extract 2 0
    dig 14
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 27
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    uncover 2
    callsub times
    ==
    assert // expected 2nd element to be correct
    bury 14
    b main_for_header@123

main_after_for@125:
    dig 38
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    swap
    bytec_2 // ""
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    swap
    pushbytes "   "
    ==
    &&
    assert // expected 4, 3
    pushbytes "f"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_dynamic_sized_tuple_array_route@9:
    bytec_0 // 0x0000
    bury 39
    intc_0 // 0
    bury 14

main_for_header@128:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@130
    dig 13
    dup
    intc_1 // 1
    +
    swap
    bzero
    dig 40
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 40
    bury 14
    b main_for_header@128

main_after_for@130:
    dig 38
    intc_0 // 0
    extract_uint16
    dup
    bury 26
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 14

main_for_header@131:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@133
    dig 38
    extract 2 0
    dig 14
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 28
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    len
    uncover 2
    ==
    assert // expected 2nd element to be correct
    bury 14
    b main_for_header@131

main_after_for@133:
    dig 38
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    intc_0 // 0
    bzero
    uncover 2
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    pushint 3 // 3
    bzero
    uncover 2
    ==
    &&
    assert // expected 4, 3
    pushbytes "e"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_fixed_size_named_tuple_array_route@8:
    bytec_0 // 0x0000
    bury 39
    intc_0 // 0
    bury 14

main_for_header@136:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@138
    dig 13
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    *
    intc_2 // 2
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@136

main_after_for@138:
    dig 38
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dup
    extract 2 9
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    uncover 2
    !
    assert
    swap
    assert
    assert
    pushbytes "d"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_fixed_size_tuple_array_route@7:
    bytec_0 // 0x0000
    bury 39
    intc_0 // 0
    bury 14

main_for_header@141:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@143
    dig 13
    dup
    intc_1 // 1
    +
    swap
    intc_2 // 2
    +
    dig 1
    itob
    swap
    itob
    concat
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    bury 14
    b main_for_header@141

main_after_for@143:
    dig 38
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 5 // 5
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 5 // 5
    ==
    swap
    pushint 6 // 6
    ==
    &&
    assert
    pushint 16 // 16
    callsub dynamic_array_pop_fixed_size
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 4 // 4
    ==
    swap
    pushint 5 // 5
    ==
    &&
    assert
    pushbytes "c"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_bool_array_route@6:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for uint64
    btoi
    bury 7
    bytec_0 // 0x0000
    bury 39
    intc_0 // 0
    bury 14

main_for_header@146:
    dig 13
    dig 7
    <
    bz main_after_for@148
    txn NumAppArgs
    dig 14
    dup
    uncover 2
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 40
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@146

main_after_for@148:
    dig 38
    intc_0 // 0
    extract_uint16
    dup
    bury 16
    dig 7
    dup
    cover 2
    ==
    assert
    bz main_after_if_else@150
    dig 14
    assert // index access is out of bounds
    dig 38
    pushint 16 // 16
    getbit
    !
    assert // expected element 0 to be False

main_after_if_else@150:
    dig 6
    intc_1 // 1
    >
    bz main_after_if_else@152
    intc_1 // 1
    dig 15
    <
    assert // index access is out of bounds
    dig 38
    pushint 17 // 17
    getbit
    !
    assert // expected element 1 to be False

main_after_if_else@152:
    dig 6
    intc_2 // 2
    >
    bz main_after_if_else@154
    intc_2 // 2
    dig 15
    <
    assert // index access is out of bounds
    dig 38
    pushint 18 // 18
    getbit
    assert // expected element 2 to be True

main_after_if_else@154:
    dig 6
    pushint 3 // 3
    >
    bz main_after_if_else@156
    dig 6
    intc_1 // 1
    -
    dup
    dig 16
    <
    assert // index access is out of bounds
    pushint 16 // 16
    +
    dig 39
    swap
    getbit
    !
    assert // expected last element to be False

main_after_if_else@156:
    pushbytes "g"
    dig 39
    app_global_put
    dig 6
    bz main_after_if_else@158
    dig 14
    intc_1 // 1
    -
    dup
    itob
    extract 6 0
    dig 40
    swap
    replace2 0
    dig 1
    pushint 16 // 16
    +
    intc_0 // 0
    setbit
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    intc_0 // 0
    swap
    substring3
    intc_0 // 0
    extract_uint16
    dig 7
    intc_1 // 1
    -
    ==
    assert

main_after_if_else@158:
    intc_1 // 1
    return

main_test_biguint_array_route@5:
    txn NumAppArgs
    intc_1 // 1
    -
    itob
    pushint 64 // 64
    bzero
    dup
    bury 42
    b|
    bytec_0 // 0x0000
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0001
    replace2 0
    dup
    bury 40
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_1 // 1
    ==
    assert
    intc_1 // 1
    -
    swap
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec_2 // 0x
    b==
    assert
    intc_0 // 0
    bury 14

main_for_header@167:
    dig 13
    pushint 5 // 5
    <
    bz main_after_for@169
    dig 13
    dup
    itob
    dig 41
    b|
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    intc_1 // 1
    +
    bury 14
    b main_for_header@167

main_after_for@169:
    dig 38
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0x04
    b==
    assert
    txn NumAppArgs
    itob
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    swap
    b-
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    dig 42
    b|
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 7 // 7
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
    b==
    assert
    dig 1
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    swap
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_3 // 8
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    b==
    assert
    dup
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    bytec 10 // 0x62696775696e74
    box_del
    pop
    bytec 10 // 0x62696775696e74
    swap
    box_put
    intc_1 // 1
    return

main_test_uint64_array_route@4:
    pushbytes 0x0001000000000000002a
    pushint 5 // 5
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 4 // 4
    ==
    assert
    pushint 43 // 43
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    bury 40
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 7 // 7
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 43 // 43
    ==
    assert
    intc_2 // 2
    extract_uint64
    pushint 42 // 42
    ==
    assert
    intc_0 // 0
    bury 26

main_for_header@172:
    dig 25
    pushint 3 // 3
    <
    bz main_after_for@174
    dig 38
    intc_3 // 8
    callsub dynamic_array_pop_fixed_size
    bury 40
    pop
    dig 25
    intc_1 // 1
    +
    bury 26
    b main_for_header@172

main_after_for@174:
    dig 38
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    intc_2 // 2
    ==
    assert
    pushint 10 // 10
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 14 // 14
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 9 // 9
    ==
    assert
    pushint 44 // 44
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 15 // 15
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 44 // 44
    ==
    assert
    pushint 23 // 23
    itob
    replace2 18 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint16
    pushint 15 // 15
    ==
    assert
    dup
    pushint 18 // 18
    extract_uint64
    pushint 23 // 23
    ==
    assert
    pushbytes "a"
    swap
    app_global_put
    intc_1 // 1
    return

main___algopy_default_create@31:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// _puya_lib.arc4.dynamic_array_pop_fixed_size(array: bytes, fixed_byte_size: uint64) -> bytes, bytes:
dynamic_array_pop_fixed_size:
    proto 2 2
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    itob
    extract 6 0
    frame_dig -2
    swap
    replace2 0
    dup
    len
    frame_dig -1
    -
    dup2
    frame_dig -1
    extract3
    uncover 2
    intc_0 // 0
    uncover 3
    substring3
    retsub


// _puya_lib.arc4.dynamic_array_pop_dynamic_element(array: bytes) -> bytes, bytes:
dynamic_array_pop_dynamic_element:
    proto 1 2
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    dup
    intc_2 // 2
    *
    dup
    frame_dig -1
    extract 2 0
    dup
    cover 2
    dup
    uncover 2
    extract_uint16
    dup
    uncover 2
    dup
    len
    swap
    cover 2
    substring3
    bytec_2 // 0x
    intc_0 // 0

dynamic_array_pop_dynamic_element_for_header@1:
    frame_dig 6
    frame_dig 1
    <
    bz dynamic_array_pop_dynamic_element_after_for@4
    frame_dig 2
    frame_dig 6
    dup
    cover 2
    extract_uint16
    intc_2 // 2
    -
    itob
    extract 6 2
    frame_dig 5
    swap
    concat
    frame_bury 5
    intc_2 // 2
    +
    frame_bury 6
    b dynamic_array_pop_dynamic_element_for_header@1

dynamic_array_pop_dynamic_element_after_for@4:
    frame_dig 0
    itob
    extract 6 2
    frame_dig 5
    concat
    frame_dig 1
    intc_2 // 2
    +
    frame_dig 2
    swap
    frame_dig 3
    substring3
    concat
    frame_dig 4
    frame_bury 0
    frame_bury 1
    retsub


// _puya_lib.arc4.dynamic_array_concat_bits(array: bytes, new_items_bytes: bytes, new_items_count: uint64, read_step: uint64) -> bytes:
dynamic_array_concat_bits:
    proto 4 1
    bytec_2 // ""
    dupn 2
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dupn 2
    frame_dig -2
    +
    dup
    itob
    extract 6 0
    frame_dig -4
    swap
    replace2 0
    cover 2
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    uncover 2
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    cover 2
    <
    bz dynamic_array_concat_bits_after_if_else@2
    frame_dig 6
    frame_dig 5
    -
    bzero
    frame_dig 4
    swap
    concat
    frame_bury 4

dynamic_array_concat_bits_after_if_else@2:
    intc_0 // 0
    frame_bury 0
    frame_dig 3
    pushint 16 // 16
    +
    dup
    frame_bury 2
    frame_dig -2
    +
    frame_bury 1

dynamic_array_concat_bits_while_top@3:
    frame_dig 2
    frame_dig 1
    <
    bz dynamic_array_concat_bits_after_while@5
    frame_dig -3
    frame_dig 0
    dup
    cover 2
    getbit
    frame_dig 4
    frame_dig 2
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 4
    intc_1 // 1
    +
    frame_bury 2
    frame_dig -1
    +
    frame_bury 0
    b dynamic_array_concat_bits_while_top@3

dynamic_array_concat_bits_after_while@5:
    frame_dig 4
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_0 // 0

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@4
    frame_dig 3
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 4
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 3
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@4:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_2 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_0 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_0 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// test_cases.array.immutable.sum_imm_fixed(arr: bytes) -> uint64:
sum_imm_fixed:
    proto 1 1
    intc_0 // 0
    dup

sum_imm_fixed_for_header@1:
    frame_dig 1
    pushint 3 // 3
    <
    bz sum_imm_fixed_after_for@4
    frame_dig 1
    dup
    pushint 16 // 16
    *
    frame_dig -1
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 0
    +
    swap
    intc_3 // 8
    extract_uint64
    +
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 1
    b sum_imm_fixed_for_header@1

sum_imm_fixed_after_for@4:
    retsub


// test_cases.array.immutable.times(n: uint64) -> bytes:
times:
    proto 1 1
    bytec_2 // ""
    intc_0 // 0

times_for_header@1:
    frame_dig 1
    frame_dig -1
    <
    bz times_after_for@4
    frame_dig 0
    pushbytes " "
    concat
    frame_bury 0
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b times_for_header@1

times_after_for@4:
    retsub


// test_cases.array.immutable.add_x(arr: bytes, x: uint64) -> bytes:
add_x:
    proto 2 1
    intc_0 // 0

add_x_for_header@1:
    frame_dig 0
    frame_dig -1
    <
    bz add_x_after_for@4
    frame_dig 0
    dup
    itob
    frame_dig -2
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury -2
    intc_1 // 1
    +
    frame_bury 0
    b add_x_for_header@1

add_x_after_for@4:
    frame_dig -2
    swap
    retsub
