#pragma version 10
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock 0x0000 0x151f7c75 0x 0x00 0x0002 0x000a 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff "imm_fixed_arr" 0x000200040007000161000162 0x000200000000000000010000000000000002 0x62696775696e74
    intc_0 // 0
    dupn 13
    bytec_2 // ""
    dupn 27
    intc_1 // 1
    txn NumAppArgs
    bz main_bare_routing@38
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert
    pushbytess 0x44d42f99 0xb7eaa60b 0x743d70ed 0x1c7e0494 0xa2d5860b 0xe05fc564 0x1e092b83 0x01310262 0xc8654a98 0x89d196f8 0x6cb7c991 0x9898bf02 0xf6b61ee8 0x60b86a7b 0x73ad283f 0x529dfae9 0x206d514f 0xe06465e2 0xec0300a2 0xecdf14af 0x511aca64 0x29852e4f 0x6d4aa358 0xb7cb96bd // method "test_uint64_array()void", method "test_biguint_array()void", method "test_bool_array(uint64)void", method "test_fixed_size_tuple_array()void", method "test_fixed_size_named_tuple_array()void", method "test_dynamic_sized_tuple_array()void", method "test_dynamic_sized_named_tuple_array()void", method "test_implicit_conversion_log(uint64[])void", method "test_implicit_conversion_emit(uint64[])void", method "test_nested_array(uint64,uint64[][])uint64[]", method "test_bit_packed_tuples()void", method "sum_uints_and_lengths_and_trues(uint64[],bool[],(uint64,bool,bool)[],(uint64,string)[])(uint64,uint64,uint64,uint64)", method "test_uint64_return(uint64)uint64[]", method "test_bool_return(uint64)bool[]", method "test_tuple_return(uint64)(uint64,bool,bool)[]", method "test_dynamic_tuple_return(uint64)(uint64,string)[]", method "test_convert_to_array_and_back((uint64,bool,bool)[],uint64)(uint64,bool,bool)[]", method "test_concat_with_arc4_tuple((uint64,uint64))uint64[]", method "test_concat_with_native_tuple((uint64,uint64))uint64[]", method "test_dynamic_concat_with_arc4_tuple((string,string))string[]", method "test_dynamic_concat_with_native_tuple((string,string))string[]", method "test_concat_immutable_dynamic((uint64,string)[],(uint64,string)[])(uint64,string)[]", method "test_immutable_arc4((uint64,uint64)[])(uint64,uint64)[]", method "test_imm_fixed_arr()(uint64,uint64)[3]"
    txna ApplicationArgs 0
    match main_test_uint64_array_route@6 main_test_biguint_array_route@7 main_test_bool_array_route@8 main_test_fixed_size_tuple_array_route@9 main_test_fixed_size_named_tuple_array_route@10 main_test_dynamic_sized_tuple_array_route@11 main_test_dynamic_sized_named_tuple_array_route@12 main_test_implicit_conversion_log_route@13 main_test_implicit_conversion_emit_route@14 main_test_nested_array_route@15 main_test_bit_packed_tuples_route@16 main_sum_uints_and_lengths_and_trues_route@17 main_test_uint64_return_route@18 main_test_bool_return_route@19 main_test_tuple_return_route@20 main_test_dynamic_tuple_return_route@21 main_test_convert_to_array_and_back_route@22 main_test_concat_with_arc4_tuple_route@23 main_test_concat_with_native_tuple_route@24 main_test_dynamic_concat_with_arc4_tuple_route@25 main_test_dynamic_concat_with_native_tuple_route@26 main_test_concat_immutable_dynamic_route@27 main_test_immutable_arc4_route@28 main_test_imm_fixed_arr_route@29
    err

main_test_imm_fixed_arr_route@29:
    pushint 48 // 48
    bzero
    dup
    bury 42
    txn NumAppArgs
    intc_1 // 1
    +
    txn NumAppArgs
    intc_2 // 2
    +
    swap
    itob
    swap
    itob
    concat
    dup
    bury 33
    dup
    dig 1
    concat
    swap
    concat
    dup
    bury 42
    !=
    assert // expected arrays to be different
    intc_0 // 0
    bury 17

main_for_header@42:
    dig 16
    pushint 3 // 3
    <
    bz main_after_for@44
    dig 16
    dup
    pushint 16 // 16
    *
    dig 42
    swap
    dig 33
    replace3 // on error: index access is out of bounds
    bury 42
    intc_1 // 1
    +
    bury 17
    b main_for_header@42

main_after_for@44:
    dig 40
    dig 40
    ==
    assert // expected arrays to be the same
    intc_0 // 0
    bury 15

main_for_header@45:
    dig 14
    pushint 3 // 3
    <
    bz main_after_for@47
    dig 14
    dup
    pushint 16 // 16
    *
    dig 42
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dig 32
    ==
    assert // expected items on iteration to be the same
    intc_1 // 1
    +
    bury 15
    b main_for_header@45

main_after_for@47:
    bytec 7 // "imm_fixed_arr"
    dig 41
    dup
    cover 2
    app_global_put
    dup
    callsub sum_imm_fixed
    pushint 15 // 15
    ==
    assert // expected sum to be 15
    pushbytes 0x00000000000000000000000000000000
    replace2 0 // on error: index access is out of bounds
    callsub sum_imm_fixed
    pushint 10 // 10
    ==
    assert // expected sum to be 10
    intc_0 // 0
    bytec 7 // "imm_fixed_arr"
    app_global_get_ex
    assert // check self.imm_fixed_arr exists
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_immutable_arc4_route@28:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    assert // expected non empty array
    intc_1 // 1
    -
    dig 1
    extract 2 16
    swap
    pushint 16 // 16
    *
    intc_2 // 2
    +
    swap
    replace3 // on error: index access is out of bounds
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_concat_immutable_dynamic_route@27:
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dig 1
    intc_0 // 0
    extract_uint16
    uncover 2
    extract 2 0
    dig 2
    extract 2 0
    uncover 3
    intc_0 // 0
    extract_uint16
    swap
    callsub dynamic_array_concat_dynamic_element
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_dynamic_concat_with_native_tuple_route@26:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    dig 2
    len
    swap
    cover 3
    substring3
    concat
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_dynamic_concat_with_arc4_tuple_route@25:
    txna ApplicationArgs 1
    extract 4 0
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_concat_with_native_tuple_route@24:
    txna ApplicationArgs 1
    dup
    extract 0 8
    swap
    extract 8 8
    concat
    bytec 9 // 0x000200000000000000010000000000000002
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0004
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_concat_with_arc4_tuple_route@23:
    bytec 9 // 0x000200000000000000010000000000000002
    txna ApplicationArgs 1
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_convert_to_array_and_back_route@22:
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    bury 21
    extract 2 0
    bury 32
    intc_0 // 0
    bury 17

main_for_header@62:
    dig 16
    dig 20
    <
    bz main_after_for@64
    dig 16
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 34
    cover 3
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    uncover 2
    swap
    concat // on error: max array length exceeded
    bury 33
    intc_1 // 1
    +
    bury 17
    b main_for_header@62

main_after_for@64:
    dig 31
    dup
    len
    pushint 9 // 9
    /
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_dynamic_tuple_return_route@21:
    txna ApplicationArgs 1
    btoi
    bury 20
    pushbytes 0x000100020000000000000000000a000548656c6c6f
    bury 42
    intc_0 // 0
    bury 17

main_for_header@67:
    dig 16
    dig 20
    <
    bz main_after_for@84
    dig 16
    dup
    callsub times
    dig 43
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@67

main_after_for@84:
    bytec_1 // 0x151f7c75
    dig 42
    concat
    log
    return

main_test_tuple_return_route@20:
    txna ApplicationArgs 1
    btoi
    bury 20
    pushbytes 0x0001000000000000000080
    bury 42
    intc_0 // 0
    bury 17

main_for_header@72:
    dig 16
    dig 20
    <
    bz main_after_for@84
    dig 16
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 43
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@72

main_test_bool_return_route@19:
    txna ApplicationArgs 1
    btoi
    bury 20
    pushbytes 0x0005a8
    bury 42
    intc_0 // 0
    bury 17

main_for_header@77:
    dig 16
    dig 20
    <
    bz main_after_for@84
    dig 16
    dup
    intc_2 // 2
    %
    !
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 43
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@77

main_test_uint64_return_route@18:
    txna ApplicationArgs 1
    btoi
    bury 20
    pushbytes 0x0003000000000000000100000000000000020000000000000003
    bury 42
    intc_0 // 0
    bury 17

main_for_header@82:
    dig 16
    dig 20
    <
    bz main_after_for@84
    dig 16
    dup
    itob
    dig 43
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@82

main_sum_uints_and_lengths_and_trues_route@17:
    txna ApplicationArgs 1
    dup
    bury 42
    txna ApplicationArgs 2
    bury 41
    txna ApplicationArgs 3
    bury 40
    txna ApplicationArgs 4
    bury 39
    intc_0 // 0
    bury 5
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 9
    intc_0 // 0
    bury 10
    intc_0 // 0
    extract_uint16
    bury 24
    intc_0 // 0
    bury 15

main_for_header@87:
    dig 14
    dig 24
    <
    bz main_after_for@89
    dig 40
    extract 2 0
    dig 15
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 10
    +
    bury 10
    intc_1 // 1
    +
    bury 15
    b main_for_header@87

main_after_for@89:
    dig 39
    intc_0 // 0
    extract_uint16
    bury 23
    intc_0 // 0
    bury 13

main_for_header@90:
    dig 12
    dig 23
    <
    bz main_after_for@94
    dig 12
    pushint 16 // 16
    +
    dig 40
    swap
    getbit
    dig 8
    bury 8
    bz main_after_if_else@93
    dig 7
    intc_1 // 1
    +
    bury 7

main_after_if_else@93:
    dig 6
    bury 8
    dig 12
    intc_1 // 1
    +
    bury 13
    b main_for_header@90

main_after_for@94:
    dig 38
    intc_0 // 0
    extract_uint16
    bury 22
    intc_0 // 0
    bury 12

main_for_header@95:
    dig 11
    dig 22
    <
    bz main_after_for@101
    dig 38
    extract 2 0
    dig 12
    pushint 9 // 9
    *
    pushint 9 // 9
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    bury 4
    dig 7
    uncover 2
    +
    dup
    bury 8
    bury 6
    bz main_after_if_else@98
    dig 5
    intc_1 // 1
    +
    bury 5

main_after_if_else@98:
    dig 4
    dup
    bury 7
    bury 5
    dig 1
    bz main_after_if_else@100
    dig 5
    intc_1 // 1
    +
    bury 5

main_after_if_else@100:
    dig 4
    bury 6
    dig 11
    intc_1 // 1
    +
    bury 12
    b main_for_header@95

main_after_for@101:
    dig 37
    intc_0 // 0
    extract_uint16
    bury 21
    intc_0 // 0
    bury 16

main_for_header@102:
    dig 15
    dig 21
    <
    bz main_after_for@104
    dig 37
    extract 2 0
    dig 16
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 24
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    dig 7
    uncover 2
    +
    swap
    len
    swap
    dig 1
    +
    bury 7
    uncover 2
    ==
    assert // expected string length to match index
    bury 16
    b main_for_header@102

main_after_for@104:
    dig 8
    itob
    dig 8
    itob
    concat
    dig 6
    itob
    concat
    dig 4
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    return

main_test_bit_packed_tuples_route@16:
    bytec_0 // 0x0000
    bury 40
    bytec_0 // 0x0000
    bury 37
    bytec_0 // 0x0000
    bury 36
    bytec_0 // 0x0000
    bury 35
    intc_0 // 0
    bury 17

main_for_header@107:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@109
    dig 16
    dup
    !
    dig 1
    intc_1 // 1
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    intc_1 // 1
    uncover 2
    setbit
    dig 41
    dup
    cover 2
    dig 1
    concat // on error: max array length exceeded
    uncover 2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 42
    dig 1
    intc_2 // 2
    ==
    dig 2
    pushint 3 // 3
    ==
    dig 3
    pushint 4 // 4
    ==
    dig 4
    pushint 5 // 5
    ==
    dig 5
    pushint 6 // 6
    ==
    dig 6
    intc_1 // 1
    +
    dig 7
    itob
    uncover 7
    intc_2 // 2
    uncover 8
    setbit
    pushint 3 // 3
    uncover 7
    setbit
    pushint 4 // 4
    uncover 6
    setbit
    pushint 5 // 5
    uncover 5
    setbit
    pushint 6 // 6
    uncover 4
    setbit
    dup2
    concat
    dig 3
    itob
    swap
    dig 1
    concat
    dig 42
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 42
    dig 4
    pushint 7 // 7
    ==
    uncover 2
    pushint 7 // 7
    uncover 2
    setbit
    uncover 2
    swap
    concat
    dup
    dig 2
    concat
    dig 40
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 40
    uncover 3
    intc_3 // 8
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    swap
    concat
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    bury 17
    b main_for_header@107

main_after_for@109:
    dig 39
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 37
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 37
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dig 37
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    pushbytes "bool2"
    uncover 4
    app_global_put
    pushbytes "bool7"
    uncover 3
    app_global_put
    pushbytes "bool8"
    uncover 2
    app_global_put
    pushbytes "bool9"
    swap
    app_global_put
    return

main_test_nested_array_route@15:
    txna ApplicationArgs 1
    btoi
    bury 19
    txna ApplicationArgs 2
    bury 42
    intc_0 // 0
    bury 17

main_for_header@112:
    dig 16
    dig 19
    <
    bz main_after_for@117
    bytec_0 // 0x0000
    bury 34
    intc_0 // 0
    bury 11

main_for_header@114:
    dig 10
    dig 17
    <
    bz main_after_for@116
    dig 10
    dup
    itob
    dig 35
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 35
    intc_1 // 1
    +
    bury 11
    b main_for_header@114

main_after_for@116:
    dig 41
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 4 // 0x0002
    dig 36
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 42
    dig 16
    intc_1 // 1
    +
    bury 17
    b main_for_header@112

main_after_for@117:
    bytec_0 // 0x0000
    bury 30
    dig 41
    intc_0 // 0
    extract_uint16
    bury 26
    intc_0 // 0
    bury 15

main_for_header@118:
    dig 14
    dig 26
    <
    bz main_after_for@120
    dig 41
    extract 2 0
    dig 15
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    extract3
    dup
    bury 34
    intc_0 // 0
    bury 4
    intc_0 // 0
    extract_uint16
    bury 25
    intc_0 // 0
    bury 14

main_for_header@167:
    dig 13
    dig 25
    <
    bz main_after_for@169
    dig 32
    extract 2 0
    dig 14
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 4
    +
    bury 4
    intc_1 // 1
    +
    bury 14
    b main_for_header@167

main_after_for@169:
    dig 2
    itob
    dig 30
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 30
    dig 14
    intc_1 // 1
    +
    bury 15
    b main_for_header@118

main_after_for@120:
    bytec_1 // 0x151f7c75
    dig 30
    concat
    log
    return

main_test_implicit_conversion_emit_route@14:
    pushbytes 0xfa40c0530002
    txna ApplicationArgs 1
    concat
    log
    return

main_test_implicit_conversion_log_route@13:
    txna ApplicationArgs 1
    log
    return

main_test_dynamic_sized_named_tuple_array_route@12:
    bytec_0 // 0x0000
    bury 42
    intc_0 // 0
    bury 17

main_for_header@127:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@129
    dig 16
    dup
    intc_1 // 1
    +
    swap
    callsub times
    dig 43
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 43
    bury 17
    b main_for_header@127

main_after_for@129:
    dig 41
    intc_0 // 0
    extract_uint16
    dup
    bury 28
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 17

main_for_header@130:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@132
    dig 41
    extract 2 0
    dig 17
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 30
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    uncover 2
    callsub times
    ==
    assert // expected 2nd element to be correct
    bury 17
    b main_for_header@130

main_after_for@132:
    dig 41
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    swap
    bytec_2 // ""
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    swap
    pushbytes "   "
    ==
    &&
    assert // expected 4, 3
    pushbytes "f"
    swap
    app_global_put
    return

main_test_dynamic_sized_tuple_array_route@11:
    bytec_0 // 0x0000
    bury 42
    intc_0 // 0
    bury 17

main_for_header@135:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@137
    dig 16
    dup
    intc_1 // 1
    +
    swap
    bzero
    dig 43
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 43
    bury 17
    b main_for_header@135

main_after_for@137:
    dig 41
    intc_0 // 0
    extract_uint16
    dup
    bury 29
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 17

main_for_header@138:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@140
    dig 41
    extract 2 0
    dig 17
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 31
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    len
    uncover 2
    ==
    assert // expected 2nd element to be correct
    bury 17
    b main_for_header@138

main_after_for@140:
    dig 41
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    intc_0 // 0
    bzero
    uncover 2
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    pushint 3 // 3
    bzero
    uncover 2
    ==
    &&
    assert // expected 4, 3
    pushbytes "e"
    swap
    app_global_put
    return

main_test_fixed_size_named_tuple_array_route@10:
    bytec_0 // 0x0000
    bury 42
    intc_0 // 0
    bury 17

main_for_header@143:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@145
    dig 16
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    *
    intc_2 // 2
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 43
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@143

main_after_for@145:
    dig 41
    dup
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    ==
    assert
    dup
    extract 2 9
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    uncover 2
    !
    assert
    swap
    assert
    assert
    pushbytes "d"
    swap
    app_global_put
    return

main_test_fixed_size_tuple_array_route@9:
    bytec_0 // 0x0000
    bury 42
    intc_0 // 0
    bury 17

main_for_header@148:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@150
    dig 16
    dup
    intc_1 // 1
    +
    swap
    intc_2 // 2
    +
    dig 1
    itob
    swap
    itob
    concat
    dig 43
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 43
    bury 17
    b main_for_header@148

main_after_for@150:
    dig 41
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 5 // 5
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 5 // 5
    ==
    swap
    pushint 6 // 6
    ==
    &&
    assert
    pushint 16 // 16
    callsub dynamic_array_pop_fixed_size
    bury 1
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 4 // 4
    ==
    swap
    pushint 5 // 5
    ==
    &&
    assert
    pushbytes "c"
    swap
    app_global_put
    return

main_test_bool_array_route@8:
    txna ApplicationArgs 1
    btoi
    bury 10
    bytec_0 // 0x0000
    bury 42
    intc_0 // 0
    bury 17

main_for_header@153:
    dig 16
    dig 10
    <
    bz main_after_for@155
    txn NumAppArgs
    dig 17
    dup
    uncover 2
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 43
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@153

main_after_for@155:
    dig 41
    intc_0 // 0
    extract_uint16
    dup
    bury 19
    dig 10
    dup
    cover 2
    ==
    assert
    bz main_after_if_else@157
    dig 17
    assert // index access is out of bounds
    dig 41
    pushint 16 // 16
    getbit
    !
    assert // expected element 0 to be False

main_after_if_else@157:
    dig 9
    intc_1 // 1
    >
    bz main_after_if_else@159
    intc_1 // 1
    dig 18
    <
    assert // index access is out of bounds
    dig 41
    pushint 17 // 17
    getbit
    !
    assert // expected element 1 to be False

main_after_if_else@159:
    dig 9
    intc_2 // 2
    >
    bz main_after_if_else@161
    intc_2 // 2
    dig 18
    <
    assert // index access is out of bounds
    dig 41
    pushint 18 // 18
    getbit
    assert // expected element 2 to be True

main_after_if_else@161:
    dig 9
    pushint 3 // 3
    >
    bz main_after_if_else@163
    dig 9
    intc_1 // 1
    -
    dup
    dig 19
    <
    assert // index access is out of bounds
    pushint 16 // 16
    +
    dig 42
    swap
    getbit
    !
    assert // expected last element to be False

main_after_if_else@163:
    pushbytes "g"
    dig 42
    app_global_put
    dig 9
    bz main_after_if_else@165
    dig 17
    intc_1 // 1
    -
    dup
    itob
    extract 6 0
    dig 43
    swap
    replace2 0
    dig 1
    pushint 16 // 16
    +
    intc_0 // 0
    setbit
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    intc_0 // 0
    swap
    substring3
    intc_0 // 0
    extract_uint16
    dig 10
    intc_1 // 1
    -
    ==
    assert

main_after_if_else@165:
    return

main_test_biguint_array_route@7:
    txn NumAppArgs
    intc_1 // 1
    -
    itob
    pushint 64 // 64
    bzero
    dup
    bury 45
    b|
    bytec_0 // 0x0000
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0001
    replace2 0
    dup
    bury 43
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_1 // 1
    ==
    assert
    intc_1 // 1
    -
    swap
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec_2 // 0x
    b==
    assert
    intc_0 // 0
    bury 17

main_for_header@174:
    dig 16
    pushint 5 // 5
    <
    bz main_after_for@176
    dig 16
    dup
    itob
    dig 44
    b|
    dig 43
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 43
    intc_1 // 1
    +
    bury 17
    b main_for_header@174

main_after_for@176:
    dig 41
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0x04
    b==
    assert
    txn NumAppArgs
    itob
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    swap
    b-
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    dig 45
    b|
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 7 // 7
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
    b==
    assert
    dig 1
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    swap
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    intc_3 // 8
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    b==
    assert
    dup
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    bytec 10 // 0x62696775696e74
    box_del
    pop
    bytec 10 // 0x62696775696e74
    swap
    box_put
    return

main_test_uint64_array_route@6:
    pushbytes 0x0001000000000000002a
    pushint 5 // 5
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 4 // 4
    ==
    assert
    pushint 43 // 43
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    bury 43
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 7 // 7
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 43 // 43
    ==
    assert
    intc_2 // 2
    extract_uint64
    pushint 42 // 42
    ==
    assert
    intc_0 // 0
    bury 29

main_for_header@179:
    dig 28
    pushint 3 // 3
    <
    bz main_after_for@181
    dig 41
    intc_3 // 8
    callsub dynamic_array_pop_fixed_size
    bury 43
    pop
    dig 28
    intc_1 // 1
    +
    bury 29
    b main_for_header@179

main_after_for@181:
    dig 41
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 4 // 4
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    intc_2 // 2
    ==
    assert
    pushint 10 // 10
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 14 // 14
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 9 // 9
    ==
    assert
    pushint 44 // 44
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16
    dup
    pushint 15 // 15
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 44 // 44
    ==
    assert
    pushint 23 // 23
    itob
    replace2 18 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint16
    pushint 15 // 15
    ==
    assert
    dup
    pushint 18 // 18
    extract_uint64
    pushint 23 // 23
    ==
    assert
    pushbytes "a"
    swap
    app_global_put
    return

main_bare_routing@38:
    txn OnCompletion
    !
    assert
    txn ApplicationID
    !
    return // on error: can only call when creating


// _puya_lib.arc4.dynamic_array_pop_fixed_size(array: bytes, fixed_byte_size: uint64) -> bytes, bytes:
dynamic_array_pop_fixed_size:
    proto 2 2
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    itob
    extract 6 0
    frame_dig -2
    swap
    replace2 0
    dup
    len
    frame_dig -1
    -
    dup2
    frame_dig -1
    extract3
    uncover 2
    intc_0 // 0
    uncover 3
    substring3
    retsub


// _puya_lib.arc4.dynamic_array_pop_dynamic_element(array: bytes) -> bytes, bytes:
dynamic_array_pop_dynamic_element:
    proto 1 2
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    dup
    intc_2 // 2
    *
    dup
    frame_dig -1
    extract 2 0
    dup
    cover 2
    dup
    uncover 2
    extract_uint16
    dup
    uncover 2
    dup
    len
    swap
    cover 2
    substring3
    bytec_2 // 0x
    intc_0 // 0

dynamic_array_pop_dynamic_element_for_header@1:
    frame_dig 6
    frame_dig 1
    <
    bz dynamic_array_pop_dynamic_element_after_for@4
    frame_dig 2
    frame_dig 6
    dup
    cover 2
    extract_uint16
    intc_2 // 2
    -
    itob
    extract 6 2
    frame_dig 5
    swap
    concat
    frame_bury 5
    intc_2 // 2
    +
    frame_bury 6
    b dynamic_array_pop_dynamic_element_for_header@1

dynamic_array_pop_dynamic_element_after_for@4:
    frame_dig 0
    itob
    extract 6 2
    frame_dig 5
    concat
    frame_dig 1
    intc_2 // 2
    +
    frame_dig 2
    swap
    frame_dig 3
    substring3
    concat
    frame_dig 4
    frame_bury 0
    frame_bury 1
    retsub


// _puya_lib.arc4.dynamic_array_concat_bits(array: bytes, new_items_bytes: bytes, new_items_count: uint64, read_step: uint64) -> bytes:
dynamic_array_concat_bits:
    proto 4 1
    bytec_2 // ""
    dupn 2
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dupn 2
    frame_dig -2
    +
    dup
    itob
    extract 6 0
    frame_dig -4
    swap
    replace2 0
    dup
    uncover 2
    uncover 3
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    cover 3
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    cover 3
    <
    bz dynamic_array_concat_bits_after_if_else@2
    frame_dig 6
    frame_dig 5
    -
    bzero
    frame_dig 4
    swap
    concat
    frame_bury 7

dynamic_array_concat_bits_after_if_else@2:
    frame_dig 7
    frame_bury 4
    intc_0 // 0
    frame_bury 0
    frame_dig 3
    pushint 16 // 16
    +
    dup
    frame_bury 2
    frame_dig -2
    +
    frame_bury 1

dynamic_array_concat_bits_while_top@3:
    frame_dig 2
    frame_dig 1
    <
    bz dynamic_array_concat_bits_after_while@5
    frame_dig -3
    frame_dig 0
    dup
    cover 2
    getbit
    frame_dig 4
    frame_dig 2
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 4
    intc_1 // 1
    +
    frame_bury 2
    frame_dig -1
    +
    frame_bury 0
    b dynamic_array_concat_bits_while_top@3

dynamic_array_concat_bits_after_while@5:
    frame_dig 4
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_0 // 0
    swap

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 3
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@4
    frame_dig 4
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 3
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 4
    intc_2 // 2
    +
    frame_bury 3
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@4:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_2 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_0 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_0 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// test_cases.array.immutable.sum_imm_fixed(arr: bytes) -> uint64:
sum_imm_fixed:
    proto 1 1
    intc_0 // 0
    dup

sum_imm_fixed_for_header@1:
    frame_dig 1
    pushint 3 // 3
    <
    bz sum_imm_fixed_after_for@4
    frame_dig 1
    dup
    pushint 16 // 16
    *
    frame_dig -1
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 0
    +
    swap
    intc_3 // 8
    extract_uint64
    +
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 1
    b sum_imm_fixed_for_header@1

sum_imm_fixed_after_for@4:
    retsub


// test_cases.array.immutable.times(n: uint64) -> bytes:
times:
    proto 1 1
    bytec_2 // ""
    intc_0 // 0

times_for_header@1:
    frame_dig 1
    frame_dig -1
    <
    bz times_after_for@4
    frame_dig 0
    pushbytes " "
    concat
    frame_bury 0
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b times_for_header@1

times_after_for@4:
    retsub


// test_cases.array.immutable.add_x(arr: bytes, x: uint64) -> bytes:
add_x:
    proto 2 1
    intc_0 // 0

add_x_for_header@1:
    frame_dig 0
    frame_dig -1
    <
    bz add_x_after_for@4
    frame_dig 0
    dup
    itob
    frame_dig -2
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury -2
    intc_1 // 1
    +
    frame_bury 0
    b add_x_for_header@1

add_x_after_for@4:
    frame_dig -2
    swap
    retsub
