#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock 0x0000 0x151f7c75 0x 0x00 0x0002 0x000a 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff "imm_fixed_arr" 0x000200040007000161000162 0x000200000000000000010000000000000002 0x62696775696e74
    intc_0 // 0
    dupn 14
    bytec_2 // ""
    dupn 34
    txn NumAppArgs
    bz main___algopy_default_create@31
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x44d42f99 0xb7eaa60b 0x743d70ed 0x1c7e0494 0xa2d5860b 0xe05fc564 0x1e092b83 0x01310262 0xc8654a98 0x89d196f8 0x6cb7c991 0x9898bf02 0xf6b61ee8 0x60b86a7b 0x73ad283f 0x529dfae9 0x206d514f 0xe06465e2 0xec0300a2 0xecdf14af 0x511aca64 0x29852e4f 0x6d4aa358 0xb7cb96bd // method "test_uint64_array()void", method "test_biguint_array()void", method "test_bool_array(uint64)void", method "test_fixed_size_tuple_array()void", method "test_fixed_size_named_tuple_array()void", method "test_dynamic_sized_tuple_array()void", method "test_dynamic_sized_named_tuple_array()void", method "test_implicit_conversion_log(uint64[])void", method "test_implicit_conversion_emit(uint64[])void", method "test_nested_array(uint64,uint64[][])uint64[]", method "test_bit_packed_tuples()void", method "sum_uints_and_lengths_and_trues(uint64[],bool[],(uint64,bool,bool)[],(uint64,string)[])(uint64,uint64,uint64,uint64)", method "test_uint64_return(uint64)uint64[]", method "test_bool_return(uint64)bool[]", method "test_tuple_return(uint64)(uint64,bool,bool)[]", method "test_dynamic_tuple_return(uint64)(uint64,string)[]", method "test_convert_to_array_and_back((uint64,bool,bool)[],uint64)(uint64,bool,bool)[]", method "test_concat_with_arc4_tuple((uint64,uint64))uint64[]", method "test_concat_with_native_tuple((uint64,uint64))uint64[]", method "test_dynamic_concat_with_arc4_tuple((string,string))string[]", method "test_dynamic_concat_with_native_tuple((string,string))string[]", method "test_concat_immutable_dynamic((uint64,string)[],(uint64,string)[])(uint64,string)[]", method "test_immutable_arc4((uint64,uint64)[])(uint64,uint64)[]", method "test_imm_fixed_arr()(uint64,uint64)[3]"
    txna ApplicationArgs 0
    match main_test_uint64_array_route@4 main_test_biguint_array_route@5 main_test_bool_array_route@6 main_test_fixed_size_tuple_array_route@7 main_test_fixed_size_named_tuple_array_route@8 main_test_dynamic_sized_tuple_array_route@9 main_test_dynamic_sized_named_tuple_array_route@10 main_test_implicit_conversion_log_route@11 main_test_implicit_conversion_emit_route@12 main_test_nested_array_route@13 main_test_bit_packed_tuples_route@14 main_sum_uints_and_lengths_and_trues_route@15 main_test_uint64_return_route@16 main_test_bool_return_route@17 main_test_tuple_return_route@18 main_test_dynamic_tuple_return_route@19 main_test_convert_to_array_and_back_route@20 main_test_concat_with_arc4_tuple_route@21 main_test_concat_with_native_tuple_route@22 main_test_dynamic_concat_with_arc4_tuple_route@23 main_test_dynamic_concat_with_native_tuple_route@24 main_test_concat_immutable_dynamic_route@25 main_test_immutable_arc4_route@26 main_test_imm_fixed_arr_route@27
    err

main_test_imm_fixed_arr_route@27:
    pushint 48 // 48
    bzero
    dup
    bury 49
    txn NumAppArgs
    intc_1 // 1
    +
    txn NumAppArgs
    intc_2 // 2
    +
    swap
    itob
    swap
    itob
    concat
    dup
    bury 39
    dup
    dig 1
    concat
    swap
    concat
    dup
    bury 49
    !=
    assert // expected arrays to be different
    intc_0 // 0
    bury 20

main_for_header@35:
    dig 19
    pushint 3 // 3
    <
    bz main_after_for@37
    dig 19
    dup
    pushint 16 // 16
    *
    dig 49
    swap
    dig 39
    replace3 // on error: index access is out of bounds
    bury 49
    intc_1 // 1
    +
    bury 20
    b main_for_header@35

main_after_for@37:
    dig 47
    dig 47
    ==
    assert // expected arrays to be the same
    intc_0 // 0
    bury 16

main_for_header@38:
    dig 15
    pushint 3 // 3
    <
    bz main_after_for@40
    dig 15
    dup
    pushint 16 // 16
    *
    dig 49
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dig 38
    ==
    assert // expected items on iteration to be the same
    intc_1 // 1
    +
    bury 16
    b main_for_header@38

main_after_for@40:
    bytec 7 // "imm_fixed_arr"
    dig 48
    dup
    cover 2
    app_global_put
    dup
    callsub sum_imm_fixed
    pushint 15 // 15
    ==
    assert // expected sum to be 15
    pushbytes 0x00000000000000000000000000000000
    replace2 0 // on error: index access is out of bounds
    callsub sum_imm_fixed
    pushint 10 // 10
    ==
    assert // expected sum to be 10
    intc_0 // 0
    bytec 7 // "imm_fixed_arr"
    app_global_get_ex
    assert // check self.imm_fixed_arr exists
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_immutable_arc4_route@26:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 16 // 16
    *
    intc_2 // 2
    +
    dig 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyStruct>
    dup
    assert // expected non empty array
    intc_1 // 1
    -
    dig 1
    extract 2 16
    swap
    pushint 16 // 16
    *
    intc_2 // 2
    +
    swap
    replace3 // on error: index access is out of bounds
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_immutable_dynamic_route@25:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 27
    intc_2 // 2
    *
    bury 11
    dup
    len
    bury 4
    extract 2 0
    bury 42
    intc_0 // 0
    bury 18

main_for_header@45:
    dig 17
    dig 25
    <
    bz main_after_for@47
    dig 17
    dup
    intc_2 // 2
    *
    dig 43
    dup
    cover 3
    swap
    extract_uint16 // on error: invalid array encoding
    dup
    dig 13
    dup
    cover 5
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    swap
    intc_1 // 1
    +
    dig 28
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    uncover 2
    +
    bury 11
    bury 18
    b main_for_header@45

main_after_for@47:
    dig 9
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 26
    intc_2 // 2
    *
    bury 10
    dup
    len
    bury 3
    extract 2 0
    bury 41
    intc_0 // 0
    bury 17

main_for_header@48:
    dig 16
    dig 24
    <
    bz main_after_for@50
    dig 16
    dup
    intc_2 // 2
    *
    dig 42
    dup
    cover 3
    swap
    extract_uint16 // on error: invalid array encoding
    dup
    dig 12
    dup
    cover 5
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    swap
    intc_1 // 1
    +
    dig 27
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    uncover 2
    +
    bury 10
    bury 17
    b main_for_header@48

main_after_for@50:
    dig 8
    intc_2 // 2
    +
    dig 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    dig 24
    dig 42
    dig 25
    dig 43
    callsub dynamic_array_concat_dynamic_element
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_concat_with_native_tuple_route@24:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 4 // 4
    ==
    assert // invalid tail pointer at index 0 of ((len+utf8[]),(len+utf8[]))
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 6 // 6
    +
    dig 2
    dig 1
    ==
    assert // invalid tail pointer at index 1 of ((len+utf8[]),(len+utf8[]))
    dig 3
    len
    uncover 4
    uncover 4
    dig 2
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    uncover 3
    +
    uncover 2
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>>
    concat
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_concat_with_arc4_tuple_route@23:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 4 // 4
    ==
    assert // invalid tail pointer at index 0 of ((len+utf8[]),(len+utf8[]))
    dig 1
    intc_2 // 2
    extract_uint16
    dig 2
    uncover 2
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 6 // 6
    +
    dup2
    ==
    assert // invalid tail pointer at index 1 of ((len+utf8[]),(len+utf8[]))
    dig 2
    len
    dig 3
    uncover 3
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    uncover 2
    +
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>>
    extract 4 0
    bytec 8 // 0x000200040007000161000162
    swap
    intc_2 // 2
    callsub dynamic_array_concat_byte_length_head
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_with_native_tuple_route@22:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64>
    dup
    extract 0 8
    swap
    extract 8 8
    concat
    bytec 9 // 0x000200000000000000010000000000000002
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0004
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_concat_with_arc4_tuple_route@21:
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64>
    bytec 9 // 0x000200000000000000010000000000000002
    swap
    concat // on error: max array length exceeded
    dup
    extract 2 0
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    replace2 0
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_convert_to_array_and_back_route@20:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 9 // 9
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyTuple>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 24
    extract 2 0
    bury 38
    intc_0 // 0
    bury 20

main_for_header@61:
    dig 19
    dig 23
    <
    bz main_after_for@63
    dig 19
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 40
    cover 3
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    uncover 2
    swap
    concat // on error: max array length exceeded
    bury 39
    intc_1 // 1
    +
    bury 20
    b main_for_header@61

main_after_for@63:
    dig 37
    dup
    len
    pushint 9 // 9
    /
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_dynamic_tuple_return_route@19:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 23
    pushbytes 0x000100020000000000000000000a000548656c6c6f
    bury 49
    intc_0 // 0
    bury 20

main_for_header@66:
    dig 19
    dig 23
    <
    bz main_after_for@83
    dig 19
    dup
    callsub times
    dig 50
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@66

main_after_for@83:
    bytec_1 // 0x151f7c75
    dig 49
    concat
    log
    intc_1 // 1
    return

main_test_tuple_return_route@18:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 23
    pushbytes 0x0001000000000000000080
    bury 49
    intc_0 // 0
    bury 20

main_for_header@71:
    dig 19
    dig 23
    <
    bz main_after_for@83
    dig 19
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@71

main_test_bool_return_route@17:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 23
    pushbytes 0x0005a8
    bury 49
    intc_0 // 0
    bury 20

main_for_header@76:
    dig 19
    dig 23
    <
    bz main_after_for@83
    dig 19
    dup
    intc_2 // 2
    %
    !
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 50
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@76

main_test_uint64_return_route@16:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 23
    pushbytes 0x0003000000000000000100000000000000020000000000000003
    bury 49
    intc_0 // 0
    bury 20

main_for_header@81:
    dig 19
    dig 23
    <
    bz main_after_for@83
    dig 19
    dup
    itob
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@81

main_sum_uints_and_lengths_and_trues_route@15:
    txna ApplicationArgs 1
    dup
    bury 49
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 31
    intc_3 // 8
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    txna ApplicationArgs 2
    dup
    bury 48
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 30
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<bool>
    txna ApplicationArgs 3
    dup
    bury 47
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 29
    pushint 9 // 9
    *
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyTuple>
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 28
    intc_2 // 2
    *
    bury 11
    dup
    len
    bury 4
    extract 2 0
    bury 42
    intc_0 // 0
    bury 18

main_for_header@86:
    dig 17
    dig 26
    <
    bz main_after_for@88
    dig 17
    dup
    intc_2 // 2
    *
    dig 43
    dup
    cover 3
    swap
    extract_uint16 // on error: invalid array encoding
    dup
    dig 13
    dup
    cover 5
    ==
    assert // invalid tail pointer for (len+(uint64,(len+utf8[]))[])
    swap
    intc_1 // 1
    +
    dig 29
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    uncover 2
    +
    bury 11
    bury 18
    b main_for_header@86

main_after_for@88:
    dig 9
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<test_cases.array.immutable.MyDynamicSizedTuple>
    intc_0 // 0
    bury 5
    intc_0 // 0
    bury 6
    intc_0 // 0
    bury 7
    intc_0 // 0
    bury 8
    intc_0 // 0
    bury 16

main_for_header@89:
    dig 15
    dig 29
    <
    bz main_after_for@91
    dig 47
    extract 2 0
    dig 16
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 9
    +
    bury 9
    intc_1 // 1
    +
    bury 16
    b main_for_header@89

main_after_for@91:
    intc_0 // 0
    bury 14

main_for_header@92:
    dig 13
    dig 28
    <
    bz main_after_for@96
    dig 13
    pushint 16 // 16
    +
    dig 47
    swap
    getbit
    bz main_after_if_else@95
    dig 6
    intc_1 // 1
    +
    bury 7

main_after_if_else@95:
    dig 13
    intc_1 // 1
    +
    bury 14
    b main_for_header@92

main_after_for@96:
    intc_0 // 0
    bury 13

main_for_header@97:
    dig 12
    dig 27
    <
    bz main_after_for@103
    dig 45
    extract 2 0
    dig 13
    pushint 9 // 9
    *
    pushint 9 // 9
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    bury 3
    dig 7
    uncover 2
    +
    bury 7
    bz main_after_if_else@100
    dig 5
    intc_1 // 1
    +
    bury 6

main_after_if_else@100:
    dup
    bz main_after_if_else@102
    dig 5
    intc_1 // 1
    +
    bury 6

main_after_if_else@102:
    dig 12
    intc_1 // 1
    +
    bury 13
    b main_for_header@97

main_after_for@103:
    intc_0 // 0
    bury 19

main_for_header@104:
    dig 18
    dig 26
    <
    bz main_after_for@106
    dig 18
    dup
    intc_2 // 2
    *
    dig 43
    dup
    cover 3
    swap
    extract_uint16
    dig 1
    intc_1 // 1
    +
    dig 29
    dig 1
    - // on error: index access is out of bounds
    dig 4
    len
    dig 2
    intc_2 // 2
    *
    dig 6
    swap
    extract_uint16
    uncover 2
    select
    uncover 4
    uncover 3
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    dig 8
    uncover 2
    +
    swap
    len
    swap
    dig 1
    +
    bury 8
    uncover 2
    ==
    assert // expected string length to match index
    bury 19
    b main_for_header@104

main_after_for@106:
    dig 7
    itob
    dig 7
    itob
    concat
    dig 6
    itob
    concat
    dig 5
    itob
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_test_bit_packed_tuples_route@14:
    bytec_0 // 0x0000
    bury 47
    bytec_0 // 0x0000
    bury 45
    bytec_0 // 0x0000
    bury 44
    bytec_0 // 0x0000
    bury 43
    intc_0 // 0
    bury 20

main_for_header@109:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@111
    dig 19
    dup
    !
    dig 1
    intc_1 // 1
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 3
    setbit
    intc_1 // 1
    uncover 2
    setbit
    dig 48
    dup
    cover 2
    dig 1
    concat // on error: max array length exceeded
    uncover 2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 49
    dig 1
    intc_1 // 1
    +
    dig 2
    intc_2 // 2
    ==
    dig 3
    pushint 3 // 3
    ==
    dig 4
    pushint 4 // 4
    ==
    dig 5
    pushint 5 // 5
    ==
    dig 6
    pushint 6 // 6
    ==
    dig 7
    itob
    uncover 7
    intc_2 // 2
    uncover 7
    setbit
    pushint 3 // 3
    uncover 6
    setbit
    pushint 4 // 4
    uncover 5
    setbit
    pushint 5 // 5
    uncover 4
    setbit
    pushint 6 // 6
    uncover 3
    setbit
    dup2
    concat
    dig 3
    itob
    swap
    dig 1
    concat
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    dig 4
    pushint 7 // 7
    ==
    uncover 2
    pushint 7 // 7
    uncover 2
    setbit
    uncover 2
    swap
    concat
    dup
    dig 2
    concat
    dig 48
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 48
    uncover 3
    intc_3 // 8
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    concat
    swap
    concat
    dig 44
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 44
    bury 20
    b main_for_header@109

main_after_for@111:
    dig 46
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    dig 45
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    dig 45
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    dig 45
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    pushbytes "bool2"
    uncover 4
    app_global_put
    pushbytes "bool7"
    uncover 3
    app_global_put
    pushbytes "bool8"
    uncover 2
    app_global_put
    pushbytes "bool9"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_nested_array_route@13:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 22
    txna ApplicationArgs 2
    dup
    bury 50
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 34
    intc_2 // 2
    *
    bury 11
    dup
    len
    bury 4
    extract 2 0
    bury 42
    intc_0 // 0
    bury 18

main_for_header@114:
    dig 17
    dig 32
    <
    bz main_after_for@116
    dig 17
    dup
    intc_2 // 2
    *
    dig 43
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 13
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dup2
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    extract3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    +
    bury 11
    intc_1 // 1
    +
    bury 18
    b main_for_header@114

main_after_for@116:
    dig 9
    intc_2 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.dynamic_array<uint64>>
    intc_0 // 0
    bury 20

main_for_header@117:
    dig 19
    dig 22
    <
    bz main_after_for@122
    bytec_0 // 0x0000
    bury 40
    intc_0 // 0
    bury 12

main_for_header@119:
    dig 11
    dig 20
    <
    bz main_after_for@121
    dig 11
    dup
    itob
    dig 41
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 41
    intc_1 // 1
    +
    bury 12
    b main_for_header@119

main_after_for@121:
    dig 48
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    bytec 4 // 0x0002
    dig 42
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 49
    dig 19
    intc_1 // 1
    +
    bury 20
    b main_for_header@117

main_after_for@122:
    bytec_0 // 0x0000
    bury 36
    dig 48
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 31
    intc_0 // 0
    bury 16

main_for_header@123:
    dig 15
    dig 31
    <
    bz main_after_for@125
    dig 48
    extract 2 0
    dig 16
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_3 // 8
    *
    intc_2 // 2
    +
    extract3
    dup
    bury 40
    intc_0 // 0
    bury 5
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    bury 30
    intc_0 // 0
    bury 15

main_for_header@172:
    dig 14
    dig 30
    <
    bz main_after_for@174
    dig 38
    extract 2 0
    dig 15
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    dig 5
    +
    bury 5
    intc_1 // 1
    +
    bury 15
    b main_for_header@172

main_after_for@174:
    dig 3
    itob
    dig 36
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 36
    dig 15
    intc_1 // 1
    +
    bury 16
    b main_for_header@123

main_after_for@125:
    bytec_1 // 0x151f7c75
    dig 36
    concat
    log
    intc_1 // 1
    return

main_test_implicit_conversion_emit_route@12:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    pushbytes 0xfa40c0530002
    swap
    concat
    log
    intc_1 // 1
    return

main_test_implicit_conversion_log_route@11:
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    log
    intc_1 // 1
    return

main_test_dynamic_sized_named_tuple_array_route@10:
    bytec_0 // 0x0000
    bury 49
    intc_0 // 0
    bury 20

main_for_header@132:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@134
    dig 19
    dup
    intc_1 // 1
    +
    swap
    callsub times
    dig 50
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 50
    bury 20
    b main_for_header@132

main_after_for@134:
    dig 48
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 34
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 20

main_for_header@135:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@137
    dig 48
    extract 2 0
    dig 20
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 36
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    uncover 2
    callsub times
    ==
    assert // expected 2nd element to be correct
    bury 20
    b main_for_header@135

main_after_for@137:
    dig 48
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    swap
    bytec_2 // ""
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    swap
    pushbytes "   "
    ==
    &&
    assert // expected 4, 3
    pushbytes "f"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_dynamic_sized_tuple_array_route@9:
    bytec_0 // 0x0000
    bury 49
    intc_0 // 0
    bury 20

main_for_header@140:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@142
    dig 19
    dup
    intc_1 // 1
    +
    swap
    bzero
    dig 50
    dup
    intc_0 // 0
    extract_uint16
    swap
    extract 2 0
    dig 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 5 // 0x000a
    concat
    swap
    concat
    bytec 4 // 0x0002
    swap
    concat
    cover 2
    intc_1 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    bury 50
    bury 20
    b main_for_header@140

main_after_for@142:
    dig 48
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 35
    pushint 5 // 5
    ==
    assert
    intc_0 // 0
    bury 20

main_for_header@143:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@145
    dig 48
    extract 2 0
    dig 20
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dig 2
    intc_1 // 1
    +
    dig 37
    dig 1
    - // on error: index access is out of bounds
    dig 3
    len
    dig 2
    intc_2 // 2
    *
    dig 5
    swap
    extract_uint16
    uncover 2
    select
    swap
    cover 3
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    dig 2
    ==
    assert // expected 1st element to be correct
    len
    uncover 2
    ==
    assert // expected 2nd element to be correct
    bury 20
    b main_for_header@143

main_after_for@145:
    dig 48
    callsub dynamic_array_pop_dynamic_element
    bury 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dup
    intc_0 // 0
    extract_uint16
    dig 2
    intc_1 // 1
    - // on error: index access is out of bounds
    dig 2
    len
    dig 3
    intc_2 // 2
    extract_uint16
    dig 1
    swap
    dig 3
    select
    dig 4
    uncover 4
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    intc_1 // 1
    ==
    intc_0 // 0
    bzero
    uncover 2
    ==
    &&
    assert // expected 1, 0
    dig 1
    intc_2 // 2
    *
    dig 3
    swap
    extract_uint16
    uncover 2
    intc_1 // 1
    +
    uncover 4
    dig 1
    - // on error: index access is out of bounds
    swap
    intc_2 // 2
    *
    dig 4
    swap
    extract_uint16
    uncover 3
    swap
    uncover 2
    select
    substring3
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    intc_3 // 8
    extract_uint16
    dig 2
    len
    uncover 3
    cover 2
    substring3
    extract 2 0
    swap
    pushint 4 // 4
    ==
    pushint 3 // 3
    bzero
    uncover 2
    ==
    &&
    assert // expected 4, 3
    pushbytes "e"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_fixed_size_named_tuple_array_route@8:
    bytec_0 // 0x0000
    bury 49
    intc_0 // 0
    bury 20

main_for_header@148:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@150
    dig 19
    dup
    intc_2 // 2
    %
    !
    dig 1
    pushint 3 // 3
    *
    intc_2 // 2
    %
    !
    dig 2
    itob
    bytec_3 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    intc_1 // 1
    uncover 3
    setbit
    concat
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@148

main_after_for@150:
    dig 48
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 5 // 5
    ==
    assert
    dup
    extract 2 9
    dup
    intc_0 // 0
    extract_uint64
    dig 1
    pushint 64 // 64
    getbit
    uncover 2
    pushint 65 // 65
    getbit
    uncover 2
    !
    assert
    swap
    assert
    assert
    pushbytes "d"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_fixed_size_tuple_array_route@7:
    bytec_0 // 0x0000
    bury 49
    intc_0 // 0
    bury 20

main_for_header@153:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@155
    dig 19
    dup
    intc_1 // 1
    +
    swap
    intc_2 // 2
    +
    dig 1
    itob
    swap
    itob
    concat
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    bury 20
    b main_for_header@153

main_after_for@155:
    dig 48
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 5 // 5
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 5 // 5
    ==
    swap
    pushint 6 // 6
    ==
    &&
    assert
    pushint 16 // 16
    callsub dynamic_array_pop_fixed_size
    bury 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    dig 1
    extract 2 0
    dig 2
    extract 2 16
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    intc_1 // 1
    ==
    swap
    intc_2 // 2
    ==
    &&
    assert
    swap
    intc_1 // 1
    -
    pushint 16 // 16
    *
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    swap
    pushint 4 // 4
    ==
    swap
    pushint 5 // 5
    ==
    &&
    assert
    pushbytes "c"
    swap
    app_global_put
    intc_1 // 1
    return

main_test_bool_array_route@6:
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 11
    bytec_0 // 0x0000
    bury 49
    intc_0 // 0
    bury 20

main_for_header@158:
    dig 19
    dig 11
    <
    bz main_after_for@160
    txn NumAppArgs
    dig 20
    dup
    uncover 2
    ==
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 50
    swap
    intc_1 // 1
    intc_3 // 8
    callsub dynamic_array_concat_bits
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@158

main_after_for@160:
    dig 48
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 22
    dig 11
    dup
    cover 2
    ==
    assert
    bz main_after_if_else@162
    dig 20
    assert // index access is out of bounds
    dig 48
    pushint 16 // 16
    getbit
    !
    assert // expected element 0 to be False

main_after_if_else@162:
    dig 10
    intc_1 // 1
    >
    bz main_after_if_else@164
    intc_1 // 1
    dig 21
    <
    assert // index access is out of bounds
    dig 48
    pushint 17 // 17
    getbit
    !
    assert // expected element 1 to be False

main_after_if_else@164:
    dig 10
    intc_2 // 2
    >
    bz main_after_if_else@166
    intc_2 // 2
    dig 21
    <
    assert // index access is out of bounds
    dig 48
    pushint 18 // 18
    getbit
    assert // expected element 2 to be True

main_after_if_else@166:
    dig 10
    pushint 3 // 3
    >
    bz main_after_if_else@168
    dig 10
    intc_1 // 1
    -
    dup
    dig 22
    <
    assert // index access is out of bounds
    pushint 16 // 16
    +
    dig 49
    swap
    getbit
    !
    assert // expected last element to be False

main_after_if_else@168:
    pushbytes "g"
    dig 49
    app_global_put
    dig 10
    bz main_after_if_else@170
    dig 20
    intc_1 // 1
    -
    dup
    itob
    extract 6 0
    dig 50
    swap
    replace2 0
    dig 1
    pushint 16 // 16
    +
    intc_0 // 0
    setbit
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    intc_2 // 2
    +
    intc_0 // 0
    swap
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dig 11
    intc_1 // 1
    -
    ==
    assert

main_after_if_else@170:
    intc_1 // 1
    return

main_test_biguint_array_route@5:
    txn NumAppArgs
    intc_1 // 1
    -
    itob
    pushint 64 // 64
    bzero
    dup
    bury 52
    b|
    bytec_0 // 0x0000
    swap
    concat // on error: max array length exceeded
    pushbytes 0x0001
    replace2 0
    dup
    bury 50
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_1 // 1
    ==
    assert
    intc_1 // 1
    -
    swap
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec_2 // 0x
    b==
    assert
    intc_0 // 0
    bury 20

main_for_header@179:
    dig 19
    pushint 5 // 5
    <
    bz main_after_for@181
    dig 19
    dup
    itob
    dig 51
    b|
    dig 50
    dup
    uncover 2
    concat // on error: max array length exceeded
    swap
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    bury 50
    intc_1 // 1
    +
    bury 20
    b main_for_header@179

main_after_for@181:
    dig 48
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0x04
    b==
    assert
    txn NumAppArgs
    itob
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    swap
    b-
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    dig 52
    b|
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 7 // 7
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    pushbytes 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
    b==
    assert
    dig 1
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    swap
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_3 // 8
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    pushint 64 // 64
    *
    pushint 64 // 64
    extract3 // on error: index access is out of bounds
    bytec 6 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    b==
    assert
    dup
    extract 2 64
    bytec_2 // 0x
    b==
    assert
    bytec 10 // 0x62696775696e74
    box_del
    pop
    bytec 10 // 0x62696775696e74
    swap
    box_put
    intc_1 // 1
    return

main_test_uint64_array_route@4:
    pushbytes 0x0001000000000000002a
    pushint 5 // 5
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 6 // 6
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 4 // 4
    ==
    assert
    pushint 43 // 43
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    bury 50
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 7 // 7
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 43 // 43
    ==
    assert
    intc_2 // 2
    extract_uint64
    pushint 42 // 42
    ==
    assert
    intc_0 // 0
    bury 35

main_for_header@184:
    dig 34
    pushint 3 // 3
    <
    bz main_after_for@186
    dig 48
    intc_3 // 8
    callsub dynamic_array_pop_fixed_size
    bury 50
    pop
    dig 34
    intc_1 // 1
    +
    bury 35
    b main_for_header@184

main_after_for@186:
    dig 48
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 4 // 4
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    intc_2 // 2
    ==
    assert
    pushint 10 // 10
    callsub add_x
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 14 // 14
    ==
    assert
    dup
    intc_1 // 1
    -
    dig 2
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 9 // 9
    ==
    assert
    pushint 44 // 44
    itob
    uncover 2
    swap
    concat // on error: max array length exceeded
    swap
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    pushint 15 // 15
    ==
    assert
    intc_1 // 1
    -
    dig 1
    extract 2 0
    swap
    intc_3 // 8
    *
    extract_uint64
    pushint 44 // 44
    ==
    assert
    pushint 23 // 23
    itob
    replace2 18 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 15 // 15
    ==
    assert
    dup
    pushint 18 // 18
    extract_uint64
    pushint 23 // 23
    ==
    assert
    pushbytes "a"
    swap
    app_global_put
    intc_1 // 1
    return

main___algopy_default_create@31:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// _puya_lib.arc4.dynamic_array_pop_fixed_size(array: bytes, fixed_byte_size: uint64) -> bytes, bytes:
dynamic_array_pop_fixed_size:
    proto 2 2
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    itob
    extract 6 0
    frame_dig -2
    swap
    replace2 0
    dup
    len
    frame_dig -1
    -
    dup2
    frame_dig -1
    extract3
    uncover 2
    intc_0 // 0
    uncover 3
    substring3
    retsub


// _puya_lib.arc4.dynamic_array_pop_dynamic_element(array: bytes) -> bytes, bytes:
dynamic_array_pop_dynamic_element:
    proto 1 2
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    dup
    intc_2 // 2
    *
    dup
    frame_dig -1
    extract 2 0
    dup
    cover 2
    dup
    uncover 2
    extract_uint16
    dup
    uncover 2
    dup
    len
    swap
    cover 2
    substring3
    bytec_2 // 0x
    intc_0 // 0

dynamic_array_pop_dynamic_element_for_header@1:
    frame_dig 6
    frame_dig 1
    <
    bz dynamic_array_pop_dynamic_element_after_for@4
    frame_dig 2
    frame_dig 6
    dup
    cover 2
    extract_uint16
    intc_2 // 2
    -
    itob
    extract 6 2
    frame_dig 5
    swap
    concat
    frame_bury 5
    intc_2 // 2
    +
    frame_bury 6
    b dynamic_array_pop_dynamic_element_for_header@1

dynamic_array_pop_dynamic_element_after_for@4:
    frame_dig 0
    itob
    extract 6 2
    frame_dig 5
    concat
    frame_dig 1
    intc_2 // 2
    +
    frame_dig 2
    swap
    frame_dig 3
    substring3
    concat
    frame_dig 4
    frame_bury 0
    frame_bury 1
    retsub


// _puya_lib.arc4.dynamic_array_concat_bits(array: bytes, new_items_bytes: bytes, new_items_count: uint64, read_step: uint64) -> bytes:
dynamic_array_concat_bits:
    proto 4 1
    bytec_2 // ""
    dupn 2
    frame_dig -4
    intc_0 // 0
    extract_uint16
    dupn 2
    frame_dig -2
    +
    dup
    itob
    extract 6 0
    frame_dig -4
    swap
    replace2 0
    cover 2
    swap
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    uncover 2
    pushint 7 // 7
    +
    intc_3 // 8
    /
    dup
    cover 2
    <
    bz dynamic_array_concat_bits_after_if_else@2
    frame_dig 6
    frame_dig 5
    -
    bzero
    frame_dig 4
    swap
    concat
    frame_bury 4

dynamic_array_concat_bits_after_if_else@2:
    intc_0 // 0
    frame_bury 0
    frame_dig 3
    pushint 16 // 16
    +
    dup
    frame_bury 2
    frame_dig -2
    +
    frame_bury 1

dynamic_array_concat_bits_while_top@3:
    frame_dig 2
    frame_dig 1
    <
    bz dynamic_array_concat_bits_after_while@5
    frame_dig -3
    frame_dig 0
    dup
    cover 2
    getbit
    frame_dig 4
    frame_dig 2
    dup
    cover 3
    uncover 2
    setbit
    frame_bury 4
    intc_1 // 1
    +
    frame_bury 2
    frame_dig -1
    +
    frame_bury 0
    b dynamic_array_concat_bits_while_top@3

dynamic_array_concat_bits_after_while@5:
    frame_dig 4
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_0 // 0

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@4
    frame_dig 3
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 4
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 3
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@4:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_2 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_0 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_0 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// test_cases.array.immutable.sum_imm_fixed(arr: bytes) -> uint64:
sum_imm_fixed:
    proto 1 1
    intc_0 // 0
    dup

sum_imm_fixed_for_header@1:
    frame_dig 1
    pushint 3 // 3
    <
    bz sum_imm_fixed_after_for@4
    frame_dig 1
    dup
    pushint 16 // 16
    *
    frame_dig -1
    swap
    pushint 16 // 16
    extract3 // on error: index access is out of bounds
    dup
    intc_0 // 0
    extract_uint64
    frame_dig 0
    +
    swap
    intc_3 // 8
    extract_uint64
    +
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 1
    b sum_imm_fixed_for_header@1

sum_imm_fixed_after_for@4:
    retsub


// test_cases.array.immutable.times(n: uint64) -> bytes:
times:
    proto 1 1
    bytec_2 // ""
    intc_0 // 0

times_for_header@1:
    frame_dig 1
    frame_dig -1
    <
    bz times_after_for@4
    frame_dig 0
    pushbytes " "
    concat
    frame_bury 0
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b times_for_header@1

times_after_for@4:
    retsub


// test_cases.array.immutable.add_x(arr: bytes, x: uint64) -> bytes:
add_x:
    proto 2 1
    intc_0 // 0

add_x_for_header@1:
    frame_dig 0
    frame_dig -1
    <
    bz add_x_after_for@4
    frame_dig 0
    dup
    itob
    frame_dig -2
    swap
    concat // on error: max array length exceeded
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    +
    itob
    extract 6 2
    replace2 0
    frame_bury -2
    intc_1 // 1
    +
    frame_bury 0
    b add_x_for_header@1

add_x_after_for@4:
    frame_dig -2
    swap
    retsub
