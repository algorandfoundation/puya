contract FixedWithTups
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  boxes {
    ['tup_bag']: test_cases.mutable_native_types.fixed_with_tups.TupBag
  }
  
  subroutine test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.__init__(): void
  {
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.create_box(): void
  {
    box_create('tup_bag', size_of(test_cases.mutable_native_types.fixed_with_tups.TupBag))
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.num_tups(): uint64
  {
    return Box['tup_bag'].count
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.add_tup(tup: test_cases.mutable_native_types.fixed_with_tups.NamedTup): void
  {
    assert(Box['tup_bag'].count < 8u, comment="too many tups")
    Box['tup_bag'].items[Box['tup_bag'].count]: test_cases.mutable_native_types.fixed_with_tups.NamedTup = tup
    Box['tup_bag'].count += 1u
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.get_tup(index: uint64): test_cases.mutable_native_types.fixed_with_tups.NamedTup
  {
    assert(index < Box['tup_bag'].count, comment="index out of bounds")
    return Box['tup_bag'].items[index]
  }
  
  baremethod test_cases.mutable_native_types.fixed_with_tups.FixedWithTups.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

contract FixedWithImmStruct
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  boxes {
    ['tup_bag']: test_cases.mutable_native_types.fixed_with_immutable_struct.TupBag
  }
  
  subroutine test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.__init__(): void
  {
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.create_box(): void
  {
    box_create('tup_bag', size_of(test_cases.mutable_native_types.fixed_with_immutable_struct.TupBag))
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.num_tups(): uint64
  {
    return Box['tup_bag'].count
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.add_tup(tup: test_cases.mutable_native_types.fixed_with_immutable_struct.NamedTup): void
  {
    assert(Box['tup_bag'].count < 8u, comment="too many tups")
    Box['tup_bag'].items[Box['tup_bag'].count]: test_cases.mutable_native_types.fixed_with_immutable_struct.NamedTup = tup
    Box['tup_bag'].count += 1u
  }
  
  abimethod test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.get_tup(index: uint64): test_cases.mutable_native_types.fixed_with_immutable_struct.NamedTup
  {
    assert(index < Box['tup_bag'].count, comment="index out of bounds")
    return Box['tup_bag'].items[index]
  }
  
  baremethod test_cases.mutable_native_types.fixed_with_immutable_struct.FixedWithImmStruct.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

contract Contract
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  globals {
    ['nested']: test_cases.mutable_native_types.contract.NestedStruct
    [hex<"70">]: test_cases.mutable_native_types.contract.NestedStruct
    ['dyn']: test_cases.mutable_native_types.contract.DynamicStruct
    ['num_payments']: uint64
    ['payments']: arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8>
  }
  locals {
    [hex<"6C">]: test_cases.mutable_native_types.contract.NestedStruct
  }
  boxes {
    ['box']: test_cases.mutable_native_types.contract.LargeFixedStruct
    ['box_map']: uint64 => test_cases.mutable_native_types.contract.LargeFixedStruct
  }
  
  subroutine test_cases.mutable_native_types.contract.Contract.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.contract.Contract.__init__(): void
  {
    GlobalState['nested']: test_cases.mutable_native_types.contract.NestedStruct = new test_cases.mutable_native_types.contract.NestedStruct(fixed_a=new test_cases.mutable_native_types.contract.FixedStruct(a=txn<NumAppArgs>(), b=txn<NumAppArgs>()), fixed_b=new test_cases.mutable_native_types.contract.FixedStruct(a=txn<NumAppArgs>() + 1u, b=txn<NumAppArgs>() + 1u), tup=(a=txn<NumAppArgs>() + 1u, b=txn<NumAppArgs>() + 1u))
    GlobalState['dyn']: test_cases.mutable_native_types.contract.DynamicStruct = new test_cases.mutable_native_types.contract.DynamicStruct(a=txn<NumAppArgs>(), b=txn<NumAppArgs>(), c=hex<"">, d='', e=new arc4.dynamic_array<arc4.uint8>())
    GlobalState['num_payments']: uint64 = 0u
    GlobalState['payments']: arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8> = bzero(size_of(arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8>))
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.fixed_initialize(): void
  {
    arr_3: arc4.static_array<uint64, 3> = bzero(size_of(arc4.static_array<uint64, 3>))
    arr_3[0u]: uint64 = 0u
    arr_3[1u]: uint64 = 1u
    arr_3[2u]: uint64 = 2u
    arr_3_from_tuple: arc4.static_array<uint64, 3> = arc4_encode((0u, 1u, 2u), arc4.static_array<uint64, 3>)
    assert(arr_3 == arr_3_from_tuple, comment="should be the same")
    arr_3_from_full: arc4.static_array<uint64, 3> = new arc4.static_array<uint64, 3>(1u.copy(), 1u.copy(), 1u.copy())
    assert(arr_3_from_full[0u] == 1u)
    assert(arr_3_from_full[1u] == 1u)
    assert(arr_3_from_full[2u] == 1u)
    arr_3_from_fixed: arc4.static_array<uint64, 3> = arr_3.copy().copy()
    assert(arr_3 == arr_3_from_fixed, comment="should be the same")
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.add_payment(pay: test_cases.mutable_native_types.contract.Payment): void
  {
    assert(GlobalState['num_payments'] < 8u, comment="too many payments")
    GlobalState['payments'][GlobalState['num_payments']]: test_cases.mutable_native_types.contract.Payment = pay.copy()
    GlobalState['num_payments'] += 1u
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.increment_payment(index: uint64, amt: uint64): void
  {
    assert(index < GlobalState['num_payments'], comment="invalid payment index")
    GlobalState['payments'][index].amt += amt
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.create_storage(box_key: uint64): void
  {
    GlobalState[hex<"70">]: test_cases.mutable_native_types.contract.NestedStruct = GlobalState['nested'].copy()
    LocalState[hex<"6C">, txn<Sender>()]: test_cases.mutable_native_types.contract.NestedStruct = GlobalState['nested'].copy()
    assert(box_create('box', size_of(test_cases.mutable_native_types.contract.LargeFixedStruct)), comment="expected box to not exist")
    Box[BoxMapKey(prefix='box_map', key=box_key)].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_a.copy()
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.delete_storage(box_key: uint64): void
  {
    STATE_DELETE(GlobalState[hex<"70">])
    STATE_DELETE(LocalState[hex<"6C">, txn<Sender>()])
    STATE_DELETE(Box['box'])
    STATE_DELETE(Box[BoxMapKey(prefix='box_map', key=box_key)])
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.struct_arg(box_key: uint64, a: test_cases.mutable_native_types.contract.FixedStruct): void
  {
    GlobalState['nested'].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    GlobalState[hex<"70">].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    LocalState[hex<"6C">, txn<Sender>()].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    Box['box'].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    Box[BoxMapKey(prefix='box_map', key=box_key)].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.struct_return(): test_cases.mutable_native_types.contract.FixedStruct
  {
    return GlobalState['nested'].fixed_a
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.tup_return(): test_cases.mutable_native_types.contract.NamedTup
  {
    return GlobalState['nested'].tup
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.calculate_sum(): uint64
  {
    fixed_a: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_a
    fixed_b: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_b
    result: uint64 = test_cases.mutable_native_types.contract.add(fixed_a) + test_cases.mutable_native_types.contract.add(fixed_b)
    if (result < 100u) {
      (c, d): tuple<uint64,uint64> = GlobalState['nested'].tup
      result += c
      result += d
    }
    return result
  }
  
  baremethod test_cases.mutable_native_types.contract.Contract.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

subroutine add(val: test_cases.mutable_native_types.contract.FixedStruct): uint64
{
  return val.a + val.b
}