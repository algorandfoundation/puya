contract Contract
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  globals {
    ['nested']: test_cases.mutable_native_types.contract.NestedStruct
    [hex<"70">]: test_cases.mutable_native_types.contract.NestedStruct
    ['dyn']: test_cases.mutable_native_types.contract.DynamicStruct
    ['num_payments']: uint64
    ['payments']: arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8>
  }
  locals {
    [hex<"6C">]: test_cases.mutable_native_types.contract.NestedStruct
  }
  boxes {
    ['box']: test_cases.mutable_native_types.contract.LargeFixedStruct
    ['box_map']: uint64 => test_cases.mutable_native_types.contract.LargeFixedStruct
  }
  
  subroutine test_cases.mutable_native_types.contract.Contract.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.contract.Contract.__init__(): void
  {
    GlobalState['nested']: test_cases.mutable_native_types.contract.NestedStruct = new test_cases.mutable_native_types.contract.NestedStruct(fixed_a=new test_cases.mutable_native_types.contract.FixedStruct(a=txn<NumAppArgs>(), b=txn<NumAppArgs>()), fixed_b=new test_cases.mutable_native_types.contract.FixedStruct(a=txn<NumAppArgs>() + 1u, b=txn<NumAppArgs>() + 1u), tup=(a=txn<NumAppArgs>() + 1u, b=txn<NumAppArgs>() + 1u))
    GlobalState['dyn']: test_cases.mutable_native_types.contract.DynamicStruct = new test_cases.mutable_native_types.contract.DynamicStruct(a=txn<NumAppArgs>(), b=txn<NumAppArgs>(), c=hex<"">, d='', e=new arc4.dynamic_array<arc4.uint8>())
    GlobalState['num_payments']: uint64 = 0u
    GlobalState['payments']: arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8> = bzero(size_of(arc4.static_array<test_cases.mutable_native_types.contract.Payment, 8>))
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.fixed_initialize(): void
  {
    arr_3: arc4.static_array<uint64, 3> = bzero(size_of(arc4.static_array<uint64, 3>))
    arr_3[0u]: uint64 = 0u
    arr_3[1u]: uint64 = 1u
    arr_3[2u]: uint64 = 2u
    arr_3_from_tuple: arc4.static_array<uint64, 3> = arc4_encode((0u, 1u, 2u), arc4.static_array<uint64, 3>)
    assert(arr_3 == arr_3_from_tuple, comment="should be the same")
    arr_3_from_full: arc4.static_array<uint64, 3> = new arc4.static_array<uint64, 3>(1u.copy(), 1u.copy(), 1u.copy())
    assert(arr_3_from_full[0u] == 1u)
    assert(arr_3_from_full[1u] == 1u)
    assert(arr_3_from_full[2u] == 1u)
    arr_3_from_fixed: arc4.static_array<uint64, 3> = arr_3.copy().copy()
    assert(arr_3 == arr_3_from_fixed, comment="should be the same")
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.add_payment(pay: test_cases.mutable_native_types.contract.Payment): void
  {
    assert(GlobalState['num_payments'] < 8u, comment="too many payments")
    GlobalState['payments'][GlobalState['num_payments']]: test_cases.mutable_native_types.contract.Payment = pay.copy()
    GlobalState['num_payments'] += 1u
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.increment_payment(index: uint64, amt: uint64): void
  {
    assert(index < GlobalState['num_payments'], comment="invalid payment index")
    GlobalState['payments'][index].amt += amt
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.create_storage(box_key: uint64): void
  {
    GlobalState[hex<"70">]: test_cases.mutable_native_types.contract.NestedStruct = GlobalState['nested'].copy()
    LocalState[hex<"6C">, txn<Sender>()]: test_cases.mutable_native_types.contract.NestedStruct = GlobalState['nested'].copy()
    assert(box_create('box', size_of(test_cases.mutable_native_types.contract.LargeFixedStruct)), comment="expected box to not exist")
    Box[BoxMapKey(prefix='box_map', key=box_key)].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_a.copy()
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.local_struct(): test_cases.mutable_native_types.contract.Payment
  {
    a: test_cases.mutable_native_types.contract.Payment = new test_cases.mutable_native_types.contract.Payment(receiver=txn<Sender>(), asset=reinterpret_cast<asset>(1234u), amt=567u)
    (foo, bar, baz): tuple<account,asset,uint64> = (a.receiver, a.asset, a.amt)
    assert(foo != global<ZeroAddress>(), comment="use foo")
    assert(reinterpret_cast<bool>(bar), comment="use bar")
    assert(baz != 0u, comment="use baz")
    test_cases.mutable_native_types.contract.do_something(a)
    return a
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.delete_storage(box_key: uint64): void
  {
    STATE_DELETE(GlobalState[hex<"70">])
    STATE_DELETE(LocalState[hex<"6C">, txn<Sender>()])
    STATE_DELETE(Box['box'])
    STATE_DELETE(Box[BoxMapKey(prefix='box_map', key=box_key)])
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.struct_arg(box_key: uint64, a: test_cases.mutable_native_types.contract.FixedStruct): void
  {
    GlobalState['nested'].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    GlobalState[hex<"70">].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    LocalState[hex<"6C">, txn<Sender>()].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    Box['box'].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
    Box[BoxMapKey(prefix='box_map', key=box_key)].fixed_a: test_cases.mutable_native_types.contract.FixedStruct = a
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.struct_return(): test_cases.mutable_native_types.contract.FixedStruct
  {
    return GlobalState['nested'].fixed_a
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.tup_return(): test_cases.mutable_native_types.contract.NamedTup
  {
    return GlobalState['nested'].tup
  }
  
  abimethod test_cases.mutable_native_types.contract.Contract.calculate_sum(): uint64
  {
    fixed_a: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_a
    fixed_b: test_cases.mutable_native_types.contract.FixedStruct = GlobalState['nested'].fixed_b
    result: uint64 = test_cases.mutable_native_types.contract.add(fixed_a) + test_cases.mutable_native_types.contract.add(fixed_b)
    if (result < 100u) {
      (c, d): tuple<uint64,uint64> = GlobalState['nested'].tup
      result += c
      result += d
    }
    return result
  }
  
  baremethod test_cases.mutable_native_types.contract.Contract.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

subroutine add(val: test_cases.mutable_native_types.contract.FixedStruct): uint64
{
  return val.a + val.b
}

subroutine do_something(pay: test_cases.mutable_native_types.contract.Payment): void
{
}

contract Case3WithStruct
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  boxes {
    ['tup_bag']: test_cases.mutable_native_types.case3_with_mutable_struct.TupBag
  }
  
  subroutine test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.__init__(): void
  {
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.create_box(): void
  {
    assert(box_create('tup_bag', size_of(test_cases.mutable_native_types.case3_with_mutable_struct.TupBag)), comment="box already exists")
    Box['tup_bag'].owner: account = txn<Sender>()
    Box['tup_bag'].app: application = global<CurrentApplicationID>()
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.num_tups(): uint64
  {
    return Box['tup_bag'].count
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.add_tup(tup: test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup): void
  {
    this::_check_owner()
    assert(Box['tup_bag'].count < 8u, comment="too many tups")
    Box['tup_bag'].items[Box['tup_bag'].count]: test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup = tup.copy()
    Box['tup_bag'].count += 1u
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.get_tup(index: uint64): test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup
  {
    assert(index < Box['tup_bag'].count, comment="index out of bounds")
    return Box['tup_bag'].items[index]
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.sum(): uint64
  {
    total: uint64 = 0u
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup = Box['tup_bag'].items[i].copy()
      total += tup.a
      total += tup.b
    }
    return total
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.add_many_tups(tups: arc4.dynamic_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup>): void
  {
    for i in range(0u, tups.length, 1u) {
      this::add_tup(tups[i].copy())
    }
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.add_fixed_tups(tups: arc4.static_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup, 3>): void
  {
    for i in range(0u, 3u, 1u) {
      this::add_tup(tups[i].copy())
    }
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.set_a(a: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      Box['tup_bag'].items[i].a: uint64 = a
    }
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.set_b(b: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      Box['tup_bag'].items[i].b: uint64 = b
    }
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.get_3_tups(start: uint64): arc4.static_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup, 3>
  {
    assert(Box['tup_bag'].count >= start + 3u, comment="not enough items")
    items: arc4.static_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup, 8> = Box['tup_bag'].items.copy()
    return arc4_encode((items[start].copy(), items[start + 1u].copy(), items[start + 2u].copy()), arc4.static_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup, 3>)
  }
  
  abimethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.get_all_tups(): arc4.dynamic_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup>
  {
    result: arc4.dynamic_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup> = new arc4.dynamic_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup>()
    items: arc4.static_array<test_cases.mutable_native_types.case3_with_mutable_struct.NamedTup, 8> = Box['tup_bag'].items.copy()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      result.extend((items[i].copy()))
    }
    return result
  }
  
  subroutine test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct._check_owner(): void
  {
    assert(Box['tup_bag'].owner == txn<Sender>(), comment="sender not authorized")
    assert(Box['tup_bag'].app == global<CurrentApplicationID>(), comment="this error should be impossible")
  }
  
  baremethod test_cases.mutable_native_types.case3_with_mutable_struct.Case3WithStruct.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

contract Case2WithImmStruct
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  boxes {
    ['tup_bag']: test_cases.mutable_native_types.case2_with_immutable_struct.TupBag
  }
  
  subroutine test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.__init__(): void
  {
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.create_box(): void
  {
    assert(box_create('tup_bag', size_of(test_cases.mutable_native_types.case2_with_immutable_struct.TupBag)), comment="box already exists")
    Box['tup_bag'].owner: account = txn<Sender>()
    Box['tup_bag'].app: application = global<CurrentApplicationID>()
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.num_tups(): uint64
  {
    return Box['tup_bag'].count
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.add_tup(tup: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup): void
  {
    this::_check_owner()
    assert(Box['tup_bag'].count < 8u, comment="too many tups")
    Box['tup_bag'].items[Box['tup_bag'].count]: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = tup
    Box['tup_bag'].count += 1u
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.get_tup(index: uint64): test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup
  {
    assert(index < Box['tup_bag'].count, comment="index out of bounds")
    return Box['tup_bag'].items[index]
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.sum(): uint64
  {
    total: uint64 = 0u
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = Box['tup_bag'].items[i]
      total += tup.a
      total += tup.b
    }
    return total
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.add_many_tups(tups: arc4.dynamic_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup>): void
  {
    for tup in tups {
      this::add_tup(tup)
    }
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.add_fixed_tups(tups: arc4.static_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup, 3>): void
  {
    for tup in tups {
      this::add_tup(tup)
    }
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.set_a(a: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = Box['tup_bag'].items[i]
      Box['tup_bag'].items[i]: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = new test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup(a=a, b=tup.b)
    }
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.set_b(b: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = Box['tup_bag'].items[i]
      Box['tup_bag'].items[i]: test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup = new test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup(a=tup.a, b=b)
    }
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.get_3_tups(start: uint64): arc4.static_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup, 3>
  {
    assert(Box['tup_bag'].count >= start + 3u, comment="not enough items")
    items: arc4.static_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup, 8> = Box['tup_bag'].items.copy()
    return arc4_encode((items[start], items[start + 1u], items[start + 2u]), arc4.static_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup, 3>)
  }
  
  abimethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.get_all_tups(): arc4.dynamic_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup>
  {
    result: arc4.dynamic_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup> = new arc4.dynamic_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup>()
    items: arc4.static_array<test_cases.mutable_native_types.case2_with_immutable_struct.NamedTup, 8> = Box['tup_bag'].items.copy()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      result.extend((items[i]))
    }
    return result
  }
  
  subroutine test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct._check_owner(): void
  {
    assert(Box['tup_bag'].owner == txn<Sender>(), comment="sender not authorized")
    assert(Box['tup_bag'].app == global<CurrentApplicationID>(), comment="this error should be impossible")
  }
  
  baremethod test_cases.mutable_native_types.case2_with_immutable_struct.Case2WithImmStruct.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}

contract Case1WithTups
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
  )
  boxes {
    ['tup_bag']: test_cases.mutable_native_types.case1_with_tups.TupBag
  }
  
  subroutine test_cases.mutable_native_types.case1_with_tups.Case1WithTups.__algopy_entrypoint_with_init(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    return this::approval_program()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.mutable_native_types.case1_with_tups.Case1WithTups.__init__(): void
  {
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.create_box(): void
  {
    assert(box_create('tup_bag', size_of(test_cases.mutable_native_types.case1_with_tups.TupBag)), comment="box already exists")
    Box['tup_bag'].owner: account = txn<Sender>()
    Box['tup_bag'].app: application = global<CurrentApplicationID>()
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.num_tups(): uint64
  {
    return Box['tup_bag'].count
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.add_tup(tup: test_cases.mutable_native_types.case1_with_tups.NamedTup): void
  {
    this::_check_owner()
    assert(Box['tup_bag'].count < 8u, comment="too many tups")
    Box['tup_bag'].items[Box['tup_bag'].count]: test_cases.mutable_native_types.case1_with_tups.NamedTup = tup
    Box['tup_bag'].count += 1u
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.get_tup(index: uint64): test_cases.mutable_native_types.case1_with_tups.NamedTup
  {
    assert(index < Box['tup_bag'].count, comment="index out of bounds")
    return Box['tup_bag'].items[index]
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.sum(): uint64
  {
    total: uint64 = 0u
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case1_with_tups.NamedTup = Box['tup_bag'].items[i]
      total += tup.a
      total += tup.b
    }
    return total
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.add_many_tups(tups: arc4.dynamic_array<test_cases.mutable_native_types.case1_with_tups.NamedTup>): void
  {
    for tup in tups {
      this::add_tup(tup)
    }
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.add_fixed_tups(tups: arc4.static_array<test_cases.mutable_native_types.case1_with_tups.NamedTup, 3>): void
  {
    for tup in tups {
      this::add_tup(tup)
    }
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.set_a(a: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case1_with_tups.NamedTup = Box['tup_bag'].items[i]
      Box['tup_bag'].items[i]: test_cases.mutable_native_types.case1_with_tups.NamedTup = (a=a, b=tup[1])
    }
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.set_b(b: uint64): void
  {
    this::_check_owner()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      tup: test_cases.mutable_native_types.case1_with_tups.NamedTup = Box['tup_bag'].items[i]
      Box['tup_bag'].items[i]: test_cases.mutable_native_types.case1_with_tups.NamedTup = (a=tup[0], b=b)
    }
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.get_3_tups(start: uint64): arc4.static_array<test_cases.mutable_native_types.case1_with_tups.NamedTup, 3>
  {
    assert(Box['tup_bag'].count >= start + 3u, comment="not enough items")
    items: arc4.static_array<test_cases.mutable_native_types.case1_with_tups.NamedTup, 8> = Box['tup_bag'].items.copy()
    return arc4_encode((items[start], items[start + 1u], items[start + 2u]), arc4.static_array<test_cases.mutable_native_types.case1_with_tups.NamedTup, 3>)
  }
  
  abimethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.get_all_tups(): arc4.dynamic_array<test_cases.mutable_native_types.case1_with_tups.NamedTup>
  {
    result: arc4.dynamic_array<test_cases.mutable_native_types.case1_with_tups.NamedTup> = new arc4.dynamic_array<test_cases.mutable_native_types.case1_with_tups.NamedTup>()
    items: arc4.static_array<test_cases.mutable_native_types.case1_with_tups.NamedTup, 8> = Box['tup_bag'].items.copy()
    for i in range(0u, Box['tup_bag'].count, 1u) {
      result.extend((items[i]))
    }
    return result
  }
  
  subroutine test_cases.mutable_native_types.case1_with_tups.Case1WithTups._check_owner(): void
  {
    assert(Box['tup_bag'].owner == txn<Sender>(), comment="sender not authorized")
    assert(Box['tup_bag'].app == global<CurrentApplicationID>(), comment="this error should be impossible")
  }
  
  baremethod test_cases.mutable_native_types.case1_with_tups.Case1WithTups.__algopy_default_create(): void
  {
  }
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
}