// Op                                                                                  Stack (out)
// algopy.arc4.ARC4Contract.approval_program() -> uint64:
subroutine main:
    main_block@0:
        // mutable_native_types/abi_call.py:41
        // class CallMe(arc4.ARC4Contract):
        txn NumAppArgs                                                                 tmp%0#1
        l-load tmp%0#1 0                                                               tmp%0#1
        bz main___algopy_default_create@22 ; b main_abi_routing@4

    main_abi_routing@4:
        // mutable_native_types/abi_call.py:41
        // class CallMe(arc4.ARC4Contract):
        txna ApplicationArgs 0                                                         tmp%2#0
        method delete()void                                                            tmp%2#0,Method(delete()void)
        l-load tmp%2#0 1                                                               Method(delete()void),tmp%2#0
        match main_delete_route@5 ; b main_switch_case_next@6

    main_delete_route@5:
        // mutable_native_types/abi_call.py:49
        // @arc4.abimethod(allow_actions=["DeleteApplication"])
        txn OnCompletion                                                               tmp%3#0
        l-load tmp%3#0 0                                                               tmp%3#0
        int DeleteApplication                                                          tmp%3#0,DeleteApplication
        ==                                                                             tmp%4#0
        txn ApplicationID                                                              tmp%4#0,tmp%5#0
        l-load tmp%4#0 1                                                               tmp%5#0,tmp%4#0
        l-load tmp%5#0 1                                                               tmp%4#0,tmp%5#0
        &&                                                                             tmp%7#0
        l-load tmp%7#0 0                                                               tmp%7#0
        assert // OnCompletion must be DeleteApplication && can only call when not creating 
        int 1                                                                          1
        return

    main_switch_case_next@6:
        // mutable_native_types/abi_call.py:41
        // class CallMe(arc4.ARC4Contract):
        txn OnCompletion                                                               tmp%8#0
        l-load tmp%8#0 0                                                               tmp%8#0
        !                                                                              tmp%9#0
        l-load tmp%9#0 0                                                               tmp%9#0
        assert // OnCompletion must be NoOp
        txn ApplicationID                                                              tmp%10#0
        l-load tmp%10#0 0                                                              tmp%10#0
        assert
        txna ApplicationArgs 0                                                         tmp%12#0
        method fixed_struct_arg((uint64,uint64))void                                   tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void)
        method fixed_struct_ret()(uint64,uint64)                                       tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64))
        method nested_struct_arg(((uint64,uint64),uint64))void                         tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void)
        method nested_struct_ret()((uint64,uint64),uint64)                             tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64))
        method dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void)
        method dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])     tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[]))
        method fixed_arr_arg((uint64,uint64)[3])void                                   tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void)
        method fixed_arr_ret()(uint64,uint64)[3]                                       tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void),Method(fixed_arr_ret()(uint64,uint64)[3])
        method native_arr_arg((uint64,uint64)[])void                                   tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void),Method(fixed_arr_ret()(uint64,uint64)[3]),Method(native_arr_arg((uint64,uint64)[])void)
        method native_arr_ret()(uint64,uint64)[]                                       tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void),Method(fixed_arr_ret()(uint64,uint64)[3]),Method(native_arr_arg((uint64,uint64)[])void),Method(native_arr_ret()(uint64,uint64)[])
        method log_it()void                                                            tmp%12#0,Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void),Method(fixed_arr_ret()(uint64,uint64)[3]),Method(native_arr_arg((uint64,uint64)[])void),Method(native_arr_ret()(uint64,uint64)[]),Method(log_it()void)
        l-load tmp%12#0 11                                                             Method(fixed_struct_arg((uint64,uint64))void),Method(fixed_struct_ret()(uint64,uint64)),Method(nested_struct_arg(((uint64,uint64),uint64))void),Method(nested_struct_ret()((uint64,uint64),uint64)),Method(dynamic_struct_arg((uint64,uint64,byte[],string,(uint64,uint64)[]))void),Method(dynamic_struct_ret()(uint64,uint64,byte[],string,(uint64,uint64)[])),Method(fixed_arr_arg((uint64,uint64)[3])void),Method(fixed_arr_ret()(uint64,uint64)[3]),Method(native_arr_arg((uint64,uint64)[])void),Method(native_arr_ret()(uint64,uint64)[]),Method(log_it()void),tmp%12#0
        match main_fixed_struct_arg_route@8 main_fixed_struct_ret_route@9 main_nested_struct_arg_route@10 main_nested_struct_ret_route@11 main_dynamic_struct_arg_route@12 main_dynamic_struct_ret_route@13 main_fixed_arr_arg_route@14 main_fixed_arr_ret_route@15 main_native_arr_arg_route@16 main_native_arr_ret_route@17 main_log_it_route@18 ; b main_after_if_else@21 

    main_fixed_struct_arg_route@8:
        // mutable_native_types/abi_call.py:53
        // @arc4.abimethod()
        callsub fixed_struct_arg
        b main_after_if_else@21

    main_fixed_struct_ret_route@9:
        // mutable_native_types/abi_call.py:57
        // @arc4.abimethod()
        callsub fixed_struct_ret
        b main_after_if_else@21

    main_nested_struct_arg_route@10:
        // mutable_native_types/abi_call.py:61
        // @arc4.abimethod()
        callsub nested_struct_arg
        b main_after_if_else@21

    main_nested_struct_ret_route@11:
        // mutable_native_types/abi_call.py:65
        // @arc4.abimethod()
        callsub nested_struct_ret
        b main_after_if_else@21

    main_dynamic_struct_arg_route@12:
        // mutable_native_types/abi_call.py:69
        // @arc4.abimethod()
        callsub dynamic_struct_arg
        b main_after_if_else@21

    main_dynamic_struct_ret_route@13:
        // mutable_native_types/abi_call.py:73
        // @arc4.abimethod()
        callsub dynamic_struct_ret
        b main_after_if_else@21

    main_fixed_arr_arg_route@14:
        // mutable_native_types/abi_call.py:77
        // @arc4.abimethod()
        callsub fixed_arr_arg
        b main_after_if_else@21

    main_fixed_arr_ret_route@15:
        // mutable_native_types/abi_call.py:81
        // @arc4.abimethod()
        callsub fixed_arr_ret
        b main_after_if_else@21

    main_native_arr_arg_route@16:
        // mutable_native_types/abi_call.py:85
        // @arc4.abimethod()
        callsub native_arr_arg
        b main_after_if_else@21

    main_native_arr_ret_route@17:
        // mutable_native_types/abi_call.py:89
        // @arc4.abimethod()
        callsub native_arr_ret
        b main_after_if_else@21

    main_log_it_route@18:
        // mutable_native_types/abi_call.py:93
        // @arc4.abimethod()
        callsub log_it
        b main_after_if_else@21

    main_after_if_else@21:
        // mutable_native_types/abi_call.py:41
        // class CallMe(arc4.ARC4Contract):
        err

    main___algopy_default_create@22:
        txn OnCompletion                                                               tmp%13#0
        l-load tmp%13#0 0                                                              tmp%13#0
        !                                                                              tmp%14#0
        txn ApplicationID                                                              tmp%14#0,tmp%15#0
        l-load tmp%15#0 0                                                              tmp%14#0,tmp%15#0
        !                                                                              tmp%14#0,tmp%16#0
        l-load tmp%14#0 1                                                              tmp%16#0,tmp%14#0
        l-load tmp%16#0 1                                                              tmp%14#0,tmp%16#0
        &&                                                                             tmp%17#0
        l-load tmp%17#0 0                                                              tmp%17#0
        assert // OnCompletion must be NoOp && can only call when creating
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.fixed_struct_arg[routing]() -> void:
subroutine fixed_struct_arg:
    fixed_struct_arg_block@0:
        // mutable_native_types/abi_call.py:53
        // @arc4.abimethod()
        txna ApplicationArgs 1                                                         arg#0
        l-load-copy arg#0 0                                                            arg#0,arg#0 (copy)
        len                                                                            arg#0,len%0#0
        l-load len%0#0 0                                                               arg#0,len%0#0
        int 16                                                                         arg#0,len%0#0,16
        ==                                                                             arg#0,eq%0#0
        l-load eq%0#0 0                                                                arg#0,eq%0#0
        assert // invalid number of bytes for test_cases.mutable_native_types.abi_call.FixedStruct arg#0
        // mutable_native_types/abi_call.py:55
        // self.fixed_struct.value = arg
        byte "fixed_struct"                                                            arg#0,"fixed_struct"
        l-load arg#0 1                                                                 "fixed_struct",arg#0
        app_global_put
        // mutable_native_types/abi_call.py:53
        // @arc4.abimethod()
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.fixed_struct_ret[routing]() -> void:
subroutine fixed_struct_ret:
    fixed_struct_ret_block@0:
        // mutable_native_types/abi_call.py:59
        // return self.fixed_struct.value
        int 0                                                                          0
        byte "fixed_struct"                                                            0,"fixed_struct"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.fixed_struct exists                                       maybe_value%0#0
        // mutable_native_types/abi_call.py:57
        // @arc4.abimethod()
        byte 0x151f7c75                                                                maybe_value%0#0,0x151f7c75
        l-load maybe_value%0#0 1                                                       0x151f7c75,maybe_value%0#0
        concat                                                                         tmp%1#0
        l-load tmp%1#0 0                                                               tmp%1#0
        log
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.nested_struct_arg[routing]() -> void:
subroutine nested_struct_arg:
    nested_struct_arg_block@0:
        // mutable_native_types/abi_call.py:61
        // @arc4.abimethod()
        txna ApplicationArgs 1                                                         arg#0
        l-load-copy arg#0 0                                                            arg#0,arg#0 (copy)
        len                                                                            arg#0,len%0#0
        l-load len%0#0 0                                                               arg#0,len%0#0
        int 24                                                                         arg#0,len%0#0,24
        ==                                                                             arg#0,eq%0#0
        l-load eq%0#0 0                                                                arg#0,eq%0#0
        assert // invalid number of bytes for test_cases.mutable_native_types.abi_call.NestedStruct arg#0
        // mutable_native_types/abi_call.py:63
        // self.nested_struct.value = arg
        byte "nested_struct"                                                           arg#0,"nested_struct"
        l-load arg#0 1                                                                 "nested_struct",arg#0
        app_global_put
        // mutable_native_types/abi_call.py:61
        // @arc4.abimethod()
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.nested_struct_ret[routing]() -> void:
subroutine nested_struct_ret:
    nested_struct_ret_block@0:
        // mutable_native_types/abi_call.py:67
        // return self.nested_struct.value
        int 0                                                                          0
        byte "nested_struct"                                                           0,"nested_struct"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.nested_struct exists                                      maybe_value%0#0
        // mutable_native_types/abi_call.py:65
        // @arc4.abimethod()
        byte 0x151f7c75                                                                maybe_value%0#0,0x151f7c75
        l-load maybe_value%0#0 1                                                       0x151f7c75,maybe_value%0#0
        concat                                                                         tmp%1#0
        l-load tmp%1#0 0                                                               tmp%1#0
        log
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.dynamic_struct_arg[routing]() -> void:
subroutine dynamic_struct_arg:
    dynamic_struct_arg_block@0:
        // mutable_native_types/abi_call.py:69
        // @arc4.abimethod()
        txna ApplicationArgs 1                                                         arg#0
        l-load-copy arg#0 0                                                            arg#0,arg#0 (copy)
        int 16                                                                         arg#0,arg#0 (copy),16
        extract_uint16 // on error: invalid tuple encoding                             arg#0,extract_uint16%0#0
        l-load-copy extract_uint16%0#0 0                                               arg#0,extract_uint16%0#0,extract_uint16%0#0 (copy)
        int 22                                                                         arg#0,extract_uint16%0#0,extract_uint16%0#0 (copy),22
        ==                                                                             arg#0,extract_uint16%0#0,eq%0#0
        l-load eq%0#0 0                                                                arg#0,extract_uint16%0#0,eq%0#0
        assert // invalid tail pointer at index 2 of (uint64,uint64,(len+uint8[]),(len+utf8[]),(len+(uint64,uint64)[])) arg#0,extract_uint16%0#0
        l-load-copy arg#0 1                                                            arg#0,extract_uint16%0#0,arg#0 (copy)
        int 18                                                                         arg#0,extract_uint16%0#0,arg#0 (copy),18
        extract_uint16                                                                 arg#0,extract_uint16%0#0,aggregate%extract_uint16%1#0
        l-load-copy arg#0 2                                                            arg#0,extract_uint16%0#0,aggregate%extract_uint16%1#0,arg#0 (copy)
        l-load extract_uint16%0#0 2                                                    arg#0,aggregate%extract_uint16%1#0,arg#0 (copy),extract_uint16%0#0
        l-load-copy aggregate%extract_uint16%1#0 2                                     arg#0,aggregate%extract_uint16%1#0,arg#0 (copy),extract_uint16%0#0,aggregate%extract_uint16%1#0 (copy)
        substring3                                                                     arg#0,aggregate%extract_uint16%1#0,aggregate%substring3%0#0
        l-load aggregate%substring3%0#0 0                                              arg#0,aggregate%extract_uint16%1#0,aggregate%substring3%0#0
        int 0                                                                          arg#0,aggregate%extract_uint16%1#0,aggregate%substring3%0#0,0
        extract_uint16 // on error: invalid array length header                        arg#0,aggregate%extract_uint16%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                            arg#0,aggregate%extract_uint16%1#0,aggregate%array_length%0#0
        int 24                                                                         arg#0,aggregate%extract_uint16%1#0,aggregate%array_length%0#0,24
        +                                                                              arg#0,aggregate%extract_uint16%1#0,add%1#0
        l-load-copy aggregate%extract_uint16%1#0 1                                     arg#0,aggregate%extract_uint16%1#0,add%1#0,aggregate%extract_uint16%1#0 (copy)
        l-load-copy add%1#0 1                                                          arg#0,aggregate%extract_uint16%1#0,add%1#0,aggregate%extract_uint16%1#0 (copy),add%1#0 (copy)
        ==                                                                             arg#0,aggregate%extract_uint16%1#0,add%1#0,eq%1#0
        l-load eq%1#0 0                                                                arg#0,aggregate%extract_uint16%1#0,add%1#0,eq%1#0
        assert // invalid tail pointer at index 3 of (uint64,uint64,(len+uint8[]),(len+utf8[]),(len+(uint64,uint64)[])) arg#0,aggregate%extract_uint16%1#0,add%1#0
        l-load-copy arg#0 2                                                            arg#0,aggregate%extract_uint16%1#0,add%1#0,arg#0 (copy)
        int 20                                                                         arg#0,aggregate%extract_uint16%1#0,add%1#0,arg#0 (copy),20
        extract_uint16                                                                 arg#0,aggregate%extract_uint16%1#0,add%1#0,aggregate%extract_uint16%3#0
        l-load-copy arg#0 3                                                            arg#0,aggregate%extract_uint16%1#0,add%1#0,aggregate%extract_uint16%3#0,arg#0 (copy)
        l-load aggregate%extract_uint16%1#0 3                                          arg#0,add%1#0,aggregate%extract_uint16%3#0,arg#0 (copy),aggregate%extract_uint16%1#0
        l-load-copy aggregate%extract_uint16%3#0 2                                     arg#0,add%1#0,aggregate%extract_uint16%3#0,arg#0 (copy),aggregate%extract_uint16%1#0,aggregate%extract_uint16%3#0 (copy)
        substring3                                                                     arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%substring3%1#0
        l-load aggregate%substring3%1#0 0                                              arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%substring3%1#0
        int 0                                                                          arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%substring3%1#0,0
        extract_uint16 // on error: invalid array length header                        arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                            arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%array_length%1#0
        int 2                                                                          arg#0,add%1#0,aggregate%extract_uint16%3#0,aggregate%array_length%1#0,2
        +                                                                              arg#0,add%1#0,aggregate%extract_uint16%3#0,add%2#0
        l-load add%1#0 2                                                               arg#0,aggregate%extract_uint16%3#0,add%2#0,add%1#0
        l-load add%2#0 1                                                               arg#0,aggregate%extract_uint16%3#0,add%1#0,add%2#0
        +                                                                              arg#0,aggregate%extract_uint16%3#0,add%3#0
        l-load-copy aggregate%extract_uint16%3#0 1                                     arg#0,aggregate%extract_uint16%3#0,add%3#0,aggregate%extract_uint16%3#0 (copy)
        l-load-copy add%3#0 1                                                          arg#0,aggregate%extract_uint16%3#0,add%3#0,aggregate%extract_uint16%3#0 (copy),add%3#0 (copy)
        ==                                                                             arg#0,aggregate%extract_uint16%3#0,add%3#0,eq%2#0
        l-load eq%2#0 0                                                                arg#0,aggregate%extract_uint16%3#0,add%3#0,eq%2#0
        assert // invalid tail pointer at index 4 of (uint64,uint64,(len+uint8[]),(len+utf8[]),(len+(uint64,uint64)[])) arg#0,aggregate%extract_uint16%3#0,add%3#0
        l-load-copy arg#0 2                                                            arg#0,aggregate%extract_uint16%3#0,add%3#0,arg#0 (copy)
        len                                                                            arg#0,aggregate%extract_uint16%3#0,add%3#0,aggregate%len%0#0
        l-load-copy arg#0 3                                                            arg#0,aggregate%extract_uint16%3#0,add%3#0,aggregate%len%0#0,arg#0 (copy)
        l-load aggregate%extract_uint16%3#0 3                                          arg#0,add%3#0,aggregate%len%0#0,arg#0 (copy),aggregate%extract_uint16%3#0
        l-load-copy aggregate%len%0#0 2                                                arg#0,add%3#0,aggregate%len%0#0,arg#0 (copy),aggregate%extract_uint16%3#0,aggregate%len%0#0 (copy)
        substring3                                                                     arg#0,add%3#0,aggregate%len%0#0,aggregate%substring3%2#0
        l-load aggregate%substring3%2#0 0                                              arg#0,add%3#0,aggregate%len%0#0,aggregate%substring3%2#0
        int 0                                                                          arg#0,add%3#0,aggregate%len%0#0,aggregate%substring3%2#0,0
        extract_uint16 // on error: invalid array length header                        arg#0,add%3#0,aggregate%len%0#0,aggregate%array_length%2#0
        l-load aggregate%array_length%2#0 0                                            arg#0,add%3#0,aggregate%len%0#0,aggregate%array_length%2#0
        int 16                                                                         arg#0,add%3#0,aggregate%len%0#0,aggregate%array_length%2#0,16
        *                                                                              arg#0,add%3#0,aggregate%len%0#0,mul%2#0
        l-load mul%2#0 0                                                               arg#0,add%3#0,aggregate%len%0#0,mul%2#0
        int 2                                                                          arg#0,add%3#0,aggregate%len%0#0,mul%2#0,2
        +                                                                              arg#0,add%3#0,aggregate%len%0#0,add%4#0
        l-load add%3#0 2                                                               arg#0,aggregate%len%0#0,add%4#0,add%3#0
        l-load add%4#0 1                                                               arg#0,aggregate%len%0#0,add%3#0,add%4#0
        +                                                                              arg#0,aggregate%len%0#0,add%5#0
        l-load aggregate%len%0#0 1                                                     arg#0,add%5#0,aggregate%len%0#0
        l-load add%5#0 1                                                               arg#0,aggregate%len%0#0,add%5#0
        ==                                                                             arg#0,eq%3#0
        l-load eq%3#0 0                                                                arg#0,eq%3#0
        assert // invalid number of bytes for test_cases.mutable_native_types.abi_call.DynamicStruct arg#0
        // mutable_native_types/abi_call.py:71
        // self.dynamic_struct.value = arg.copy()
        byte "dynamic_struct"                                                          arg#0,"dynamic_struct"
        l-load arg#0 1                                                                 "dynamic_struct",arg#0
        app_global_put
        // mutable_native_types/abi_call.py:69
        // @arc4.abimethod()
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.dynamic_struct_ret[routing]() -> void:
subroutine dynamic_struct_ret:
    dynamic_struct_ret_block@0:
        // mutable_native_types/abi_call.py:75
        // return self.dynamic_struct.value
        int 0                                                                          0
        byte "dynamic_struct"                                                          0,"dynamic_struct"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.dynamic_struct exists                                     maybe_value%0#0
        // mutable_native_types/abi_call.py:73
        // @arc4.abimethod()
        byte 0x151f7c75                                                                maybe_value%0#0,0x151f7c75
        l-load maybe_value%0#0 1                                                       0x151f7c75,maybe_value%0#0
        concat                                                                         tmp%1#0
        l-load tmp%1#0 0                                                               tmp%1#0
        log
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.fixed_arr_arg[routing]() -> void:
subroutine fixed_arr_arg:
    fixed_arr_arg_block@0:
        // mutable_native_types/abi_call.py:77
        // @arc4.abimethod()
        txna ApplicationArgs 1                                                         arg#0
        l-load-copy arg#0 0                                                            arg#0,arg#0 (copy)
        len                                                                            arg#0,len%0#0
        l-load len%0#0 0                                                               arg#0,len%0#0
        int 48                                                                         arg#0,len%0#0,48
        ==                                                                             arg#0,eq%0#0
        l-load eq%0#0 0                                                                arg#0,eq%0#0
        assert // invalid number of bytes for arc4.static_array<test_cases.mutable_native_types.abi_call.FixedStruct, 3> arg#0
        // mutable_native_types/abi_call.py:79
        // self.fixed_arr.value = arg.copy()
        byte "fixed_arr"                                                               arg#0,"fixed_arr"
        l-load arg#0 1                                                                 "fixed_arr",arg#0
        app_global_put
        // mutable_native_types/abi_call.py:77
        // @arc4.abimethod()
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.fixed_arr_ret[routing]() -> void:
subroutine fixed_arr_ret:
    fixed_arr_ret_block@0:
        // mutable_native_types/abi_call.py:83
        // return self.fixed_arr.value
        int 0                                                                          0
        byte "fixed_arr"                                                               0,"fixed_arr"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.fixed_arr exists                                          maybe_value%0#0
        // mutable_native_types/abi_call.py:81
        // @arc4.abimethod()
        byte 0x151f7c75                                                                maybe_value%0#0,0x151f7c75
        l-load maybe_value%0#0 1                                                       0x151f7c75,maybe_value%0#0
        concat                                                                         tmp%1#0
        l-load tmp%1#0 0                                                               tmp%1#0
        log
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.native_arr_arg[routing]() -> void:
subroutine native_arr_arg:
    native_arr_arg_block@0:
        // mutable_native_types/abi_call.py:85
        // @arc4.abimethod()
        txna ApplicationArgs 1                                                         arg#0
        l-load-copy arg#0 0                                                            arg#0,arg#0 (copy)
        int 0                                                                          arg#0,arg#0 (copy),0
        extract_uint16 // on error: invalid array length header                        arg#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                            arg#0,aggregate%array_length%0#0
        int 16                                                                         arg#0,aggregate%array_length%0#0,16
        *                                                                              arg#0,mul%0#0
        l-load mul%0#0 0                                                               arg#0,mul%0#0
        int 2                                                                          arg#0,mul%0#0,2
        +                                                                              arg#0,add%0#0
        l-load-copy arg#0 1                                                            arg#0,add%0#0,arg#0 (copy)
        len                                                                            arg#0,add%0#0,len%0#0
        l-load len%0#0 0                                                               arg#0,add%0#0,len%0#0
        l-load add%0#0 1                                                               arg#0,len%0#0,add%0#0
        ==                                                                             arg#0,eq%0#0
        l-load eq%0#0 0                                                                arg#0,eq%0#0
        assert // invalid number of bytes for arc4.dynamic_array<test_cases.mutable_native_types.abi_call.FixedStruct> arg#0
        // mutable_native_types/abi_call.py:87
        // self.native_arr.value = arg.copy()
        byte "native_arr"                                                              arg#0,"native_arr"
        l-load arg#0 1                                                                 "native_arr",arg#0
        app_global_put
        // mutable_native_types/abi_call.py:85
        // @arc4.abimethod()
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.native_arr_ret[routing]() -> void:
subroutine native_arr_ret:
    native_arr_ret_block@0:
        // mutable_native_types/abi_call.py:91
        // return self.native_arr.value
        int 0                                                                          0
        byte "native_arr"                                                              0,"native_arr"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.native_arr exists                                         maybe_value%0#0
        // mutable_native_types/abi_call.py:89
        // @arc4.abimethod()
        byte 0x151f7c75                                                                maybe_value%0#0,0x151f7c75
        l-load maybe_value%0#0 1                                                       0x151f7c75,maybe_value%0#0
        concat                                                                         tmp%1#0
        l-load tmp%1#0 0                                                               tmp%1#0
        log
        int 1                                                                          1
        return


// test_cases.mutable_native_types.abi_call.CallMe.log_it[routing]() -> void:
subroutine log_it:
    log_it_block@0:
        // mutable_native_types/abi_call.py:95
        // log(self.fixed_struct.value)
        int 0                                                                          0
        byte "fixed_struct"                                                            0,"fixed_struct"
        app_global_get_ex                                                              maybe_value%0#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                      maybe_value%0#0,maybe_exists%0#0
        assert // check self.fixed_struct exists                                       maybe_value%0#0
        l-load maybe_value%0#0 0                                                       maybe_value%0#0
        log
        // mutable_native_types/abi_call.py:96
        // log(self.nested_struct.value)
        int 0                                                                          0
        byte "nested_struct"                                                           0,"nested_struct"
        app_global_get_ex                                                              maybe_value%1#0,maybe_exists%1#0
        l-load maybe_exists%1#0 0                                                      maybe_value%1#0,maybe_exists%1#0
        assert // check self.nested_struct exists                                      maybe_value%1#0
        l-load maybe_value%1#0 0                                                       maybe_value%1#0
        log
        // mutable_native_types/abi_call.py:97
        // log(self.dynamic_struct.value)
        int 0                                                                          0
        byte "dynamic_struct"                                                          0,"dynamic_struct"
        app_global_get_ex                                                              maybe_value%2#0,maybe_exists%2#0
        l-load maybe_exists%2#0 0                                                      maybe_value%2#0,maybe_exists%2#0
        assert // check self.dynamic_struct exists                                     maybe_value%2#0
        l-load maybe_value%2#0 0                                                       maybe_value%2#0
        log
        // mutable_native_types/abi_call.py:98
        // log(self.fixed_arr.value)
        int 0                                                                          0
        byte "fixed_arr"                                                               0,"fixed_arr"
        app_global_get_ex                                                              maybe_value%3#0,maybe_exists%3#0
        l-load maybe_exists%3#0 0                                                      maybe_value%3#0,maybe_exists%3#0
        assert // check self.fixed_arr exists                                          maybe_value%3#0
        l-load maybe_value%3#0 0                                                       maybe_value%3#0
        log
        // mutable_native_types/abi_call.py:99
        // log(self.native_arr.value)
        int 0                                                                          0
        byte "native_arr"                                                              0,"native_arr"
        app_global_get_ex                                                              maybe_value%4#0,maybe_exists%4#0
        l-load maybe_exists%4#0 0                                                      maybe_value%4#0,maybe_exists%4#0
        assert // check self.native_arr exists                                         maybe_value%4#0
        l-load maybe_value%4#0 0                                                       maybe_value%4#0
        log
        // mutable_native_types/abi_call.py:93
        // @arc4.abimethod()
        int 1                                                                          1
        return


