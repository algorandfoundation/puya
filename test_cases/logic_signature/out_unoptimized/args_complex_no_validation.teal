#pragma version 11
#pragma typetrack false

// test_cases.logic_signature.lsig_args_complex.args_complex_no_validation() -> uint64:
main:
    intcblock 0 1 8 7
    bytecblock 0x 0x00 0x21 0xff
    intc_0 // 0
    b main_block@0

main_block@0:
    // logic_signature/lsig_args_complex.py:149
    // arg0: UInt64,
    arg_0
    btoi
    // logic_signature/lsig_args_complex.py:150
    // arg1: Bytes,
    arg_1
    cover 1
    // logic_signature/lsig_args_complex.py:151
    // arg2: BigUInt,
    arg_2
    cover 2
    // logic_signature/lsig_args_complex.py:152
    // arg3: String,
    arg_3
    cover 3
    // logic_signature/lsig_args_complex.py:153
    // arg4: bool,
    arg 4
    btoi
    cover 4
    // logic_signature/lsig_args_complex.py:154
    // arg5: arc4.UInt8,
    arg 5
    cover 5
    // logic_signature/lsig_args_complex.py:155
    // arg6: arc4.UInt64,
    arg 6
    cover 6
    // logic_signature/lsig_args_complex.py:156
    // arg7: arc4.UInt128,
    arg 7
    cover 7
    // logic_signature/lsig_args_complex.py:157
    // arg8: arc4.Address,
    arg 8
    cover 8
    // logic_signature/lsig_args_complex.py:158
    // arg9: arc4.Bool,
    arg 9
    cover 9
    // logic_signature/lsig_args_complex.py:159
    // arg10: arc4.String,
    arg 10
    cover 10
    // logic_signature/lsig_args_complex.py:160
    // arg11: arc4.DynamicBytes,
    arg 11
    cover 11
    // logic_signature/lsig_args_complex.py:161
    // arg12: arc4.StaticArray[arc4.Byte, typing.Literal[4]],
    arg 12
    cover 12
    // logic_signature/lsig_args_complex.py:162
    // arg13: SimpleStruct,
    arg 13
    cover 13
    // logic_signature/lsig_args_complex.py:163
    // arg14: NestedStruct,
    arg 14
    cover 14
    // logic_signature/lsig_args_complex.py:164
    // arg15: arc4.Tuple[arc4.UInt8, arc4.UInt64],
    arg 15
    cover 15
    // logic_signature/lsig_args_complex.py:165
    // arg16: SimpleNamedTuple,
    arg 16
    arg 17
    uncover 1
    cover 16
    cover 17
    // logic_signature/lsig_args_complex.py:166
    // arg17: tuple[UInt64, Bytes],
    arg 18
    btoi
    arg 19
    cover 1
    cover 19
    cover 19
    // logic_signature/lsig_args_complex.py:167
    // arg18: tuple[UInt64, tuple[Bytes, UInt64]],
    arg 20
    btoi
    arg 21
    cover 1
    arg 22
    btoi
    uncover 1
    cover 21
    uncover 1
    cover 22
    cover 22
    // logic_signature/lsig_args_complex.py:168
    // arg19: OverwriteStruct,
    arg 23
    cover 23
    // logic_signature/lsig_args_complex.py:169
    // arg20: arc4.DynamicArray[arc4.UInt8],
    arg 24
    cover 24
    // logic_signature/lsig_args_complex.py:171-172
    // # verify args match raw op.arg values
    // assert arg0 == op.btoi(op.arg(0))
    arg_0
    btoi
    dig 1
    ==
    assert
    // logic_signature/lsig_args_complex.py:173
    // assert arg1 == op.arg(1)
    arg_1
    dig 2
    ==
    assert
    // logic_signature/lsig_args_complex.py:174
    // assert arg2.bytes == op.arg(2)
    arg_2
    dig 3
    ==
    assert
    // logic_signature/lsig_args_complex.py:175
    // assert arg3.bytes == op.arg(3)
    arg_3
    dig 4
    ==
    assert
    // logic_signature/lsig_args_complex.py:176
    // assert arg4 == (op.btoi(op.arg(4)) != 0)
    arg 4
    btoi
    intc_0 // 0
    !=
    uncover 5
    ==
    assert
    // logic_signature/lsig_args_complex.py:177
    // assert arg5.bytes == op.arg(5)
    arg 5
    dig 5
    ==
    assert
    // logic_signature/lsig_args_complex.py:178
    // assert arg6.bytes == op.arg(6)
    arg 6
    dig 6
    ==
    assert
    // logic_signature/lsig_args_complex.py:179
    // assert arg7.bytes == op.arg(7)
    arg 7
    dig 7
    ==
    assert
    // logic_signature/lsig_args_complex.py:180
    // assert arg8.bytes == op.arg(8)
    arg 8
    uncover 8
    ==
    assert
    // logic_signature/lsig_args_complex.py:181
    // assert arg9.bytes == op.arg(9)
    arg 9
    dig 8
    ==
    assert
    // logic_signature/lsig_args_complex.py:182
    // assert arg10.bytes == op.arg(10)
    arg 10
    dig 9
    ==
    assert
    // logic_signature/lsig_args_complex.py:183
    // assert arg11.bytes == op.arg(11)
    arg 11
    dig 10
    ==
    assert
    // logic_signature/lsig_args_complex.py:184
    // assert arg12.bytes == op.arg(12)
    arg 12
    dig 11
    ==
    assert
    // logic_signature/lsig_args_complex.py:185
    // assert arg13.bytes == op.arg(13)
    arg 13
    dig 12
    ==
    assert
    // logic_signature/lsig_args_complex.py:186
    // assert arg14.bytes == op.arg(14)
    arg 14
    dig 13
    ==
    assert
    // logic_signature/lsig_args_complex.py:187
    // assert arg15.bytes == op.arg(15)
    arg 15
    dig 15
    ==
    assert
    // logic_signature/lsig_args_complex.py:188
    // assert arg16[0].bytes == op.arg(16)
    arg 16
    dig 14
    ==
    assert
    // logic_signature/lsig_args_complex.py:189
    // assert arg16[1].bytes == op.arg(17)
    arg 17
    uncover 16
    ==
    assert
    // logic_signature/lsig_args_complex.py:190
    // assert arg17[0] == op.btoi(op.arg(18))
    arg 18
    btoi
    dig 16
    ==
    assert
    // logic_signature/lsig_args_complex.py:191
    // assert arg17[1] == op.arg(19)
    arg 19
    dig 18
    ==
    assert
    // logic_signature/lsig_args_complex.py:192
    // assert arg18[0] == op.btoi(op.arg(20))
    arg 20
    btoi
    dig 17
    ==
    assert
    // logic_signature/lsig_args_complex.py:193
    // assert arg18[1][0] == op.arg(21)
    arg 21
    dig 19
    ==
    assert
    // logic_signature/lsig_args_complex.py:194
    // assert arg18[1][1] == op.btoi(op.arg(22))
    arg 22
    btoi
    dig 20
    ==
    assert
    // logic_signature/lsig_args_complex.py:195
    // assert arg19.bytes == op.arg(23)
    arg 23
    dig 21
    ==
    assert
    // logic_signature/lsig_args_complex.py:196
    // assert arg20.bytes == op.arg(24)
    arg 24
    dig 22
    ==
    assert
    // logic_signature/lsig_args_complex.py:198-199
    // # mutate all
    // arg0 = arg0 + 1
    intc_1 // 1
    +
    cover 21
    // logic_signature/lsig_args_complex.py:200
    // arg1 = arg1 + b"!"
    bytec_2 // 0x21
    concat
    cover 20
    // logic_signature/lsig_args_complex.py:201
    // arg2 = arg2 + BigUInt(1)
    pushbytes 0x01
    b+
    cover 19
    // logic_signature/lsig_args_complex.py:202
    // arg3 = String("hello_") + arg3
    pushbytes "hello_"
    uncover 1
    concat
    cover 18
    // logic_signature/lsig_args_complex.py:204
    // arg5 = arc4.UInt8(arg5.as_uint64() + 1)
    btoi
    intc_1 // 1
    +
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    intc_3 // 7
    intc_1 // 1
    extract3
    cover 17
    // logic_signature/lsig_args_complex.py:205
    // arg6 = arc4.UInt64(arg6.as_uint64() + 1)
    btoi
    intc_1 // 1
    +
    itob
    cover 16
    // logic_signature/lsig_args_complex.py:206
    // arg7 = arc4.UInt128(arg7.as_biguint() + BigUInt(1))
    pushbytes 0x01
    b+
    dup
    len
    pushint 16
    <=
    assert // overflow
    pushint 16
    bzero
    b|
    cover 15
    // logic_signature/lsig_args_complex.py:207
    // arg8 = arc4.Address(op.Global.zero_address)
    global ZeroAddress
    cover 15
    // logic_signature/lsig_args_complex.py:208
    // arg9 = arc4.Bool(not arg9.native)
    intc_0 // 0
    getbit
    !
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    cover 14
    // logic_signature/lsig_args_complex.py:209
    // arg10 = arc4.String(arg10.native + " world")
    extract 2 0
    pushbytes " world"
    concat
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    cover 13
    // logic_signature/lsig_args_complex.py:210
    // arg11 = arc4.DynamicBytes(arg11.native + b"\x00")
    extract 2 0
    bytec_1 // 0x00
    concat
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    cover 12
    // logic_signature/lsig_args_complex.py:211
    // arg12[0] = arc4.Byte(0xFF)
    intc_0 // 0
    intc_1 // 1
    *
    bytec_3 // 0xff
    replace3 // on error: index access is out of bounds
    cover 11
    // logic_signature/lsig_args_complex.py:212
    // arg13 = SimpleStruct(x=arc4.UInt64(arg13.x.as_uint64() + 1), y=arg13.y)
    dup
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    intc_1 // 1
    +
    itob
    uncover 1
    intc_2 // 8
    intc_2 // 8
    extract3
    bytec_0 // 0x
    uncover 2
    concat
    uncover 1
    concat
    cover 10
    // logic_signature/lsig_args_complex.py:214
    // header=arc4.UInt8(arg14.header.as_uint64() + 1),
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_1 // 1
    +
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    intc_3 // 7
    intc_1 // 1
    extract3
    // logic_signature/lsig_args_complex.py:215
    // data=arg14.data.copy(),
    uncover 1
    intc_1 // 1
    pushint 16
    extract3
    // logic_signature/lsig_args_complex.py:213-216
    // arg14 = NestedStruct(
    //     header=arc4.UInt8(arg14.header.as_uint64() + 1),
    //     data=arg14.data.copy(),
    // )
    bytec_0 // 0x
    uncover 2
    concat
    uncover 1
    concat
    cover 9
    // logic_signature/lsig_args_complex.py:219
    // arc4.UInt8(arg15[0].as_uint64() + 1),
    dig 1
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_1 // 1
    +
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    intc_3 // 7
    intc_1 // 1
    extract3
    // logic_signature/lsig_args_complex.py:220
    // arc4.UInt64(arg15[1].as_uint64() + 1),
    uncover 2
    intc_1 // 1
    intc_2 // 8
    extract3
    btoi
    intc_1 // 1
    +
    itob
    // logic_signature/lsig_args_complex.py:217-222
    // arg15 = arc4.Tuple(
    //     (
    //         arc4.UInt8(arg15[0].as_uint64() + 1),
    //         arc4.UInt64(arg15[1].as_uint64() + 1),
    //     )
    // )
    bytec_0 // 0x
    uncover 2
    concat
    uncover 1
    concat
    cover 8
    // logic_signature/lsig_args_complex.py:224
    // a=arc4.UInt8(arg16.a.as_uint64() + 1),
    btoi
    intc_1 // 1
    +
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    intc_3 // 7
    intc_1 // 1
    extract3
    // logic_signature/lsig_args_complex.py:223-226
    // arg16 = SimpleNamedTuple(
    //     a=arc4.UInt8(arg16.a.as_uint64() + 1),
    //     b=arc4.UInt64(arg16.b.as_uint64() + 1),
    // )
    cover 7
    // logic_signature/lsig_args_complex.py:227
    // arg17 = (arg17[0] + 1, arg17[1] + b"!")
    intc_1 // 1
    +
    uncover 2
    bytec_2 // 0x21
    concat
    uncover 1
    cover 6
    cover 5
    // logic_signature/lsig_args_complex.py:228
    // arg18 = (arg18[0] + 1, (arg18[1][0] + b"!", arg18[1][1] + 1))
    intc_1 // 1
    +
    uncover 1
    bytec_2 // 0x21
    concat
    uncover 2
    intc_1 // 1
    +
    uncover 2
    cover 4
    uncover 1
    cover 3
    cover 2
    // logic_signature/lsig_args_complex.py:230
    // value=arc4.UInt8(arg19.value.as_uint64() + 1),
    dup
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_1 // 1
    +
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    intc_3 // 7
    intc_1 // 1
    extract3
    // logic_signature/lsig_args_complex.py:231
    // dont_overwrite_me=arc4.Bool(not arg19.dont_overwrite_me.native),
    uncover 1
    intc_2 // 8
    getbit
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    bytec_1 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    // logic_signature/lsig_args_complex.py:229-232
    // arg19 = OverwriteStruct(
    //     value=arc4.UInt8(arg19.value.as_uint64() + 1),
    //     dont_overwrite_me=arc4.Bool(not arg19.dont_overwrite_me.native),
    // )
    bytec_0 // 0x
    uncover 2
    concat
    uncover 1
    concat
    cover 1
    // logic_signature/lsig_args_complex.py:233
    // arg20.append(arc4.UInt8(0xFF))
    bytec_0 // 0x
    bytec_3 // 0xff
    concat
    b main_block@1

main_block@1:
    dig 1
    dup
    intc_0 // 0
    extract_uint16
    // logic_signature/lsig_args_complex.py:233
    // arg20.append(arc4.UInt8(0xFF))
    intc_1 // 1
    +
    itob
    extract 6 0
    replace2 0
    dig 1
    concat
    bury 25
    // logic_signature/lsig_args_complex.py:233
    // arg20.append(arc4.UInt8(0xFF))
    b main_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2

main_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2:
    // logic_signature/lsig_args_complex.py:233
    // arg20.append(arc4.UInt8(0xFF))
    dig 24
    // logic_signature/lsig_args_complex.py:235-236
    // # assert all
    // assert arg0 > 0
    dig 24
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:237
    // assert arg1.length > 0
    dig 23
    len
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:238
    // assert arg2 > 0
    dig 22
    bytec_0 // 0x
    b>
    assert
    // logic_signature/lsig_args_complex.py:239
    // assert arg3.bytes.length > 0
    dig 21
    len
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:240
    // assert arg5.as_uint64() > 0
    dig 20
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:241
    // assert arg6.as_uint64() > 0
    dig 19
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:242
    // assert arg7.as_biguint() > 0
    dig 18
    bytec_0 // 0x
    b>
    assert
    // logic_signature/lsig_args_complex.py:243
    // assert arg8.native == op.Global.zero_address
    dig 17
    global ZeroAddress
    ==
    assert
    // logic_signature/lsig_args_complex.py:244
    // assert arg10.native.bytes.length > 0
    dig 15
    extract 2 0
    len
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:245
    // assert arg11.length > 0
    dig 14
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:246
    // assert arg12[0] == arc4.Byte(0xFF)
    intc_0 // 0
    intc_1 // 1
    *
    dig 14
    uncover 1
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    bytec_3 // 0xff
    b==
    assert
    // logic_signature/lsig_args_complex.py:247
    // assert arg13.x.as_uint64() > 0
    dig 12
    intc_0 // 0
    intc_2 // 8
    extract3
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:248
    // assert arg14.header.as_uint64() > 0
    dig 11
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:249
    // assert arg15[0].as_uint64() > 0
    dig 10
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:250
    // assert arg16.a.as_uint64() > 0
    dig 9
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:251
    // assert arg17[0] > 0
    dig 8
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:252
    // assert arg17[1].length > 0
    dig 7
    len
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:253
    // assert arg18[0] > 0
    dig 6
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:254
    // assert arg18[1][0].length > 0
    dig 5
    len
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:255
    // assert arg18[1][1] > 0
    dig 4
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:256
    // assert arg19.value.as_uint64() > 0
    dig 3
    intc_0 // 0
    intc_1 // 1
    extract3
    btoi
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:257
    // assert arg20.length > 0
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0
    >
    assert
    // logic_signature/lsig_args_complex.py:259
    // return arg9.native
    dig 15
    intc_0 // 0
    getbit
    return
