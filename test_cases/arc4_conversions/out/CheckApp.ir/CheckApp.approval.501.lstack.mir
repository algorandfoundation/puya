// Op                                                                                 Stack (out)
// algopy.arc4.ARC4Contract.approval_program() -> uint64:
subroutine main:
    main_block@0:
        // arc4_conversions/contract.py:230
        // class CheckApp(arc4.ARC4Contract):
        txn NumAppArgs                                                                tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        bz main___algopy_default_create@21 ; b main_abi_routing@2

    main_abi_routing@2:
        // arc4_conversions/contract.py:230
        // class CheckApp(arc4.ARC4Contract):
        txna ApplicationArgs 0                                                        tmp%2#0
        method delete_application()void                                               tmp%2#0,Method(delete_application()void)
        l-load tmp%2#0 1                                                              Method(delete_application()void),tmp%2#0
        match main_delete_application_route@3 ; b main_switch_case_next@4

    main_delete_application_route@3:
        // arc4_conversions/contract.py:231
        // @arc4.abimethod(allow_actions=["DeleteApplication"])
        txn OnCompletion                                                              tmp%3#0
        l-load tmp%3#0 0                                                              tmp%3#0
        int DeleteApplication                                                         tmp%3#0,DeleteApplication
        ==                                                                            tmp%4#0
        txn ApplicationID                                                             tmp%4#0,tmp%5#0
        l-load tmp%4#0 1                                                              tmp%5#0,tmp%4#0
        l-load tmp%5#0 1                                                              tmp%4#0,tmp%5#0
        &&                                                                            tmp%7#0
        l-load tmp%7#0 0                                                              tmp%7#0
        assert // OnCompletion must be DeleteApplication && can only call when not creating 
        int 1                                                                         1
        return

    main_switch_case_next@4:
        // arc4_conversions/contract.py:230
        // class CheckApp(arc4.ARC4Contract):
        txn OnCompletion                                                              tmp%8#0
        l-load tmp%8#0 0                                                              tmp%8#0
        !                                                                             tmp%9#0
        l-load tmp%9#0 0                                                              tmp%9#0
        assert // OnCompletion must be NoOp
        txn ApplicationID                                                             tmp%10#0
        l-load tmp%10#0 0                                                             tmp%10#0
        assert
        txna ApplicationArgs 0                                                        tmp%12#0
        method check_uint64(uint64,byte[])void                                        tmp%12#0,Method(check_uint64(uint64,byte[])void)
        method check_dynamic_bytes(byte[],byte[])void                                 tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void)
        method check_string(string,byte[])void                                        tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void)
        method check_biguint(uint512,byte[])void                                      tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void)
        method check_bool(bool,byte[])void                                            tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void)
        method check_dyn_array_uin64(uint64[],byte[])void                             tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void)
        method check_static_array_uin64_3(uint64[3],byte[])void                       tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void)
        method check_dyn_array_struct((uint64,address)[],byte[])void                  tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void)
        method check_static_array_struct((uint64,address)[3],byte[])void              tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void),Method(check_static_array_struct((uint64,address)[3],byte[])void)
        method check_dyn_array_dyn_struct((uint64,address,byte[])[],byte[])void       tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void),Method(check_static_array_struct((uint64,address)[3],byte[])void),Method(check_dyn_array_dyn_struct((uint64,address,byte[])[],byte[])void)
        method check_static_array_dyn_struct((uint64,address,byte[])[3],byte[])void   tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void),Method(check_static_array_struct((uint64,address)[3],byte[])void),Method(check_dyn_array_dyn_struct((uint64,address,byte[])[],byte[])void),Method(check_static_array_dyn_struct((uint64,address,byte[])[3],byte[])void)
        method check_static_bytes(byte[32])void                                       tmp%12#0,Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void),Method(check_static_array_struct((uint64,address)[3],byte[])void),Method(check_dyn_array_dyn_struct((uint64,address,byte[])[],byte[])void),Method(check_static_array_dyn_struct((uint64,address,byte[])[3],byte[])void),Method(check_static_bytes(byte[32])void)
        l-load tmp%12#0 12                                                            Method(check_uint64(uint64,byte[])void),Method(check_dynamic_bytes(byte[],byte[])void),Method(check_string(string,byte[])void),Method(check_biguint(uint512,byte[])void),Method(check_bool(bool,byte[])void),Method(check_dyn_array_uin64(uint64[],byte[])void),Method(check_static_array_uin64_3(uint64[3],byte[])void),Method(check_dyn_array_struct((uint64,address)[],byte[])void),Method(check_static_array_struct((uint64,address)[3],byte[])void),Method(check_dyn_array_dyn_struct((uint64,address,byte[])[],byte[])void),Method(check_static_array_dyn_struct((uint64,address,byte[])[3],byte[])void),Method(check_static_bytes(byte[32])void),tmp%12#0
        match main_check_uint64_route@6 main_check_dynamic_bytes_route@7 main_check_string_route@8 main_check_biguint_route@9 main_check_bool_route@10 main_check_dyn_array_uin64_route@11 main_check_static_array_uin64_3_route@12 main_check_dyn_array_struct_route@13 main_check_static_array_struct_route@14 main_check_dyn_array_dyn_struct_route@15 main_check_static_array_dyn_struct_route@16 main_check_static_bytes_route@17 ; b main_after_if_else@20 

    main_check_uint64_route@6:
        // arc4_conversions/contract.py:235
        // @arc4.abimethod
        callsub check_uint64
        b main_after_if_else@20

    main_check_dynamic_bytes_route@7:
        // arc4_conversions/contract.py:239
        // @arc4.abimethod
        callsub check_dynamic_bytes
        b main_after_if_else@20

    main_check_string_route@8:
        // arc4_conversions/contract.py:243
        // @arc4.abimethod
        callsub check_string
        b main_after_if_else@20

    main_check_biguint_route@9:
        // arc4_conversions/contract.py:247
        // @arc4.abimethod
        callsub check_biguint
        b main_after_if_else@20

    main_check_bool_route@10:
        // arc4_conversions/contract.py:251
        // @arc4.abimethod
        callsub check_bool
        b main_after_if_else@20

    main_check_dyn_array_uin64_route@11:
        // arc4_conversions/contract.py:255
        // @arc4.abimethod
        callsub check_dyn_array_uin64
        b main_after_if_else@20

    main_check_static_array_uin64_3_route@12:
        // arc4_conversions/contract.py:261
        // @arc4.abimethod
        callsub check_static_array_uin64_3
        b main_after_if_else@20

    main_check_dyn_array_struct_route@13:
        // arc4_conversions/contract.py:267
        // @arc4.abimethod
        callsub check_dyn_array_struct
        b main_after_if_else@20

    main_check_static_array_struct_route@14:
        // arc4_conversions/contract.py:273
        // @arc4.abimethod
        callsub check_static_array_struct
        b main_after_if_else@20

    main_check_dyn_array_dyn_struct_route@15:
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        callsub check_dyn_array_dyn_struct
        b main_after_if_else@20

    main_check_static_array_dyn_struct_route@16:
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        callsub check_static_array_dyn_struct
        b main_after_if_else@20

    main_check_static_bytes_route@17:
        // arc4_conversions/contract.py:291
        // @arc4.abimethod
        callsub check_static_bytes
        b main_after_if_else@20

    main_after_if_else@20:
        // arc4_conversions/contract.py:230
        // class CheckApp(arc4.ARC4Contract):
        err

    main___algopy_default_create@21:
        txn OnCompletion                                                              tmp%13#0
        l-load tmp%13#0 0                                                             tmp%13#0
        !                                                                             tmp%14#0
        txn ApplicationID                                                             tmp%14#0,tmp%15#0
        l-load tmp%15#0 0                                                             tmp%14#0,tmp%15#0
        !                                                                             tmp%14#0,tmp%16#0
        l-load tmp%14#0 1                                                             tmp%16#0,tmp%14#0
        l-load tmp%16#0 1                                                             tmp%14#0,tmp%16#0
        &&                                                                            tmp%17#0
        l-load tmp%17#0 0                                                             tmp%17#0
        assert // OnCompletion must be NoOp && can only call when creating
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_uint64[routing]() -> void:
subroutine check_uint64:
    check_uint64_block@0:
        // arc4_conversions/contract.py:235
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        int 8                                                                         value#0,len%0#0,8
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.uint64                             value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,tmp%1#0,aggregate%array_length%0#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%0#0,2
        +                                                                             value#0,tmp%1#0,add%0#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%0#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%0#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%0#0,len%1#0
        l-load add%0#0 1                                                              value#0,tmp%1#0,len%1#0,add%0#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:237
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:235
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_dynamic_bytes[routing]() -> void:
subroutine check_dynamic_bytes:
    check_dynamic_bytes_block@0:
        // arc4_conversions/contract.py:239
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        int 0                                                                         value#0,value#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,aggregate%array_length%0#0
        int 2                                                                         value#0,aggregate%array_length%0#0,2
        +                                                                             value#0,add%0#0
        l-load-copy value#0 1                                                         value#0,add%0#0,value#0 (copy)
        len                                                                           value#0,add%0#0,len%0#0
        l-load len%0#0 0                                                              value#0,add%0#0,len%0#0
        l-load add%0#0 1                                                              value#0,len%0#0,add%0#0
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                           value#0,tmp%1#0,aggregate%array_length%1#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%1#0,2
        +                                                                             value#0,tmp%1#0,add%1#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%1#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%1#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%1#0,len%1#0
        l-load add%1#0 1                                                              value#0,tmp%1#0,len%1#0,add%1#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:241
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:239
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_string[routing]() -> void:
subroutine check_string:
    check_string_block@0:
        // arc4_conversions/contract.py:243
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        int 0                                                                         value#0,value#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,aggregate%array_length%0#0
        int 2                                                                         value#0,aggregate%array_length%0#0,2
        +                                                                             value#0,add%0#0
        l-load-copy value#0 1                                                         value#0,add%0#0,value#0 (copy)
        len                                                                           value#0,add%0#0,len%0#0
        l-load len%0#0 0                                                              value#0,add%0#0,len%0#0
        l-load add%0#0 1                                                              value#0,len%0#0,add%0#0
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                           value#0,tmp%1#0,aggregate%array_length%1#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%1#0,2
        +                                                                             value#0,tmp%1#0,add%1#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%1#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%1#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%1#0,len%1#0
        l-load add%1#0 1                                                              value#0,tmp%1#0,len%1#0,add%1#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:245
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:243
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_biguint[routing]() -> void:
subroutine check_biguint:
    check_biguint_block@0:
        // arc4_conversions/contract.py:247
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        int 64                                                                        value#0,len%0#0,64
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.uint512                            value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,tmp%1#0,aggregate%array_length%0#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%0#0,2
        +                                                                             value#0,tmp%1#0,add%0#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%0#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%0#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%0#0,len%1#0
        l-load add%0#0 1                                                              value#0,tmp%1#0,len%1#0,add%0#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:249
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:247
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_bool[routing]() -> void:
subroutine check_bool:
    check_bool_block@0:
        // arc4_conversions/contract.py:251
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        int 1                                                                         value#0,len%0#0,1
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.bool                               value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,tmp%1#0,aggregate%array_length%0#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%0#0,2
        +                                                                             value#0,tmp%1#0,add%0#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%0#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%0#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%0#0,len%1#0
        l-load add%0#0 1                                                              value#0,tmp%1#0,len%1#0,add%0#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:253
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:251
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_dyn_array_uin64[routing]() -> void:
subroutine check_dyn_array_uin64:
    check_dyn_array_uin64_block@0:
        // arc4_conversions/contract.py:255
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        int 0                                                                         value#0,value#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,aggregate%array_length%0#0
        int 8                                                                         value#0,aggregate%array_length%0#0,8
        *                                                                             value#0,mul%0#0
        l-load mul%0#0 0                                                              value#0,mul%0#0
        int 2                                                                         value#0,mul%0#0,2
        +                                                                             value#0,add%0#0
        l-load-copy value#0 1                                                         value#0,add%0#0,value#0 (copy)
        len                                                                           value#0,add%0#0,len%0#0
        l-load len%0#0 0                                                              value#0,add%0#0,len%0#0
        l-load add%0#0 1                                                              value#0,len%0#0,add%0#0
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint64>         value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                           value#0,tmp%1#0,aggregate%array_length%1#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%1#0,2
        +                                                                             value#0,tmp%1#0,add%1#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%1#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%1#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%1#0,len%1#0
        l-load add%1#0 1                                                              value#0,tmp%1#0,len%1#0,add%1#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:259
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:255
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_static_array_uin64_3[routing]() -> void:
subroutine check_static_array_uin64_3:
    check_static_array_uin64_3_block@0:
        // arc4_conversions/contract.py:261
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        int 24                                                                        value#0,len%0#0,24
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.static_array<arc4.uint64, 3>       value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,tmp%1#0,aggregate%array_length%0#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%0#0,2
        +                                                                             value#0,tmp%1#0,add%0#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%0#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%0#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%0#0,len%1#0
        l-load add%0#0 1                                                              value#0,tmp%1#0,len%1#0,add%0#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:265
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:261
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_dyn_array_struct[routing]() -> void:
subroutine check_dyn_array_struct:
    check_dyn_array_struct_block@0:
        // arc4_conversions/contract.py:267
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        int 0                                                                         value#0,value#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,aggregate%array_length%0#0
        int 40                                                                        value#0,aggregate%array_length%0#0,40
        *                                                                             value#0,mul%0#0
        l-load mul%0#0 0                                                              value#0,mul%0#0
        int 2                                                                         value#0,mul%0#0,2
        +                                                                             value#0,add%0#0
        l-load-copy value#0 1                                                         value#0,add%0#0,value#0 (copy)
        len                                                                           value#0,add%0#0,len%0#0
        l-load len%0#0 0                                                              value#0,add%0#0,len%0#0
        l-load add%0#0 1                                                              value#0,len%0#0,add%0#0
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.dynamic_array<test_cases.arc4_conversions.contract.MyStructARC4> value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                           value#0,tmp%1#0,aggregate%array_length%1#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%1#0,2
        +                                                                             value#0,tmp%1#0,add%1#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%1#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%1#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%1#0,len%1#0
        l-load add%1#0 1                                                              value#0,tmp%1#0,len%1#0,add%1#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:271
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:267
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_static_array_struct[routing]() -> void:
subroutine check_static_array_struct:
    check_static_array_struct_block@0:
        // arc4_conversions/contract.py:273
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        int 120                                                                       value#0,len%0#0,120
        ==                                                                            value#0,eq%0#0
        l-load eq%0#0 0                                                               value#0,eq%0#0
        assert // invalid number of bytes for arc4.static_array<test_cases.arc4_conversions.contract.MyStructARC4, 3> value#0
        txna ApplicationArgs 2                                                        value#0,tmp%1#0
        l-load-copy tmp%1#0 0                                                         value#0,tmp%1#0,tmp%1#0 (copy)
        int 0                                                                         value#0,tmp%1#0,tmp%1#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%1#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,tmp%1#0,aggregate%array_length%0#0
        int 2                                                                         value#0,tmp%1#0,aggregate%array_length%0#0,2
        +                                                                             value#0,tmp%1#0,add%0#0
        l-load-copy tmp%1#0 1                                                         value#0,tmp%1#0,add%0#0,tmp%1#0 (copy)
        len                                                                           value#0,tmp%1#0,add%0#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%1#0,add%0#0,len%1#0
        l-load add%0#0 1                                                              value#0,tmp%1#0,len%1#0,add%0#0
        ==                                                                            value#0,tmp%1#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,tmp%1#0,eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%1#0
        l-load tmp%1#0 0                                                              value#0,tmp%1#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:277
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:273
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_dyn_array_dyn_struct[routing]() -> void:
subroutine check_dyn_array_dyn_struct:
    check_dyn_array_dyn_struct_block@0:
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        l-store-copy value#0 0                                                        value#0,value#0 (copy)
        v-store value#0                                                               value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        int 0                                                                         value#0,value#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,aggregate%array_length%0#0
        l-store-copy aggregate%array_length%0#0 0                                     value#0,aggregate%array_length%0#0,aggregate%array_length%0#0 (copy)
        v-store aggregate%array_length%0#0                                            value#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           value#0,aggregate%array_length%0#0
        int 2                                                                         value#0,aggregate%array_length%0#0,2
        *                                                                             value#0,num_bytes%0#0
        v-store num_bytes%0#0                                                         value#0
        l-load-copy value#0 0                                                         value#0,value#0 (copy)
        len                                                                           value#0,total_length%0#0
        v-store total_length%0#0                                                      value#0
        l-load value#0 0                                                              value#0
        extract 2 0                                                                   array_data%0#0
        v-store array_data%0#0
        int 0                                                                         0
        v-store index%0#0
        b check_dyn_array_dyn_struct_for_header@1

    check_dyn_array_dyn_struct_for_header@1:
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        v-load index%0#0                                                              index%0#0
        v-load aggregate%array_length%0#0                                             index%0#0,aggregate%array_length%0#0
        <                                                                             continue_looping%0#0
        l-load continue_looping%0#0 0                                                 continue_looping%0#0
        bz check_dyn_array_dyn_struct_after_for@4 ; b check_dyn_array_dyn_struct_for_body@2 

    check_dyn_array_dyn_struct_for_body@2:
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        v-load index%0#0                                                              index%0#0
        l-store-copy index%0#0 0                                                      index%0#0,index%0#0 (copy)
        int 2                                                                         index%0#0,index%0#0 (copy),2
        *                                                                             index%0#0,head_offset_bytes%0#0
        v-load array_data%0#0                                                         index%0#0,head_offset_bytes%0#0,array_data%0#0
        l-store-copy array_data%0#0 2                                                 array_data%0#0,index%0#0,head_offset_bytes%0#0,array_data%0#0 (copy)
        l-load head_offset_bytes%0#0 1                                                array_data%0#0,index%0#0,array_data%0#0 (copy),head_offset_bytes%0#0
        extract_uint16 // on error: invalid array encoding                            array_data%0#0,index%0#0,item_offset%0#0
        l-load-copy item_offset%0#0 0                                                 array_data%0#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy)
        v-load num_bytes%0#0                                                          array_data%0#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy),num_bytes%0#0
        l-store-copy num_bytes%0#0 4                                                  num_bytes%0#0,array_data%0#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy),num_bytes%0#0 (copy)
        ==                                                                            num_bytes%0#0,array_data%0#0,index%0#0,item_offset%0#0,offset_is_correct%0#0
        l-load offset_is_correct%0#0 0                                                num_bytes%0#0,array_data%0#0,index%0#0,item_offset%0#0,offset_is_correct%0#0
        assert // invalid tail pointer for (len+(uint64,uint8[32],(len+uint8[]))[])   num_bytes%0#0,array_data%0#0,index%0#0,item_offset%0#0
        l-load index%0#0 1                                                            num_bytes%0#0,array_data%0#0,item_offset%0#0,index%0#0
        int 1                                                                         num_bytes%0#0,array_data%0#0,item_offset%0#0,index%0#0,1
        +                                                                             num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0
        v-load aggregate%array_length%0#0                                             num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%array_length%0#0
        l-load-copy aggregate%next_index%0#0 1                                        num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%array_length%0#0,aggregate%next_index%0#0 (copy)
        - // on error: index access is out of bounds                                  num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0
        l-load-copy array_data%0#0 3                                                  num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,array_data%0#0 (copy)
        len                                                                           num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0
        l-load-copy aggregate%next_index%0#0 2                                        num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_index%0#0 (copy)
        int 2                                                                         num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_index%0#0 (copy),2
        *                                                                             num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset_offset%0#0
        l-load-copy array_data%0#0 5                                                  num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset_offset%0#0,array_data%0#0 (copy)
        l-load aggregate%next_item_offset_offset%0#0 1                                num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,array_data%0#0 (copy),aggregate%next_item_offset_offset%0#0
        extract_uint16                                                                num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0
        l-load aggregate%end_of_array%0#0 1                                           num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%next_item_offset%0#0,aggregate%end_of_array%0#0
        l-load aggregate%next_item_offset%0#0 1                                       num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0
        l-load aggregate%has_next%0#0 2                                               num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0,aggregate%has_next%0#0
        select                                                                        num_bytes%0#0,array_data%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0
        l-load array_data%0#0 3                                                       num_bytes%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0,array_data%0#0
        l-load item_offset%0#0 3                                                      num_bytes%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0,array_data%0#0,item_offset%0#0
        l-load aggregate%end_offset%0#0 2                                             num_bytes%0#0,aggregate%next_index%0#0,array_data%0#0,item_offset%0#0,aggregate%end_offset%0#0
        substring3                                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0
        l-load-copy aggregate%substring3%0#0 0                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,aggregate%substring3%0#0 (copy)
        int 40                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,aggregate%substring3%0#0 (copy),40
        extract_uint16 // on error: invalid tuple encoding                            num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load-copy extract_uint16%0#0 0                                              num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,extract_uint16%0#0 (copy)
        int 42                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,extract_uint16%0#0 (copy),42
        ==                                                                            num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,eq%0#0
        l-load eq%0#0 0                                                               num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,eq%0#0
        assert // invalid tail pointer at index 2 of (uint64,uint8[32],(len+uint8[])) num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load-copy aggregate%substring3%0#0 1                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%substring3%0#0 (copy)
        len                                                                           num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%len%0#0
        l-load aggregate%substring3%0#0 2                                             num_bytes%0#0,aggregate%next_index%0#0,extract_uint16%0#0,aggregate%len%0#0,aggregate%substring3%0#0
        l-load extract_uint16%0#0 2                                                   num_bytes%0#0,aggregate%next_index%0#0,aggregate%len%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load aggregate%len%0#0 2                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%len%0#0
        substring3                                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0
        l-load aggregate%substring3%2#0 0                                             num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0
        int 0                                                                         num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0,0
        extract_uint16 // on error: invalid array length header                       num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%3#0
        l-load aggregate%array_length%3#0 0                                           num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%3#0
        int 44                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%3#0,44
        +                                                                             num_bytes%0#0,aggregate%next_index%0#0,add%1#0
        l-load num_bytes%0#0 2                                                        aggregate%next_index%0#0,add%1#0,num_bytes%0#0
        l-load add%1#0 1                                                              aggregate%next_index%0#0,num_bytes%0#0,add%1#0
        +                                                                             aggregate%next_index%0#0,num_bytes%0#0
        v-store num_bytes%0#0                                                         aggregate%next_index%0#0
        l-load aggregate%next_index%0#0 0                                             aggregate%next_index%0#0
        v-store index%0#0
        b check_dyn_array_dyn_struct_for_header@1

    check_dyn_array_dyn_struct_after_for@4:
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        v-load num_bytes%0#0                                                          num_bytes%0#0
        int 2                                                                         num_bytes%0#0,2
        +                                                                             num_bytes%1#0
        v-load total_length%0#0                                                       num_bytes%1#0,total_length%0#0
        l-load num_bytes%1#0 1                                                        total_length%0#0,num_bytes%1#0
        ==                                                                            eq%1#0
        l-load eq%1#0 0                                                               eq%1#0
        assert // invalid number of bytes for arc4.dynamic_array<test_cases.arc4_conversions.contract.MyDynStructARC4> 
        txna ApplicationArgs 2                                                        tmp%3#0
        l-load-copy tmp%3#0 0                                                         tmp%3#0,tmp%3#0 (copy)
        int 0                                                                         tmp%3#0,tmp%3#0 (copy),0
        extract_uint16 // on error: invalid array length header                       tmp%3#0,aggregate%array_length%4#0
        l-load aggregate%array_length%4#0 0                                           tmp%3#0,aggregate%array_length%4#0
        int 2                                                                         tmp%3#0,aggregate%array_length%4#0,2
        +                                                                             tmp%3#0,add%2#0
        l-load-copy tmp%3#0 1                                                         tmp%3#0,add%2#0,tmp%3#0 (copy)
        len                                                                           tmp%3#0,add%2#0,len%1#0
        l-load len%1#0 0                                                              tmp%3#0,add%2#0,len%1#0
        l-load add%2#0 1                                                              tmp%3#0,len%1#0,add%2#0
        ==                                                                            tmp%3#0,eq%2#0
        l-load eq%2#0 0                                                               tmp%3#0,eq%2#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          tmp%3#0
        l-load tmp%3#0 0                                                              tmp%3#0
        extract 2 0                                                                   expected#0
        // arc4_conversions/contract.py:283
        // assert value.bytes == expected, "expected to encode correctly"
        v-load value#0                                                                expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:279
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_static_array_dyn_struct[routing]() -> void:
subroutine check_static_array_dyn_struct:
    check_static_array_dyn_struct_block@0:
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        value#0
        v-store value#0
        int 6                                                                         6
        v-store num_bytes%0#0
        int 0                                                                         0
        v-store index%0#0
        b check_static_array_dyn_struct_for_header@1

    check_static_array_dyn_struct_for_header@1:
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        v-load index%0#0                                                              index%0#0
        int 3                                                                         index%0#0,3
        <                                                                             continue_looping%0#0
        l-load continue_looping%0#0 0                                                 continue_looping%0#0
        bz check_static_array_dyn_struct_after_for@4 ; b check_static_array_dyn_struct_for_body@2 

    check_static_array_dyn_struct_for_body@2:
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        v-load index%0#0                                                              index%0#0
        l-store-copy index%0#0 0                                                      index%0#0,index%0#0 (copy)
        int 2                                                                         index%0#0,index%0#0 (copy),2
        *                                                                             index%0#0,head_offset_bytes%0#0
        v-load value#0                                                                index%0#0,head_offset_bytes%0#0,value#0
        l-store-copy value#0 2                                                        value#0,index%0#0,head_offset_bytes%0#0,value#0 (copy)
        l-load head_offset_bytes%0#0 1                                                value#0,index%0#0,value#0 (copy),head_offset_bytes%0#0
        extract_uint16 // on error: invalid array encoding                            value#0,index%0#0,item_offset%0#0
        l-load-copy item_offset%0#0 0                                                 value#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy)
        v-load num_bytes%0#0                                                          value#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy),num_bytes%0#0
        l-store-copy num_bytes%0#0 4                                                  num_bytes%0#0,value#0,index%0#0,item_offset%0#0,item_offset%0#0 (copy),num_bytes%0#0 (copy)
        ==                                                                            num_bytes%0#0,value#0,index%0#0,item_offset%0#0,offset_is_correct%0#0
        l-load offset_is_correct%0#0 0                                                num_bytes%0#0,value#0,index%0#0,item_offset%0#0,offset_is_correct%0#0
        assert // invalid tail pointer for (uint64,uint8[32],(len+uint8[]))[3]        num_bytes%0#0,value#0,index%0#0,item_offset%0#0
        l-load index%0#0 1                                                            num_bytes%0#0,value#0,item_offset%0#0,index%0#0
        int 1                                                                         num_bytes%0#0,value#0,item_offset%0#0,index%0#0,1
        +                                                                             num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0
        int 3                                                                         num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,3
        l-load-copy aggregate%next_index%0#0 1                                        num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,3,aggregate%next_index%0#0 (copy)
        - // on error: index access is out of bounds                                  num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0
        l-load-copy value#0 3                                                         num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,value#0 (copy)
        len                                                                           num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0
        l-load-copy aggregate%next_index%0#0 2                                        num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_index%0#0 (copy)
        int 2                                                                         num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_index%0#0 (copy),2
        *                                                                             num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset_offset%0#0
        l-load-copy value#0 5                                                         num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset_offset%0#0,value#0 (copy)
        l-load aggregate%next_item_offset_offset%0#0 1                                num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,value#0 (copy),aggregate%next_item_offset_offset%0#0
        extract_uint16                                                                num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0
        l-load aggregate%end_of_array%0#0 1                                           num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%next_item_offset%0#0,aggregate%end_of_array%0#0
        l-load aggregate%next_item_offset%0#0 1                                       num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%has_next%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0
        l-load aggregate%has_next%0#0 2                                               num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_of_array%0#0,aggregate%next_item_offset%0#0,aggregate%has_next%0#0
        select                                                                        num_bytes%0#0,value#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0
        l-load value#0 3                                                              num_bytes%0#0,item_offset%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0,value#0
        l-load item_offset%0#0 3                                                      num_bytes%0#0,aggregate%next_index%0#0,aggregate%end_offset%0#0,value#0,item_offset%0#0
        l-load aggregate%end_offset%0#0 2                                             num_bytes%0#0,aggregate%next_index%0#0,value#0,item_offset%0#0,aggregate%end_offset%0#0
        substring3                                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0
        l-load-copy aggregate%substring3%0#0 0                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,aggregate%substring3%0#0 (copy)
        int 40                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,aggregate%substring3%0#0 (copy),40
        extract_uint16 // on error: invalid tuple encoding                            num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load-copy extract_uint16%0#0 0                                              num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,extract_uint16%0#0 (copy)
        int 42                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,extract_uint16%0#0 (copy),42
        ==                                                                            num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,eq%0#0
        l-load eq%0#0 0                                                               num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,eq%0#0
        assert // invalid tail pointer at index 2 of (uint64,uint8[32],(len+uint8[])) num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load-copy aggregate%substring3%0#0 1                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%substring3%0#0 (copy)
        len                                                                           num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%len%0#0
        l-load aggregate%substring3%0#0 2                                             num_bytes%0#0,aggregate%next_index%0#0,extract_uint16%0#0,aggregate%len%0#0,aggregate%substring3%0#0
        l-load extract_uint16%0#0 2                                                   num_bytes%0#0,aggregate%next_index%0#0,aggregate%len%0#0,aggregate%substring3%0#0,extract_uint16%0#0
        l-load aggregate%len%0#0 2                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%0#0,extract_uint16%0#0,aggregate%len%0#0
        substring3                                                                    num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0
        l-load aggregate%substring3%2#0 0                                             num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0
        int 0                                                                         num_bytes%0#0,aggregate%next_index%0#0,aggregate%substring3%2#0,0
        extract_uint16 // on error: invalid array length header                       num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%0#0
        l-load aggregate%array_length%0#0 0                                           num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%0#0
        int 44                                                                        num_bytes%0#0,aggregate%next_index%0#0,aggregate%array_length%0#0,44
        +                                                                             num_bytes%0#0,aggregate%next_index%0#0,add%1#0
        l-load num_bytes%0#0 2                                                        aggregate%next_index%0#0,add%1#0,num_bytes%0#0
        l-load add%1#0 1                                                              aggregate%next_index%0#0,num_bytes%0#0,add%1#0
        +                                                                             aggregate%next_index%0#0,num_bytes%0#0
        v-store num_bytes%0#0                                                         aggregate%next_index%0#0
        l-load aggregate%next_index%0#0 0                                             aggregate%next_index%0#0
        v-store index%0#0
        b check_static_array_dyn_struct_for_header@1

    check_static_array_dyn_struct_after_for@4:
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        v-load value#0                                                                value#0
        l-store-copy value#0 0                                                        value#0,value#0 (copy)
        len                                                                           value#0,len%0#0
        l-load len%0#0 0                                                              value#0,len%0#0
        v-load num_bytes%0#0                                                          value#0,len%0#0,num_bytes%0#0
        ==                                                                            value#0,eq%1#0
        l-load eq%1#0 0                                                               value#0,eq%1#0
        assert // invalid number of bytes for arc4.static_array<test_cases.arc4_conversions.contract.MyDynStructARC4, 3> value#0
        txna ApplicationArgs 2                                                        value#0,tmp%3#0
        l-load-copy tmp%3#0 0                                                         value#0,tmp%3#0,tmp%3#0 (copy)
        int 0                                                                         value#0,tmp%3#0,tmp%3#0 (copy),0
        extract_uint16 // on error: invalid array length header                       value#0,tmp%3#0,aggregate%array_length%1#0
        l-load aggregate%array_length%1#0 0                                           value#0,tmp%3#0,aggregate%array_length%1#0
        int 2                                                                         value#0,tmp%3#0,aggregate%array_length%1#0,2
        +                                                                             value#0,tmp%3#0,add%2#0
        l-load-copy tmp%3#0 1                                                         value#0,tmp%3#0,add%2#0,tmp%3#0 (copy)
        len                                                                           value#0,tmp%3#0,add%2#0,len%1#0
        l-load len%1#0 0                                                              value#0,tmp%3#0,add%2#0,len%1#0
        l-load add%2#0 1                                                              value#0,tmp%3#0,len%1#0,add%2#0
        ==                                                                            value#0,tmp%3#0,eq%2#0
        l-load eq%2#0 0                                                               value#0,tmp%3#0,eq%2#0
        assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>          value#0,tmp%3#0
        l-load tmp%3#0 0                                                              value#0,tmp%3#0
        extract 2 0                                                                   value#0,expected#0
        // arc4_conversions/contract.py:289
        // assert value.bytes == expected, "expected to encode correctly"
        l-load value#0 1                                                              expected#0,value#0
        l-load expected#0 1                                                           value#0,expected#0
        ==                                                                            tmp%0#1
        l-load tmp%0#1 0                                                              tmp%0#1
        assert // expected to encode correctly
        // arc4_conversions/contract.py:285
        // @arc4.abimethod
        int 1                                                                         1
        return


// test_cases.arc4_conversions.contract.CheckApp.check_static_bytes[routing]() -> void:
subroutine check_static_bytes:
    check_static_bytes_block@0:
        // arc4_conversions/contract.py:291
        // @arc4.abimethod
        txna ApplicationArgs 1                                                        bytes32#0
        l-load-copy bytes32#0 0                                                       bytes32#0,bytes32#0 (copy)
        len                                                                           bytes32#0,len%0#0
        l-load len%0#0 0                                                              bytes32#0,len%0#0
        int 32                                                                        bytes32#0,len%0#0,32
        ==                                                                            bytes32#0,eq%0#0
        l-load eq%0#0 0                                                               bytes32#0,eq%0#0
        assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>       bytes32#0
        // arc4_conversions/contract.py:293
        // assert bytes32.bytes == Txn.sender.bytes, "expected to encode correctly"
        txn Sender                                                                    bytes32#0,tmp%0#1
        l-load bytes32#0 1                                                            tmp%0#1,bytes32#0
        l-load tmp%0#1 1                                                              bytes32#0,tmp%0#1
        ==                                                                            tmp%1#0
        l-load tmp%1#0 0                                                              tmp%1#0
        assert // expected to encode correctly
        // arc4_conversions/contract.py:291
        // @arc4.abimethod
        int 1                                                                         1
        return


