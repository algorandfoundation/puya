#pragma version 8

// test_cases.nested_loops.contract.Nested.approval_program() -> uint64:
main:
        byte ""
        dupn 14

main_block@0:
        int 2
        dup
        swap
        int 0
        dup
        cover 2
        cover 2
        int 1
        assert // Step cannot be zero
        int 0
        >
        bz main_after_for@36

main_for_preamble@1:
        int 0
        bury 12

main_for_header@2:
        dig 11
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@36

main_for_body@3:
        dig 11
        bury 18
        int 1
        assert // Step cannot be zero
        int 0
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@33

main_for_preamble@4:
        int 0
        bury 7

main_for_header@5:
        dig 6
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@33

main_for_body@6:
        dig 6
        bury 17
        int 1
        assert // Step cannot be zero
        int 0
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@30

main_for_preamble@7:
        int 0
        bury 6

main_for_header@8:
        dig 5
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@30

main_for_body@9:
        dig 5
        bury 16
        int 1
        assert // Step cannot be zero
        int 0
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@27

main_for_preamble@10:
        int 0
        bury 11

main_for_header@11:
        dig 10
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@27

main_for_body@12:
        dig 10
        bury 15
        int 1
        assert // Step cannot be zero
        int 0
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@24

main_for_preamble@13:
        int 0
        bury 10

main_for_header@14:
        dig 9
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@24

main_for_body@15:
        dig 9
        bury 14
        int 1
        assert // Step cannot be zero
        int 0
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@21

main_for_preamble@16:
        int 0
        bury 9

main_for_header@17:
        dig 8
        dig 3
        <
        dig 2
        bury 2
        bz main_after_for@21

main_for_body@18:
        dig 8
        dig 18
        dig 18
        +
        dig 17
        +
        dig 16
        +
        dig 15
        +
        +
        dig 2
        +
        bury 2

main_for_footer@19:

main_for_increment@20:
        dig 8
        int 1
        +
        bury 9
        b main_for_header@17

main_after_for@21:
        dup
        bury 2

main_for_footer@22:

main_for_increment@23:
        dig 9
        int 1
        +
        bury 10
        b main_for_header@14

main_after_for@24:
        dup
        bury 2

main_for_footer@25:

main_for_increment@26:
        dig 10
        int 1
        +
        bury 11
        b main_for_header@11

main_after_for@27:
        dup
        bury 2

main_for_footer@28:

main_for_increment@29:
        dig 5
        int 1
        +
        bury 6
        b main_for_header@8

main_after_for@30:
        dup
        bury 2

main_for_footer@31:

main_for_increment@32:
        dig 6
        int 1
        +
        bury 7
        b main_for_header@5

main_after_for@33:
        dup
        bury 2
        dig 17
        dig 3
        +
        pop

main_for_footer@34:

main_for_increment@35:
        dig 11
        int 1
        +
        bury 12
        b main_for_header@2

main_after_for@36:
        dup
        dup
        bury 3
        itob
        log
        int 0
        dup
        bury 6
        int 1
        assert // Step cannot be zero
        int 0
        int 10
        <
        swap
        bury 5
        bz main_after_for@42

main_for_preamble@37:
        int 0
        bury 8
        int 0
        bury 13

main_for_header@38:
        dig 7
        int 10
        <
        dig 5
        bury 5
        bz main_after_for@42

main_for_body@39:
        dig 7
        dig 13
        *
        dig 5
        +
        bury 5

main_for_footer@40:

main_for_increment@41:
        dig 7
        int 1
        +
        bury 8
        dig 12
        int 1
        +
        bury 13
        b main_for_header@38

main_after_for@42:
        dig 3
        itob
        log
        dig 1
        return

