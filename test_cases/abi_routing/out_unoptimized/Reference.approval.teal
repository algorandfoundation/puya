#pragma version 10
#pragma typetrack false

// test_cases.abi_routing.contract.Reference.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 8 2
    bytecblock 0x151f7c75 "asa" 0x 0x07 0x01040023 "local_uint" "local_bytes" 0x00000000000001c8

main_block@0:
    txn ApplicationID
    bnz main_after_if_else@2

main_call___init__@1:
    callsub __init__

main_after_if_else@2:
    callsub approval_program
    return


// test_cases.abi_routing.contract.Reference.__init__() -> void:
__init__:

__init___block@0:
    // abi_routing/contract.py:26
    // self.asa = Asset(123)
    bytec_1 // "asa"
    pushint 123 // 123
    app_global_put
    // abi_routing/contract.py:27
    // self.an_int = UInt64(2)
    pushbytes "an_int"
    intc_3 // 2
    app_global_put
    // abi_routing/contract.py:28
    // self.some_bytes = Bytes3(arc4.Byte(7), arc4.Byte(8), arc4.Byte(9))
    bytec_2 // 0x
    bytec_3 // 0x07
    concat
    pushbytes 0x08
    concat
    pushbytes 0x09
    concat
    bytec_2 // 0x
    swap
    concat
    pushbytes "some_bytes"
    swap
    app_global_put
    // abi_routing/contract.py:29
    // self.creator = op.Txn.sender
    txn Sender
    pushbytes "creator"
    swap
    app_global_put
    // abi_routing/contract.py:30
    // self.app = Application(123)
    pushbytes "app"
    pushint 123 // 123
    app_global_put
    // abi_routing/contract.py:34
    // assert arc4.arc4_signature("get(uint64,byte[])byte[]"), "has method selector"
    pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
    len
    intc_1 // 0
    !=
    assert // has method selector
    // abi_routing/contract.py:36
    // assert arc4.arc4_signature(Reference.opt_in) == arc4.arc4_signature(
    bytec 4 // method "opt_in(uint64,byte[])void"
    // abi_routing/contract.py:36-38
    // assert arc4.arc4_signature(Reference.opt_in) == arc4.arc4_signature(
    //     "opt_in(uint64,byte[])void"
    // ), "has method selector for method reference"
    dup
    ==
    assert // has method selector for method reference
    retsub


// test_cases.abi_routing.contract.Reference.noop_with_uint64(a: bytes) -> bytes:
noop_with_uint64:
    // abi_routing/contract.py:40-41
    // @arc4.abimethod
    // def noop_with_uint64(self, a: arc4.UInt64) -> arc4.UInt8:
    proto 1 1

noop_with_uint64_block@0:
    // abi_routing/contract.py:42
    // result = 1 + a.native
    frame_dig -1
    btoi
    intc_0 // 1
    +
    // abi_routing/contract.py:43
    // return arc4.UInt8(result)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    pushint 7 // 7
    intc_0 // 1
    extract3
    retsub


// test_cases.abi_routing.contract.Reference.opt_in(uint: uint64, bites: bytes) -> void:
opt_in:
    // abi_routing/contract.py:45-46
    // @arc4.abimethod(allow_actions=[OnCompleteAction.OptIn])
    // def opt_in(self, uint: UInt64, bites: Bytes) -> None:
    proto 2 0

opt_in_block@0:
    // abi_routing/contract.py:47
    // self.local_uint[Txn.sender] = uint
    txn Sender
    bytec 5 // "local_uint"
    frame_dig -2
    app_local_put
    // abi_routing/contract.py:48
    // self.local_bytes[Txn.sender] = bites
    txn Sender
    bytec 6 // "local_bytes"
    frame_dig -1
    app_local_put
    retsub


// test_cases.abi_routing.contract.Reference.full_abi_config(a: bytes) -> bytes:
full_abi_config:
    // abi_routing/contract.py:50-62
    // @arc4.abimethod(
    //     allow_actions=[
    //         "NoOp",
    //         OnCompleteAction.OptIn,
    //         "CloseOut",
    //         OnCompleteAction.UpdateApplication,
    //         OnCompleteAction.DeleteApplication,
    //     ],
    //     name="all_the_things",
    //     create="allow",
    //     readonly=True,
    // )
    // def full_abi_config(self, a: arc4.UInt64) -> arc4.UInt8:
    proto 1 1

full_abi_config_block@0:
    // abi_routing/contract.py:63
    // result = UInt64(1) + a.native
    frame_dig -1
    btoi
    intc_0 // 1
    +
    // abi_routing/contract.py:64
    // return arc4.UInt8(result)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    pushint 7 // 7
    intc_0 // 1
    extract3
    retsub


// test_cases.abi_routing.contract.Reference.mixed_oca(a: bytes) -> bytes:
mixed_oca:
    // abi_routing/contract.py:66-75
    // @arc4.abimethod(
    //     allow_actions=[
    //         "NoOp",
    //         "CloseOut",
    //         "DeleteApplication",
    //     ],
    //     create="disallow",
    //     readonly=True,
    // )
    // def mixed_oca(self, a: arc4.UInt64) -> arc4.UInt8:
    proto 1 1

mixed_oca_block@0:
    // abi_routing/contract.py:76
    // result = UInt64(1) + a.native
    frame_dig -1
    btoi
    intc_0 // 1
    +
    // abi_routing/contract.py:77
    // return arc4.UInt8(result)
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    pushint 7 // 7
    intc_0 // 1
    extract3
    retsub


// test_cases.abi_routing.contract.Reference.bare_abi_config() -> void:
bare_abi_config:

bare_abi_config_block@0:
    // abi_routing/contract.py:90
    // log("Hello World")
    pushbytes "Hello World"
    log
    retsub


// test_cases.abi_routing.contract.Reference.opt_into_asset(asset: uint64) -> void:
opt_into_asset:
    // abi_routing/contract.py:92-93
    // @arc4.abimethod
    // def opt_into_asset(self, asset: Asset) -> None:
    proto 1 0

opt_into_asset_block@0:
    // abi_routing/contract.py:94-95
    // # Only allow app creator to opt the app account into a ASA
    // assert op.Txn.sender == op.Global.creator_address, "Only creator can opt in to ASA"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can opt in to ASA
    // abi_routing/contract.py:96-97
    // # Verify a ASA hasn't already been opted into
    // assert not self.asa, "ASA already opted in"
    intc_1 // 0
    bytec_1 // "asa"
    app_global_get_ex
    assert // check self.asa exists
    !
    assert // ASA already opted in
    // abi_routing/contract.py:98-99
    // # Save ASA ID in global state
    // self.asa = asset
    bytec_1 // "asa"
    frame_dig -1
    app_global_put
    // abi_routing/contract.py:101-102
    // # Submit opt-in transaction: 0 asset transfer to self
    // op.ITxnCreate.begin()
    itxn_begin
    // abi_routing/contract.py:103
    // op.ITxnCreate.set_type_enum(TransactionType.AssetTransfer)
    pushint 4 // axfer
    itxn_field TypeEnum
    // abi_routing/contract.py:104
    // op.ITxnCreate.set_fee(UInt64(0))  # cover fee with outer txn
    intc_1 // 0
    itxn_field Fee
    // abi_routing/contract.py:105
    // op.ITxnCreate.set_asset_receiver(op.Global.current_application_address)
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // abi_routing/contract.py:106
    // op.ITxnCreate.set_xfer_asset(asset)
    frame_dig -1
    itxn_field XferAsset
    // abi_routing/contract.py:107
    // op.ITxnCreate.submit()
    itxn_submit
    retsub


// test_cases.abi_routing.contract.Reference.with_transactions(asset: uint64, an_int: bytes, pay: uint64, another_int: bytes) -> void:
with_transactions:
    // abi_routing/contract.py:109-116
    // @arc4.abimethod
    // def with_transactions(
    //     self,
    //     asset: Asset,
    //     an_int: arc4.UInt64,
    //     pay: gtxn.PaymentTransaction,
    //     another_int: arc4.UInt64,
    // ) -> None:
    proto 4 0

with_transactions_block@0:
    // abi_routing/contract.py:117
    // assert self.asa == asset, "is correct asset"
    intc_1 // 0
    bytec_1 // "asa"
    app_global_get_ex
    assert // check self.asa exists
    frame_dig -4
    ==
    assert // is correct asset
    // abi_routing/contract.py:118
    // assert an_int.native == 1, "is correct int"
    frame_dig -3
    btoi
    intc_0 // 1
    ==
    assert // is correct int
    // abi_routing/contract.py:119
    // assert pay.receiver == op.Global.current_application_address, "is payment to app"
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // is payment to app
    // abi_routing/contract.py:120
    // assert another_int.native == 2, "is correct int"
    frame_dig -1
    btoi
    intc_3 // 2
    ==
    assert // is correct int
    retsub


// test_cases.abi_routing.contract.Reference.compare_assets(asset_a: uint64, asset_b: uint64) -> void:
compare_assets:
    // abi_routing/contract.py:122-123
    // @arc4.abimethod
    // def compare_assets(self, asset_a: Asset, asset_b: Asset) -> None:
    proto 2 0

compare_assets_block@0:
    // abi_routing/contract.py:124
    // assert asset_a == asset_b, "asset a == b"
    frame_dig -2
    frame_dig -1
    ==
    assert // asset a == b
    retsub


// test_cases.abi_routing.contract.Reference.get_address() -> bytes:
get_address:

get_address_block@0:
    // abi_routing/contract.py:128
    // return arc4.Address()
    global ZeroAddress
    retsub


// test_cases.abi_routing.contract.Reference.get_asset() -> bytes:
get_asset:

get_asset_block@0:
    // abi_routing/contract.py:132
    // return arc4.UInt64(456)
    bytec 7 // 0x00000000000001c8
    retsub


// test_cases.abi_routing.contract.Reference.get_app() -> bytes:
get_app:

get_app_block@0:
    // abi_routing/contract.py:136
    // return arc4.UInt64(456)
    bytec 7 // 0x00000000000001c8
    retsub


// test_cases.abi_routing.contract.Reference.get_a_int() -> bytes:
get_a_int:

get_a_int_block@0:
    // abi_routing/contract.py:140
    // return arc4.UInt64(3)
    pushbytes 0x0000000000000003
    retsub


// test_cases.abi_routing.contract.Reference.method_with_default_args(asset_from_storage: uint64, asset_from_function: uint64, account_from_storage: bytes, account_from_function: bytes, application_from_storage: uint64, application_from_function: uint64, bytes_from_storage: bytes, int_from_storage: bytes, int_from_function: bytes, int_from_const: bytes, str_from_const: bytes, int_from_local: uint64, bytes_from_local: bytes) -> void:
method_with_default_args:
    // abi_routing/contract.py:142-174
    // @arc4.abimethod(
    //     default_args={
    //         "asset_from_storage": "asa",
    //         "asset_from_function": get_asset,
    //         "account_from_storage": "creator",
    //         "account_from_function": "get_address",
    //         "application_from_storage": "app",
    //         "application_from_function": get_app,
    //         "bytes_from_storage": "some_bytes",
    //         "int_from_storage": "an_int",
    //         "int_from_function": "get_a_int",
    //         "int_from_const": arc4.UInt32(123),
    //         "str_from_const": arc4.String("abc"),
    //         "int_from_local": "local_uint",
    //         "bytes_from_local": "local_bytes",
    //     }
    // )
    // def method_with_default_args(
    //     self,
    //     asset_from_storage: Asset,
    //     asset_from_function: Asset,
    //     account_from_storage: Account,
    //     account_from_function: Account,
    //     application_from_storage: Application,
    //     application_from_function: Application,
    //     bytes_from_storage: Bytes3,
    //     int_from_storage: arc4.UInt64,
    //     int_from_function: arc4.UInt64,
    //     int_from_const: arc4.UInt32,
    //     str_from_const: arc4.String,
    //     int_from_local: UInt64,
    //     bytes_from_local: Bytes,
    // ) -> None:
    proto 13 0

method_with_default_args_block@0:
    // abi_routing/contract.py:175
    // assert asset_from_storage == Asset(123), "wrong asset from storage"
    frame_dig -13
    pushint 123 // 123
    ==
    assert // wrong asset from storage
    // abi_routing/contract.py:176
    // assert asset_from_function == Asset(456), "wrong asset from function"
    frame_dig -12
    pushint 456 // 456
    ==
    assert // wrong asset from function
    // abi_routing/contract.py:177
    // assert account_from_storage == op.Global.creator_address, "wrong account from storage"
    global CreatorAddress
    frame_dig -11
    ==
    assert // wrong account from storage
    // abi_routing/contract.py:178
    // assert account_from_function == op.Global.zero_address, "wrong account from function"
    global ZeroAddress
    frame_dig -10
    ==
    assert // wrong account from function
    // abi_routing/contract.py:179
    // assert application_from_storage == Application(123), "wrong application from storage"
    frame_dig -9
    pushint 123 // 123
    ==
    assert // wrong application from storage
    // abi_routing/contract.py:180
    // assert application_from_function == Application(456), "wrong application from function"
    frame_dig -8
    pushint 456 // 456
    ==
    assert // wrong application from function
    // abi_routing/contract.py:181
    // assert bytes_from_storage[0] == arc4.Byte(7), "wrong 0th byte from storage"
    frame_dig -7
    intc_1 // 0
    intc_0 // 1
    *
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    bytec_3 // 0x07
    b==
    assert // wrong 0th byte from storage
    // abi_routing/contract.py:182
    // assert bytes_from_storage[1] == arc4.Byte(8), "wrong 1st byte from storage"
    frame_dig -7
    intc_0 // 1
    dup
    *
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    pushbytes 0x08
    b==
    assert // wrong 1st byte from storage
    // abi_routing/contract.py:183
    // assert bytes_from_storage[2] == arc4.Byte(9), "wrong 2nd byte from storage"
    frame_dig -7
    intc_3 // 2
    intc_0 // 1
    *
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    pushbytes 0x09
    b==
    assert // wrong 2nd byte from storage
    // abi_routing/contract.py:184
    // assert int_from_storage.native == 2, "wrong int from storage"
    frame_dig -6
    btoi
    intc_3 // 2
    ==
    assert // wrong int from storage
    // abi_routing/contract.py:185
    // assert int_from_function.native == 3, "wrong int from function"
    frame_dig -5
    btoi
    pushint 3 // 3
    ==
    assert // wrong int from function
    // abi_routing/contract.py:186
    // assert int_from_const == 123
    frame_dig -4
    pushbytes 0x0000007b
    b==
    assert
    // abi_routing/contract.py:187
    // assert str_from_const == "abc"
    frame_dig -3
    pushbytes 0x0003616263
    ==
    assert
    // abi_routing/contract.py:188
    // assert int_from_local == self.local_uint[Txn.sender]
    txn Sender
    intc_1 // 0
    bytec 5 // "local_uint"
    app_local_get_ex
    assert // check self.local_uint exists for account
    frame_dig -2
    ==
    assert
    // abi_routing/contract.py:189
    // assert bytes_from_local == self.local_bytes[Txn.sender]
    txn Sender
    intc_1 // 0
    bytec 6 // "local_bytes"
    app_local_get_ex
    assert // check self.local_bytes exists for account
    frame_dig -1
    ==
    assert
    retsub


// test_cases.abi_routing.contract.Reference.method_with_15_args(one: uint64, two: uint64, three: uint64, four: uint64, five: uint64, six: uint64, seven: uint64, eight: uint64, nine: uint64, ten: uint64, eleven: uint64, twelve: uint64, thirteen: uint64, fourteen: uint64, fifteen: bytes) -> bytes:
method_with_15_args:
    // abi_routing/contract.py:191-209
    // @arc4.abimethod
    // def method_with_15_args(
    //     self,
    //     one: UInt64,
    //     two: UInt64,
    //     three: UInt64,
    //     four: UInt64,
    //     five: UInt64,
    //     six: UInt64,
    //     seven: UInt64,
    //     eight: UInt64,
    //     nine: UInt64,
    //     ten: UInt64,
    //     eleven: UInt64,
    //     twelve: UInt64,
    //     thirteen: UInt64,
    //     fourteen: UInt64,
    //     fifteen: Bytes,
    // ) -> Bytes:
    proto 15 1

method_with_15_args_block@0:
    // abi_routing/contract.py:212-213
    // one
    // + two
    frame_dig -15
    frame_dig -14
    +
    // abi_routing/contract.py:212-214
    // one
    // + two
    // + three
    frame_dig -13
    +
    // abi_routing/contract.py:212-215
    // one
    // + two
    // + three
    // + four
    frame_dig -12
    +
    // abi_routing/contract.py:212-216
    // one
    // + two
    // + three
    // + four
    // + five
    frame_dig -11
    +
    // abi_routing/contract.py:212-217
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    frame_dig -10
    +
    // abi_routing/contract.py:212-218
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    frame_dig -9
    +
    // abi_routing/contract.py:212-219
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    frame_dig -8
    +
    // abi_routing/contract.py:212-220
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    frame_dig -7
    +
    // abi_routing/contract.py:212-221
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    // + ten
    frame_dig -6
    +
    // abi_routing/contract.py:212-222
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    // + ten
    // + eleven
    frame_dig -5
    +
    // abi_routing/contract.py:212-223
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    // + ten
    // + eleven
    // + twelve
    frame_dig -4
    +
    // abi_routing/contract.py:212-224
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    // + ten
    // + eleven
    // + twelve
    // + thirteen
    frame_dig -3
    +
    // abi_routing/contract.py:212-225
    // one
    // + two
    // + three
    // + four
    // + five
    // + six
    // + seven
    // + eight
    // + nine
    // + ten
    // + eleven
    // + twelve
    // + thirteen
    // + fourteen
    frame_dig -2
    +
    intc_1 // 0
    !=
    // abi_routing/contract.py:211-226
    // assert (
    //     one
    //     + two
    //     + three
    //     + four
    //     + five
    //     + six
    //     + seven
    //     + eight
    //     + nine
    //     + ten
    //     + eleven
    //     + twelve
    //     + thirteen
    //     + fourteen
    // )
    assert
    // abi_routing/contract.py:227
    // return fifteen
    frame_dig -1
    retsub


// test_cases.abi_routing.contract.Reference.method_with_more_than_15_args(a: bytes, b: bytes, c: bytes, d: uint64, asset: uint64, e: bytes, f: bytes, pay: uint64, g: bytes, h: bytes, i: bytes, j: bytes, k: bytes, l: bytes, m: bytes, n: bytes, o: bytes, p: uint64, q: bytes, r: bytes, s: bytes, t: bytes, asset2: uint64, pay2: uint64, u: bytes, v: bytes) -> bytes:
method_with_more_than_15_args:
    // abi_routing/contract.py:229-259
    // @arc4.abimethod
    // def method_with_more_than_15_args(
    //     self,
    //     a: arc4.UInt64,
    //     b: arc4.UInt64,
    //     c: arc4.UInt64,
    //     d: UInt64,
    //     asset: Asset,
    //     e: arc4.UInt64,
    //     f: arc4.UInt64,
    //     pay: gtxn.PaymentTransaction,
    //     g: arc4.UInt64,
    //     h: arc4.UInt64,
    //     i: arc4.UInt64,
    //     j: arc4.UInt64,
    //     k: arc4.UInt64,
    //     # ruff: noqa: E741
    //     l: arc4.UInt64,
    //     m: arc4.UInt64,
    //     n: arc4.UInt64,
    //     o: arc4.UInt64,
    //     p: UInt64,
    //     q: arc4.UInt64,
    //     r: arc4.UInt64,
    //     s: Bytes,
    //     t: Bytes,
    //     asset2: Asset,
    //     pay2: gtxn.PaymentTransaction,
    //     u: arc4.UInt64,
    //     v: arc4.UInt64,
    // ) -> arc4.UInt64:
    proto 26 1

method_with_more_than_15_args_block@0:
    // abi_routing/contract.py:264
    // assert op.Txn.num_app_args == 16
    txn NumAppArgs
    pushint 16 // 16
    ==
    assert
    // abi_routing/contract.py:265
    // assert pay.amount == 100000
    frame_dig -19
    gtxns Amount
    pushint 100000 // 100000
    ==
    assert
    // abi_routing/contract.py:266
    // assert pay2.amount == 200000
    frame_dig -3
    gtxns Amount
    pushint 200000 // 200000
    ==
    assert
    // abi_routing/contract.py:267
    // assert asset.id
    frame_dig -22
    intc_1 // 0
    !=
    assert
    // abi_routing/contract.py:268
    // assert asset2.id
    frame_dig -4
    intc_1 // 0
    !=
    assert
    // abi_routing/contract.py:270
    // log(s + t)
    frame_dig -6
    frame_dig -5
    concat
    log
    // abi_routing/contract.py:273
    // a.native
    frame_dig -26
    btoi
    // abi_routing/contract.py:274
    // + b.native
    frame_dig -25
    btoi
    // abi_routing/contract.py:273-274
    // a.native
    // + b.native
    +
    // abi_routing/contract.py:275
    // + c.native
    frame_dig -24
    btoi
    // abi_routing/contract.py:273-275
    // a.native
    // + b.native
    // + c.native
    +
    // abi_routing/contract.py:273-276
    // a.native
    // + b.native
    // + c.native
    // + d
    frame_dig -23
    +
    // abi_routing/contract.py:277
    // + e.native
    frame_dig -21
    btoi
    // abi_routing/contract.py:273-277
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    +
    // abi_routing/contract.py:278
    // + f.native
    frame_dig -20
    btoi
    // abi_routing/contract.py:273-278
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    +
    // abi_routing/contract.py:279
    // + g.native
    frame_dig -18
    btoi
    // abi_routing/contract.py:273-279
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    +
    // abi_routing/contract.py:280
    // + h.native
    frame_dig -17
    btoi
    // abi_routing/contract.py:273-280
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    +
    // abi_routing/contract.py:281
    // + i.native
    frame_dig -16
    btoi
    // abi_routing/contract.py:273-281
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    +
    // abi_routing/contract.py:282
    // + j.native
    frame_dig -15
    btoi
    // abi_routing/contract.py:273-282
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    +
    // abi_routing/contract.py:283
    // + k.native
    frame_dig -14
    btoi
    // abi_routing/contract.py:273-283
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    +
    // abi_routing/contract.py:284
    // + l.native
    frame_dig -13
    btoi
    // abi_routing/contract.py:273-284
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    +
    // abi_routing/contract.py:285
    // + m.native
    frame_dig -12
    btoi
    // abi_routing/contract.py:273-285
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    +
    // abi_routing/contract.py:286
    // + n.native
    frame_dig -11
    btoi
    // abi_routing/contract.py:273-286
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    +
    // abi_routing/contract.py:287
    // + o.native
    frame_dig -10
    btoi
    // abi_routing/contract.py:273-287
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    +
    // abi_routing/contract.py:273-288
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    // + p
    frame_dig -9
    +
    // abi_routing/contract.py:289
    // + q.native
    frame_dig -8
    btoi
    // abi_routing/contract.py:273-289
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    // + p
    // + q.native
    +
    // abi_routing/contract.py:290
    // + r.native
    frame_dig -7
    btoi
    // abi_routing/contract.py:273-290
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    // + p
    // + q.native
    // + r.native
    +
    // abi_routing/contract.py:291
    // + u.native
    frame_dig -2
    btoi
    // abi_routing/contract.py:273-291
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    // + p
    // + q.native
    // + r.native
    // + u.native
    +
    // abi_routing/contract.py:292
    // + v.native
    frame_dig -1
    btoi
    // abi_routing/contract.py:273-292
    // a.native
    // + b.native
    // + c.native
    // + d
    // + e.native
    // + f.native
    // + g.native
    // + h.native
    // + i.native
    // + j.native
    // + k.native
    // + l.native
    // + m.native
    // + n.native
    // + o.native
    // + p
    // + q.native
    // + r.native
    // + u.native
    // + v.native
    +
    // abi_routing/contract.py:272-293
    // return arc4.UInt64(
    //     a.native
    //     + b.native
    //     + c.native
    //     + d
    //     + e.native
    //     + f.native
    //     + g.native
    //     + h.native
    //     + i.native
    //     + j.native
    //     + k.native
    //     + l.native
    //     + m.native
    //     + n.native
    //     + o.native
    //     + p
    //     + q.native
    //     + r.native
    //     + u.native
    //     + v.native
    // )
    itob
    retsub


// test_cases.abi_routing.contract.Reference.hello_with_algopy_string(name: bytes) -> bytes:
hello_with_algopy_string:
    // abi_routing/contract.py:295-296
    // @arc4.abimethod
    // def hello_with_algopy_string(self, name: String) -> String:
    proto 1 1

hello_with_algopy_string_block@0:
    // abi_routing/contract.py:297
    // return "Hello " + name + "!"
    pushbytes "Hello "
    frame_dig -1
    concat
    pushbytes "!"
    concat
    retsub


// algopy.arc4.ARC4Contract.approval_program() -> uint64:
approval_program:

approval_program_block@0:

approval_program_block@1:
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txn NumAppArgs
    intc_1 // 0
    !=
    bz approval_program_bare_routing@20

approval_program_abi_routing@2:
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 0
    pushbytes 0xd78db35b // method "noop_with_uint64(uint64)uint8"
    bytec 4 // method "opt_in(uint64,byte[])void"
    pushbytes 0x3a5353fc // method "all_the_things(uint64)uint8"
    pushbytes 0xd2f2f53c // method "mixed_oca(uint64)uint8"
    pushbytes 0x2826b202 // method "opt_into_asset(asset)void"
    pushbytes 0x6f8e94cd // method "with_transactions(asset,uint64,pay,uint64)void"
    pushbytes 0x17dc68f0 // method "compare_assets(asset,asset)void"
    pushbytes 0x7fad9780 // method "get_address()address"
    pushbytes 0x2fdf95a4 // method "get_asset()uint64"
    pushbytes 0x1399826c // method "get_application()uint64"
    pushbytes 0xa1300821 // method "get_an_int()uint64"
    pushbytes 0x670dc055 // method "method_with_default_args(asset,asset,account,account,application,application,byte[3],uint64,uint64,uint32,string,uint64,byte[])void"
    pushbytes 0x5732195a // method "method_with_15_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,byte[])byte[]"
    pushbytes 0xd17552fb // method "method_with_more_than_15_args(uint64,uint64,uint64,uint64,asset,uint64,uint64,pay,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,byte[],byte[],asset,pay,uint64,uint64)uint64"
    pushbytes 0x9023bb19 // method "hello_with_algopy_string(string)string"
    uncover 15
    match approval_program_noop_with_uint64_route@3 approval_program_opt_in_route@4 approval_program_all_the_things_route@5 approval_program_mixed_oca_route@6 approval_program_opt_into_asset_route@7 approval_program_with_transactions_route@8 approval_program_compare_assets_route@9 approval_program_get_address_route@10 approval_program_get_asset_route@11 approval_program_get_application_route@12 approval_program_get_an_int_route@13 approval_program_method_with_default_args_route@14 approval_program_method_with_15_args_route@15 approval_program_method_with_more_than_15_args_route@16 approval_program_hello_with_algopy_string_route@17

approval_program_switch_case_default@18:

approval_program_switch_case_next@19:

approval_program_after_if_else@24:
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    intc_1 // 0

approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25:
    retsub

approval_program_hello_with_algopy_string_route@17:
    // abi_routing/contract.py:295
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // abi_routing/contract.py:295
    // @arc4.abimethod
    callsub hello_with_algopy_string
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_method_with_more_than_15_args_route@16:
    // abi_routing/contract.py:229
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txn GroupIndex
    intc_3 // 2
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 10
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 11
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 12
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 13
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 14
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    intc_1 // 0
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    intc_2 // 8
    dup
    extract3 // on error: Index access is out of bounds
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 16 // 16
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 24 // 24
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 32 // 32
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dup
    pushint 40 // 40
    extract_uint16
    swap
    dup
    pushint 42 // 42
    extract_uint16
    swap
    uncover 2
    uncover 2
    substring3
    extract 2 0
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dup
    pushint 42 // 42
    extract_uint16
    swap
    dup
    len
    swap
    uncover 2
    uncover 2
    substring3
    extract 2 0
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 44 // 44
    intc_0 // 1
    extract3 // on error: Index access is out of bounds
    btoi
    txnas Assets
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 45 // 45
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    txna ApplicationArgs 15
    dup
    len
    swap
    dup
    pushint 40 // 40
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 61 // 61
    ==
    assert // invalid tail pointer at index 5 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 1
    swap
    dig 3
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    pushint 61 // 61
    +
    dig 1
    pushint 42 // 42
    extract_uint16 // on error: invalid tuple encoding
    dup
    dig 2
    ==
    assert // invalid tail pointer at index 6 of arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    dig 2
    swap
    uncover 4
    substring3
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.uint64,arc4.dynamic_array<arc4.uint8>,arc4.dynamic_array<arc4.uint8>,arc4.uint8,arc4.uint64,arc4.uint64>
    pushint 53 // 53
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    // abi_routing/contract.py:229
    // @arc4.abimethod
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    uncover 25
    callsub method_with_more_than_15_args
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_method_with_15_args_route@15:
    // abi_routing/contract.py:191
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 6
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 7
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 10
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 11
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 12
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 13
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 14
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 15
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // abi_routing/contract.py:191
    // @arc4.abimethod
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    uncover 14
    callsub method_with_15_args
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_method_with_default_args_route@14:
    // abi_routing/contract.py:142-158
    // @arc4.abimethod(
    //     default_args={
    //         "asset_from_storage": "asa",
    //         "asset_from_function": get_asset,
    //         "account_from_storage": "creator",
    //         "account_from_function": "get_address",
    //         "application_from_storage": "app",
    //         "application_from_function": get_app,
    //         "bytes_from_storage": "some_bytes",
    //         "int_from_storage": "an_int",
    //         "int_from_function": "get_a_int",
    //         "int_from_const": arc4.UInt32(123),
    //         "str_from_const": arc4.String("abc"),
    //         "int_from_local": "local_uint",
    //         "bytes_from_local": "local_bytes",
    //     }
    // )
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 4
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Accounts
    txna ApplicationArgs 5
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Applications
    txna ApplicationArgs 6
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Applications
    txna ApplicationArgs 7
    dup
    len
    pushint 3 // 3
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 3>
    txna ApplicationArgs 8
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 9
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 10
    dup
    len
    pushint 4 // 4
    ==
    assert // invalid number of bytes for arc4.uint32
    txna ApplicationArgs 11
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 12
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 13
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // abi_routing/contract.py:142-158
    // @arc4.abimethod(
    //     default_args={
    //         "asset_from_storage": "asa",
    //         "asset_from_function": get_asset,
    //         "account_from_storage": "creator",
    //         "account_from_function": "get_address",
    //         "application_from_storage": "app",
    //         "application_from_function": get_app,
    //         "bytes_from_storage": "some_bytes",
    //         "int_from_storage": "an_int",
    //         "int_from_function": "get_a_int",
    //         "int_from_const": arc4.UInt32(123),
    //         "str_from_const": arc4.String("abc"),
    //         "int_from_local": "local_uint",
    //         "bytes_from_local": "local_bytes",
    //     }
    // )
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    callsub method_with_default_args
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_get_an_int_route@13:
    // abi_routing/contract.py:138
    // @arc4.abimethod(readonly=True, name="get_an_int")
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub get_a_int
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_get_application_route@12:
    // abi_routing/contract.py:134
    // @arc4.abimethod(readonly=True, name="get_application")
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub get_app
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_get_asset_route@11:
    // abi_routing/contract.py:130
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub get_asset
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_get_address_route@10:
    // abi_routing/contract.py:126
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    callsub get_address
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_compare_assets_route@9:
    // abi_routing/contract.py:122
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    // abi_routing/contract.py:122
    // @arc4.abimethod
    callsub compare_assets
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_with_transactions_route@8:
    // abi_routing/contract.py:109
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // abi_routing/contract.py:109
    // @arc4.abimethod
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    callsub with_transactions
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_opt_into_asset_route@7:
    // abi_routing/contract.py:92
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    btoi
    txnas Assets
    // abi_routing/contract.py:92
    // @arc4.abimethod
    callsub opt_into_asset
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_mixed_oca_route@6:
    // abi_routing/contract.py:66-74
    // @arc4.abimethod(
    //     allow_actions=[
    //         "NoOp",
    //         "CloseOut",
    //         "DeleteApplication",
    //     ],
    //     create="disallow",
    //     readonly=True,
    // )
    txn OnCompletion
    intc_0 // 1
    swap
    shl
    pushint 37 // 37
    &
    assert // OnCompletion is not one of NoOp, CloseOut, DeleteApplication
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // abi_routing/contract.py:66-74
    // @arc4.abimethod(
    //     allow_actions=[
    //         "NoOp",
    //         "CloseOut",
    //         "DeleteApplication",
    //     ],
    //     create="disallow",
    //     readonly=True,
    // )
    callsub mixed_oca
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_all_the_things_route@5:
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // abi_routing/contract.py:50-61
    // @arc4.abimethod(
    //     allow_actions=[
    //         "NoOp",
    //         OnCompleteAction.OptIn,
    //         "CloseOut",
    //         OnCompleteAction.UpdateApplication,
    //         OnCompleteAction.DeleteApplication,
    //     ],
    //     name="all_the_things",
    //     create="allow",
    //     readonly=True,
    // )
    callsub full_abi_config
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_opt_in_route@4:
    // abi_routing/contract.py:45
    // @arc4.abimethod(allow_actions=[OnCompleteAction.OptIn])
    txn OnCompletion
    intc_0 // OptIn
    ==
    assert // OnCompletion is not OptIn
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 1
    *
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // abi_routing/contract.py:45
    // @arc4.abimethod(allow_actions=[OnCompleteAction.OptIn])
    callsub opt_in
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_noop_with_uint64_route@3:
    // abi_routing/contract.py:40
    // @arc4.abimethod
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_1 // 0
    !=
    assert // can only call when not creating
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // abi_routing/contract.py:40
    // @arc4.abimethod
    callsub noop_with_uint64
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25

approval_program_bare_routing@20:
    // abi_routing/contract.py:24
    // class Reference(ARC4Contract):
    txn OnCompletion
    intc_1 // 0
    intc_0 // 1
    intc_3 // 2
    pushint 4 // 4
    pushint 5 // 5
    uncover 5
    match approval_program_bare_abi_config@21 approval_program_bare_abi_config@21 approval_program_bare_abi_config@21 approval_program_bare_abi_config@21 approval_program_bare_abi_config@21

approval_program_switch_case_default@22:

approval_program_switch_case_next@23:
    b approval_program_after_if_else@24

approval_program_bare_abi_config@21:
    // abi_routing/contract.py:79-88
    // @arc4.baremethod(
    //     allow_actions=[
    //         "NoOp",
    //         "OptIn",
    //         "CloseOut",
    //         "UpdateApplication",
    //         "DeleteApplication",
    //     ],
    //     create="require",
    // )
    txn ApplicationID
    intc_1 // 0
    ==
    assert // can only call when creating
    callsub bare_abi_config
    intc_0 // 1
    b approval_program_after_inlined_test_cases.abi_routing.contract.Reference.__puya_arc4_router__@25
