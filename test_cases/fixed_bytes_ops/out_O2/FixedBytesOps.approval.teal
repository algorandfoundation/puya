#pragma version 11
#pragma typetrack false

// test_cases.fixed_bytes_ops.contract.FixedBytesOps.approval_program() -> uint64:
main:
    intcblock 1 0 4 3
    bytecblock 0xabcd1234 0xcd12 0xabcdef 0x "local" "box"
    intc_1 // 0
    dupn 3
    bytec_3 // ""
    dup
    txn NumAppArgs
    bz main_else_body@33
    txna ApplicationArgs 0
    bury 4
    txn NumAppArgs
    intc_0 // 1
    ==
    bz main_else_body@10
    dig 3
    pushbytes 0x6765745f73746174655f646174615f6f725f617373657274
    ==
    bz main_else_body@6
    txn Sender
    intc_1 // 0
    bytec 4 // "local"
    app_local_get_ex
    assert // no data for account
    log

main_after_if_else@34:
    intc_0 // 1
    return

main_else_body@6:
    dig 3
    pushbytes 0x6765745f626f785f64617461
    ==
    bz main_after_if_else@34
    bytec 5 // "box"
    box_get
    assert // check self.box exists
    log
    b main_after_if_else@34

main_else_body@10:
    txn NumAppArgs
    pushint 2 // 2
    ==
    bz main_else_body@20
    dig 3
    pushbytes 0x7365745f73746174655f64617461
    ==
    bz main_else_body@13
    txn Sender
    bytec 4 // "local"
    txna ApplicationArgs 1
    app_local_put
    b main_after_if_else@34

main_else_body@13:
    dig 3
    pushbytes 0x7365745f626f785f64617461
    ==
    bz main_else_body@15
    txna ApplicationArgs 1
    dup
    len
    pushint 5 // 5
    ==
    assert // expected bytes to be length 5
    bytec 5 // "box"
    swap
    box_put
    b main_after_if_else@34

main_else_body@15:
    dig 3
    pushbytes 0x76616c69646174655f66697865645f62797465735f33
    ==
    bz main_after_if_else@34
    txna ApplicationArgs 1
    len
    intc_3 // 3
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 3>
    b main_after_if_else@34

main_else_body@20:
    txn NumAppArgs
    intc_3 // 3
    ==
    bz main_after_if_else@34
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f6f725f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_else_body@23
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b|
    log
    b main_after_if_else@34

main_else_body@23:
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f616e645f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_else_body@25
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b&
    log
    b main_after_if_else@34

main_else_body@25:
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f786f725f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_after_if_else@34
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b^
    log
    b main_after_if_else@34

main_else_body@33:
    bytec_0 // 0xabcd1234
    callsub test_sequence_ops
    pushbytes 0xabcd12345678
    callsub test_sequence_ops
    intc_2 // 4
    bzero
    bury 5
    txn ApplicationID
    pushint 123 // 123
    ==
    pushbytess 0x616263 0x313233 // 0x616263, 0x313233
    uncover 2
    select
    len
    intc_3 // 3
    ==
    assert
    bytec_3 // 0x
    bury 3
    intc_1 // 0
    bury 1

main_for_header@58:
    dup
    intc_3 // 3
    <
    bz main_after_for@61
    bytec_2 // 0xabcdef
    dig 1
    dup
    cover 2
    intc_0 // 1
    extract3
    dig 4
    swap
    concat
    bury 4
    intc_0 // 1
    +
    bury 1
    b main_for_header@58

main_after_for@61:
    bytec_2 // 0xabcdef
    dig 3
    ==
    assert
    intc_1 // 0
    bury 2

main_for_header@62:
    dig 1
    intc_3 // 3
    <
    bz main_after_for@65
    bytec_2 // 0xabcdef
    dig 2
    dup
    cover 2
    intc_0 // 1
    extract3
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    dup
    bytec_2 // 0xabcdef
    callsub is_substring
    assert
    bytec_2 // 0xabcdef
    callsub is_substring
    assert
    intc_0 // 1
    +
    bury 2
    b main_for_header@62

main_after_for@65:
    pushint 32 // 32
    bzero
    bury 6
    intc_1 // 0
    bury 1

main_for_header@68:
    dup
    pushint 8 // 8
    <
    bz main_after_for@71
    dupn 2
    intc_2 // 4
    *
    dig 7
    swap
    intc_2 // 4
    extract3 // on error: index access is out of bounds
    dig 6
    ==
    assert
    intc_0 // 1
    +
    bury 1
    b main_for_header@68

main_after_for@71:
    bytec_0 // 0xabcd1234
    dup
    callsub is_substring
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    assert
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    callsub is_substring
    !
    assert
    bytec_0 // 0xabcd1234
    dup
    callsub is_substring
    !
    !
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    !
    !
    assert
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    callsub is_substring
    !
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    assert
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    callsub is_substring
    !
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    !
    !
    assert
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    callsub is_substring
    !
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    assert
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    callsub is_substring
    !
    !
    assert
    pushbytes 0x68656c6c6f
    log
    b main_after_if_else@34


// _puya_lib.bytes_.is_substring(item: bytes, sequence: bytes) -> uint64:
is_substring:
    proto 2 1
    bytec_3 // ""
    intc_1 // 0

is_substring_while_top@1:
    frame_dig -2
    len
    frame_dig 1
    +
    dup
    frame_bury 0
    frame_dig -1
    len
    <=
    bz is_substring_after_while@5
    frame_dig -1
    frame_dig 1
    frame_dig 0
    substring3
    frame_dig -2
    ==
    bz is_substring_after_if_else@4
    intc_0 // 1
    frame_bury 0
    retsub

is_substring_after_if_else@4:
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    b is_substring_while_top@1

is_substring_after_while@5:
    intc_1 // 0
    frame_bury 0
    retsub


// test_cases.fixed_bytes_ops.contract.test_sequence_ops(val: bytes) -> void:
test_sequence_ops:
    proto 1 0
    bytec_3 // ""
    frame_dig -1
    extract 0 1
    pushbytes 0xab
    ==
    assert
    frame_dig -1
    extract 3 1
    pushbytes 0x34
    ==
    assert
    frame_dig -1
    substring 1 3
    bytec_1 // 0xcd12
    ==
    assert
    frame_dig -1
    substring 0 2
    pushbytes 0xabcd
    ==
    assert
    frame_dig -1
    substring 2 4
    pushbytes 0x1234
    ==
    assert
    frame_dig -1
    substring 0 3
    pushbytes 0xabcd12
    ==
    assert
    intc_1 // 0
    dup

test_sequence_ops_for_header@1:
    frame_dig 2
    intc_2 // 4
    <
    bz test_sequence_ops_after_for@4
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b test_sequence_ops_for_header@1

test_sequence_ops_after_for@4:
    frame_dig 1
    intc_2 // 4
    ==
    assert
    intc_1 // 0
    frame_bury 1
    intc_2 // 4
    frame_bury 0

test_sequence_ops_for_header@5:
    frame_dig 0
    bz test_sequence_ops_after_for@8
    frame_dig 0
    intc_0 // 1
    -
    frame_bury 0
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    b test_sequence_ops_for_header@5

test_sequence_ops_after_for@8:
    frame_dig 1
    intc_2 // 4
    ==
    assert
    retsub
