#pragma version 11
#pragma typetrack false

// test_cases.fixed_bytes_ops.contract.FixedBytesOps.approval_program() -> uint64:
main:
    intcblock 1 0 4 3
    bytecblock 0xabcd1234 0xcd12 0xabcdef 0x "local" "box"
    intc_1 // 0
    dupn 3
    bytec_3 // ""
    dup
    // fixed_bytes_ops/contract.py:27
    // if Txn.num_app_args > 0:
    txn NumAppArgs
    bz main_else_body@33
    // fixed_bytes_ops/contract.py:28
    // method = Txn.application_args(0)
    txna ApplicationArgs 0
    bury 4
    // fixed_bytes_ops/contract.py:29
    // if Txn.num_app_args == 1:
    txn NumAppArgs
    intc_0 // 1
    ==
    bz main_else_body@10
    // fixed_bytes_ops/contract.py:30
    // if method == b"get_state_data_or_assert":
    dig 3
    pushbytes 0x6765745f73746174655f646174615f6f725f617373657274
    ==
    bz main_else_body@6
    // fixed_bytes_ops/contract.py:31
    // log(self.get_state_data_or_assert(Txn.sender))
    txn Sender
    // fixed_bytes_ops/contract.py:125
    // result, exists = self.local.maybe(for_account)
    intc_1 // 0
    bytec 4 // "local"
    app_local_get_ex
    // fixed_bytes_ops/contract.py:126
    // assert exists, "no data for account"
    assert // no data for account
    // fixed_bytes_ops/contract.py:31
    // log(self.get_state_data_or_assert(Txn.sender))
    log

main_after_if_else@34:
    // fixed_bytes_ops/contract.py:114
    // return True
    intc_0 // 1
    return

main_else_body@6:
    // fixed_bytes_ops/contract.py:32
    // elif method == b"get_box_data":
    dig 3
    pushbytes 0x6765745f626f785f64617461
    ==
    bz main_after_if_else@34
    // fixed_bytes_ops/contract.py:33
    // log(self.box.value)
    bytec 5 // "box"
    box_get
    assert // check self.box exists
    log
    b main_after_if_else@34

main_else_body@10:
    // fixed_bytes_ops/contract.py:34
    // elif Txn.num_app_args == 2:
    txn NumAppArgs
    pushint 2
    ==
    bz main_else_body@20
    // fixed_bytes_ops/contract.py:35
    // if method == b"set_state_data":
    dig 3
    pushbytes 0x7365745f73746174655f64617461
    ==
    bz main_else_body@13
    // fixed_bytes_ops/contract.py:37
    // Txn.sender,
    txn Sender
    // fixed_bytes_ops/contract.py:121
    // self.local[for_account] = value
    bytec 4 // "local"
    // fixed_bytes_ops/contract.py:38
    // FixedBytes[typing.Literal[4]].from_bytes(Txn.application_args(1)),
    txna ApplicationArgs 1
    // fixed_bytes_ops/contract.py:121
    // self.local[for_account] = value
    app_local_put
    b main_after_if_else@34

main_else_body@13:
    // fixed_bytes_ops/contract.py:40
    // elif method == b"set_box_data":
    dig 3
    pushbytes 0x7365745f626f785f64617461
    ==
    bz main_else_body@15
    // fixed_bytes_ops/contract.py:41
    // self.box.value = FixedBytes[typing.Literal[5]](Txn.application_args(1))
    txna ApplicationArgs 1
    dup
    len
    pushint 5
    ==
    assert // expected bytes to be length 5
    bytec 5 // "box"
    swap
    box_put
    b main_after_if_else@34

main_else_body@15:
    // fixed_bytes_ops/contract.py:42
    // elif method == b"validate_fixed_bytes_3":
    dig 3
    pushbytes 0x76616c69646174655f66697865645f62797465735f33
    ==
    bz main_after_if_else@34
    // fixed_bytes_ops/contract.py:44
    // FixedBytes[typing.Literal[3]].from_bytes(Txn.application_args(1))
    txna ApplicationArgs 1
    // fixed_bytes_ops/contract.py:155
    // val.validate()
    len
    intc_3 // 3
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 3>
    b main_after_if_else@34

main_else_body@20:
    // fixed_bytes_ops/contract.py:46
    // elif Txn.num_app_args == 3:
    txn NumAppArgs
    intc_3 // 3
    ==
    bz main_after_if_else@34
    // fixed_bytes_ops/contract.py:47
    // if method == b"test_augmented_or_assignment_with_bytes":
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f6f725f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_else_body@23
    // fixed_bytes_ops/contract.py:49
    // FixedBytes[typing.Literal[1]].from_bytes(Txn.application_args(1)),
    txna ApplicationArgs 1
    // fixed_bytes_ops/contract.py:50
    // Txn.application_args(2),
    txna ApplicationArgs 2
    // fixed_bytes_ops/contract.py:134
    // val1 |= other
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b|
    // fixed_bytes_ops/contract.py:135
    // log(val1)
    log
    b main_after_if_else@34

main_else_body@23:
    // fixed_bytes_ops/contract.py:52
    // elif method == b"test_augmented_and_assignment_with_bytes":
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f616e645f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_else_body@25
    // fixed_bytes_ops/contract.py:54
    // FixedBytes[typing.Literal[1]].from_bytes(Txn.application_args(1)),
    txna ApplicationArgs 1
    // fixed_bytes_ops/contract.py:55
    // Txn.application_args(2),
    txna ApplicationArgs 2
    // fixed_bytes_ops/contract.py:142
    // val1 &= other
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b&
    // fixed_bytes_ops/contract.py:143
    // log(val1)
    log
    b main_after_if_else@34

main_else_body@25:
    // fixed_bytes_ops/contract.py:57
    // elif method == b"test_augmented_xor_assignment_with_bytes":
    dig 3
    pushbytes 0x746573745f6175676d656e7465645f786f725f61737369676e6d656e745f776974685f6279746573
    ==
    bz main_after_if_else@34
    // fixed_bytes_ops/contract.py:59
    // FixedBytes[typing.Literal[1]].from_bytes(Txn.application_args(1)),
    txna ApplicationArgs 1
    // fixed_bytes_ops/contract.py:60
    // Txn.application_args(2),
    txna ApplicationArgs 2
    // fixed_bytes_ops/contract.py:150
    // val1 ^= other
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    b^
    // fixed_bytes_ops/contract.py:151
    // log(val1)
    log
    b main_after_if_else@34

main_else_body@33:
    // fixed_bytes_ops/contract.py:90
    // test_sequence_ops(FixedBytes.from_bytes(b"\xab\xcd\x12\x34"))
    bytec_0 // 0xabcd1234
    callsub test_sequence_ops
    // fixed_bytes_ops/contract.py:93
    // FixedBytes[typing.Literal[4]].from_bytes(Bytes.from_hex("ABCD12345678"))
    pushbytes 0xabcd12345678
    // fixed_bytes_ops/contract.py:92-94
    // test_sequence_ops(
    //     FixedBytes[typing.Literal[4]].from_bytes(Bytes.from_hex("ABCD12345678"))
    // )
    callsub test_sequence_ops
    // fixed_bytes_ops/contract.py:518
    // empty_1 = FixedBytes[typing.Literal[4]]()
    intc_2 // 4
    bzero
    bury 5
    // fixed_bytes_ops/contract.py:524
    // abc = FixedBytes[typing.Literal[3]](b"123" if Txn.application_id == 123 else b"abc")
    txn ApplicationID
    pushint 123
    ==
    pushbytess 0x616263 0x313233
    uncover 2
    select
    // fixed_bytes_ops/contract.py:525
    // assert abc.bytes.length == 3
    len
    intc_3 // 3
    ==
    assert
    // fixed_bytes_ops/contract.py:535
    // result = Bytes()
    bytec_3 // 0x
    bury 3
    intc_1 // 0
    bury 1

main_for_header@58:
    // fixed_bytes_ops/contract.py:537
    // for item in val:
    dup
    intc_3 // 3
    <
    bz main_after_for@61
    // fixed_bytes_ops/contract.py:533-534
    // # from_hex
    // val: FixedBytes[typing.Literal[3]] = FixedBytes.from_hex("ABCDEF")
    bytec_2 // 0xabcdef
    // fixed_bytes_ops/contract.py:537
    // for item in val:
    dig 1
    dup
    cover 2
    intc_0 // 1
    extract3
    // fixed_bytes_ops/contract.py:538
    // result += item
    dig 4
    swap
    concat
    bury 4
    intc_0 // 1
    +
    bury 1
    b main_for_header@58

main_after_for@61:
    // fixed_bytes_ops/contract.py:533-534
    // # from_hex
    // val: FixedBytes[typing.Literal[3]] = FixedBytes.from_hex("ABCDEF")
    bytec_2 // 0xabcdef
    // fixed_bytes_ops/contract.py:539
    // assert result == val
    dig 3
    ==
    assert
    intc_1 // 0
    bury 2

main_for_header@62:
    // fixed_bytes_ops/contract.py:541
    // for idx, byte in uenumerate(val):
    dig 1
    intc_3 // 3
    <
    bz main_after_for@65
    // fixed_bytes_ops/contract.py:533-534
    // # from_hex
    // val: FixedBytes[typing.Literal[3]] = FixedBytes.from_hex("ABCDEF")
    bytec_2 // 0xabcdef
    // fixed_bytes_ops/contract.py:541
    // for idx, byte in uenumerate(val):
    dig 2
    dup
    cover 2
    intc_0 // 1
    extract3
    // fixed_bytes_ops/contract.py:543
    // assert FB1(byte) == val[idx]
    dup
    len
    intc_0 // 1
    ==
    assert // expected bytes to be length 1
    // fixed_bytes_ops/contract.py:545
    // assert byte in val
    dup
    // fixed_bytes_ops/contract.py:533-534
    // # from_hex
    // val: FixedBytes[typing.Literal[3]] = FixedBytes.from_hex("ABCDEF")
    bytec_2 // 0xabcdef
    // fixed_bytes_ops/contract.py:545
    // assert byte in val
    callsub is_substring
    assert
    // fixed_bytes_ops/contract.py:533-534
    // # from_hex
    // val: FixedBytes[typing.Literal[3]] = FixedBytes.from_hex("ABCDEF")
    bytec_2 // 0xabcdef
    // fixed_bytes_ops/contract.py:546
    // assert FB1(byte) in val
    callsub is_substring
    assert
    intc_0 // 1
    +
    bury 2
    b main_for_header@62

main_after_for@65:
    // fixed_bytes_ops/contract.py:576
    // arr = zero_bytes(FixedArray[FixedBytes[typing.Literal[4]], typing.Literal[8]])
    pushint 32
    bzero
    bury 6
    intc_1 // 0
    bury 1

main_for_header@68:
    // fixed_bytes_ops/contract.py:579
    // for v in arr:
    dup
    pushint 8
    <
    bz main_after_for@71
    dupn 2
    intc_2 // 4
    *
    dig 7
    swap
    intc_2 // 4
    extract3 // on error: index access is out of bounds
    // fixed_bytes_ops/contract.py:580
    // assert v == FixedBytes[typing.Literal[4]]()
    dig 6
    ==
    assert
    intc_0 // 1
    +
    bury 1
    b main_for_header@68

main_after_for@71:
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    dup
    // fixed_bytes_ops/contract.py:606
    // assert x in x  # noqa: PLR0124
    callsub is_substring
    assert
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:607
    // assert y in x
    callsub is_substring
    assert
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:608
    // assert x not in y
    callsub is_substring
    !
    assert
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    dup
    // fixed_bytes_ops/contract.py:610
    // assert (x not in x) == False  # noqa: E712, PLR0124
    callsub is_substring
    !
    !
    assert
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:611
    // assert (y not in x) == False  # noqa: E712
    callsub is_substring
    !
    !
    assert
    // fixed_bytes_ops/contract.py:105
    // FixedBytes.from_hex("ABCD1234"), FixedBytes.from_bytes(Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:612
    // assert (x in y) == False  # noqa: E712
    callsub is_substring
    !
    assert
    // fixed_bytes_ops/contract.py:108
    // test_contains_bytes(FixedBytes.from_hex("ABCD1234"), Bytes.from_hex("CD12"))
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:617
    // assert y in x
    callsub is_substring
    assert
    // fixed_bytes_ops/contract.py:108
    // test_contains_bytes(FixedBytes.from_hex("ABCD1234"), Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:618
    // assert x not in y
    callsub is_substring
    !
    assert
    // fixed_bytes_ops/contract.py:108
    // test_contains_bytes(FixedBytes.from_hex("ABCD1234"), Bytes.from_hex("CD12"))
    bytec_1 // 0xcd12
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:620
    // assert (y not in x) == False  # noqa: E712
    callsub is_substring
    !
    !
    assert
    // fixed_bytes_ops/contract.py:108
    // test_contains_bytes(FixedBytes.from_hex("ABCD1234"), Bytes.from_hex("CD12"))
    bytec_0 // 0xabcd1234
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:621
    // assert (x in y) == False  # noqa: E712
    callsub is_substring
    !
    assert
    // fixed_bytes_ops/contract.py:626
    // assert b"\xcd\x12" in x
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:110
    // test_contains_literal_bytes(FixedBytes.from_hex("ABCD1234"))
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:626
    // assert b"\xcd\x12" in x
    callsub is_substring
    assert
    // fixed_bytes_ops/contract.py:628
    // assert (b"\xcd\x12" not in x) == False  # noqa: E712
    bytec_1 // 0xcd12
    // fixed_bytes_ops/contract.py:110
    // test_contains_literal_bytes(FixedBytes.from_hex("ABCD1234"))
    bytec_0 // 0xabcd1234
    // fixed_bytes_ops/contract.py:628
    // assert (b"\xcd\x12" not in x) == False  # noqa: E712
    callsub is_substring
    !
    !
    assert
    // fixed_bytes_ops/contract.py:111
    // result = FixedBytes[typing.Literal[5]](b"hello")
    pushbytes 0x68656c6c6f
    // fixed_bytes_ops/contract.py:112
    // log(result)
    log
    b main_after_if_else@34


// _puya_lib.bytes_.is_substring(item: bytes, sequence: bytes) -> uint64:
is_substring:
    proto 2 1
    bytec_3 // ""
    intc_1 // 0

is_substring_while_top@1:
    frame_dig -2
    len
    frame_dig 1
    +
    dup
    frame_bury 0
    frame_dig -1
    len
    <=
    bz is_substring_after_while@5
    frame_dig -1
    frame_dig 1
    frame_dig 0
    substring3
    frame_dig -2
    ==
    bz is_substring_after_if_else@4
    intc_0 // 1
    frame_bury 0
    retsub

is_substring_after_if_else@4:
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    b is_substring_while_top@1

is_substring_after_while@5:
    intc_1 // 0
    frame_bury 0
    retsub


// test_cases.fixed_bytes_ops.contract.test_sequence_ops(val: bytes) -> void:
test_sequence_ops:
    // fixed_bytes_ops/contract.py:441-442
    // @subroutine(inline=False)
    // def test_sequence_ops(val: FixedBytes[typing.Literal[4]]) -> None:
    proto 1 0
    bytec_3 // ""
    // fixed_bytes_ops/contract.py:448-449
    // # Indexing (returns Bytes)
    // first_byte = val[0]
    frame_dig -1
    extract 0 1
    // fixed_bytes_ops/contract.py:450
    // assert first_byte == Bytes.from_hex("AB")
    pushbytes 0xab
    ==
    assert
    // fixed_bytes_ops/contract.py:452
    // last_byte = val[3]
    frame_dig -1
    extract 3 1
    // fixed_bytes_ops/contract.py:453
    // assert last_byte == Bytes.from_hex("34")
    pushbytes 0x34
    ==
    assert
    // fixed_bytes_ops/contract.py:456-457
    // # Slicing (returns Bytes)
    // slice_result = val[1:3]
    frame_dig -1
    substring 1 3
    // fixed_bytes_ops/contract.py:458
    // assert slice_result == Bytes.from_hex("CD12")
    bytec_1 // 0xcd12
    ==
    assert
    // fixed_bytes_ops/contract.py:460
    // slice_result = val[:2]
    frame_dig -1
    substring 0 2
    // fixed_bytes_ops/contract.py:461
    // assert slice_result == Bytes.from_hex("ABCD")
    pushbytes 0xabcd
    ==
    assert
    // fixed_bytes_ops/contract.py:463
    // slice_result = val[2:]
    frame_dig -1
    substring 2 4
    // fixed_bytes_ops/contract.py:464
    // assert slice_result == Bytes.from_hex("1234")
    pushbytes 0x1234
    ==
    assert
    // fixed_bytes_ops/contract.py:466
    // slice_result = val[:-1]
    frame_dig -1
    substring 0 3
    // fixed_bytes_ops/contract.py:467
    // assert slice_result == Bytes.from_hex("ABCD12")
    pushbytes 0xabcd12
    ==
    assert
    // fixed_bytes_ops/contract.py:475-476
    // # Iteration
    // count = UInt64(0)
    intc_1 // 0
    dup

test_sequence_ops_for_header@1:
    // fixed_bytes_ops/contract.py:477
    // for _byte in val:
    frame_dig 2
    intc_2 // 4
    <
    bz test_sequence_ops_after_for@4
    // fixed_bytes_ops/contract.py:478
    // count += 1
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b test_sequence_ops_for_header@1

test_sequence_ops_after_for@4:
    // fixed_bytes_ops/contract.py:479
    // assert count == 4
    frame_dig 1
    intc_2 // 4
    ==
    assert
    // fixed_bytes_ops/contract.py:481-482
    // # Reverse iteration
    // count = UInt64(0)
    intc_1 // 0
    frame_bury 1
    // fixed_bytes_ops/contract.py:483
    // for _byte in reversed(val):
    intc_2 // 4
    frame_bury 0

test_sequence_ops_for_header@5:
    // fixed_bytes_ops/contract.py:483
    // for _byte in reversed(val):
    frame_dig 0
    bz test_sequence_ops_after_for@8
    frame_dig 0
    intc_0 // 1
    -
    frame_bury 0
    // fixed_bytes_ops/contract.py:484
    // count += 1
    frame_dig 1
    intc_0 // 1
    +
    frame_bury 1
    b test_sequence_ops_for_header@5

test_sequence_ops_after_for@8:
    // fixed_bytes_ops/contract.py:485
    // assert count == 4
    frame_dig 1
    intc_2 // 4
    ==
    assert
    retsub
