contract FixedBytesOps
{
  method_resolution_order: (
    algopy._contract.Contract,
  )
  locals {
    ['local']: bytes[4]
  }
  boxes {
    ['box']: bytes[5]
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.approval_program(): bool
  {
    if (!(txn<ApplicationID>())) {
      this::__init__()
    }
    if (txn<NumAppArgs>() > 0u) {
      method: bytes = txna<ApplicationArgs, 0>()
      if (txn<NumAppArgs>() == 1u) {
        if (method == hex<"6765745F73746174655F646174615F6F725F617373657274">) {
          log(reinterpret_cast<bytes>(this::get_state_data_or_assert(txn<Sender>())))
        } else {
          if (method == hex<"6765745F626F785F64617461">) {
            log(reinterpret_cast<bytes>(Box['box']))
          }
        }
      } else {
        if (txn<NumAppArgs>() == 2u) {
          if (method == hex<"7365745F73746174655F64617461">) {
            this::set_state_data(txn<Sender>(), reinterpret_cast<bytes[4]>(txna<ApplicationArgs, 1>()))
          } else {
            if (method == hex<"7365745F626F785F64617461">) {
              Box['box']: bytes[5] = checked_maybe((reinterpret_cast<bytes[5]>(SINGLE_EVAL(id=0, source=txna<ApplicationArgs, 1>())), len(SINGLE_EVAL(id=0)) == 5u))
            } else {
              if (method == hex<"76616C69646174655F66697865645F62797465735F33">) {
                this::validate_fixed_bytes_3(reinterpret_cast<bytes[3]>(txna<ApplicationArgs, 1>()))
              }
            }
          }
        } else {
          if (txn<NumAppArgs>() == 3u) {
            if (method == hex<"746573745F6175676D656E7465645F6F725F61737369676E6D656E745F776974685F6279746573">) {
              this::test_augmented_or_assignment_with_bytes(reinterpret_cast<bytes[1]>(txna<ApplicationArgs, 1>()), txna<ApplicationArgs, 2>())
            } else {
              if (method == hex<"746573745F6175676D656E7465645F616E645F61737369676E6D656E745F776974685F6279746573">) {
                this::test_augmented_and_assignment_with_bytes(reinterpret_cast<bytes[1]>(txna<ApplicationArgs, 1>()), txna<ApplicationArgs, 2>())
              } else {
                if (method == hex<"746573745F6175676D656E7465645F786F725F61737369676E6D656E745F776974685F6279746573">) {
                  this::test_augmented_xor_assignment_with_bytes(reinterpret_cast<bytes[1]>(txna<ApplicationArgs, 1>()), txna<ApplicationArgs, 2>())
                }
              }
            }
          }
        }
      }
    } else {
      test_cases.fixed_bytes_ops.contract.test_binary_ops(hex<"FF">, hex<"0F">)
      test_cases.fixed_bytes_ops.contract.test_binary_ops_with_fixed_bytes_of_different_size(hex<"FF">, hex<"0F0F">)
      test_cases.fixed_bytes_ops.contract.test_binary_ops_with_bytes_of_different_size(hex<"FF">, hex<"0F0F">)
      test_cases.fixed_bytes_ops.contract.test_binary_ops_with_literal_bytes(hex<"FF">)
      test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_invalid_lengths(reinterpret_cast<bytes[3]>(hex<"F0F0F0F0">), reinterpret_cast<bytes[3]>(hex<"0F0F">))
      test_cases.fixed_bytes_ops.contract.test_augmented_assignment(hex<"F0">, hex<"0F">)
      test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_bytes(hex<"F0">, hex<"0F">)
      test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_literal_bytes(hex<"F0">)
      test_cases.fixed_bytes_ops.contract.test_unary_ops()
      test_cases.fixed_bytes_ops.contract.test_comparison_ops()
      test_cases.fixed_bytes_ops.contract.test_sequence_ops(hex<"ABCD1234">)
      test_cases.fixed_bytes_ops.contract.test_sequence_ops(reinterpret_cast<bytes[4]>(hex<"ABCD12345678">))
      test_cases.fixed_bytes_ops.contract.test_construction()
      test_cases.fixed_bytes_ops.contract.test_iteration()
      test_cases.fixed_bytes_ops.contract.test_size_of()
      test_cases.fixed_bytes_ops.contract.test_passing_fixed_bytes()
      test_cases.fixed_bytes_ops.contract.test_contains_fixed_bytes(hex<"ABCD1234">, hex<"CD12">)
      test_cases.fixed_bytes_ops.contract.test_contains_bytes(hex<"ABCD1234">, hex<"CD12">)
      test_cases.fixed_bytes_ops.contract.test_contains_literal_bytes(hex<"ABCD1234">)
      result: bytes[5] = hex<"68656C6C6F">
      log(reinterpret_cast<bytes>(result))
    }
    return true
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.clear_state_program(): bool
  {
    return true
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.__init__(): void
  {
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.set_state_data(for_account: account, value: bytes[4]): void
  {
    LocalState['local', for_account]: bytes[4] = value
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.get_state_data_or_assert(for_account: account): bytes[4]
  {
    (result, exists): tuple<bytes[4],bool> = STATE_GET_EX(LocalState['local', for_account])
    assert(exists, comment="no data for account")
    return result
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_or_assignment_with_bytes(val: bytes[1], other: bytes): void
  {
    val1: bytes[1] = val
    val1 |= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
    log(reinterpret_cast<bytes>(val1))
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_and_assignment_with_bytes(val: bytes[1], other: bytes): void
  {
    val1: bytes[1] = val
    val1 &= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
    log(reinterpret_cast<bytes>(val1))
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_xor_assignment_with_bytes(val: bytes[1], other: bytes): void
  {
    val1: bytes[1] = val
    val1 ^= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
    log(reinterpret_cast<bytes>(val1))
  }
  
  subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.validate_fixed_bytes_3(val: bytes[3]): void
  {
    arc4_validate(val, arc4.static_array<arc4.uint8, 3>)
  }
  
  subroutine algopy._contract.Contract.__init__(): void
  {
  }
}

subroutine test_binary_ops(left: bytes[1], right: bytes[1]): void
{
  result: bytes[1] = left | right
  assert(result == hex<"FF">)
  result: bytes[1] = right | left
  assert(result == hex<"FF">)
  result: bytes[1] = left ^ right
  assert(result == hex<"F0">)
  result: bytes[1] = right ^ left
  assert(result == hex<"F0">)
  result: bytes[1] = left & right
  assert(result == hex<"0F">)
  result: bytes[1] = right & left
  assert(result == hex<"0F">)
  concat_result: bytes = left + right
  assert(concat_result == hex<"FF0F">)
  concat_result: bytes = right + left
  assert(concat_result == hex<"0FFF">)
}

subroutine test_binary_ops_with_fixed_bytes_of_different_size(left: bytes[1], right: bytes[2]): void
{
  result: bytes = left | right
  assert(result == hex<"0FFF">)
  result: bytes = right | left
  assert(result == hex<"0FFF">)
  result: bytes = left ^ right
  assert(result == hex<"0FF0">)
  result: bytes = right ^ left
  assert(result == hex<"0FF0">)
  result: bytes = left & right
  assert(result == hex<"000F">)
  result: bytes = right & left
  assert(result == hex<"000F">)
  concat_result: bytes = left + right
  assert(concat_result == hex<"FF0F0F">)
  concat_result: bytes = right + left
  assert(concat_result == hex<"0F0FFF">)
}

subroutine test_binary_ops_with_bytes_of_different_size(left: bytes[1], right: bytes): void
{
  result: bytes = left | right
  assert(result == hex<"0FFF">)
  result: bytes = right | left
  assert(result == hex<"0FFF">)
  result: bytes = left ^ right
  assert(result == hex<"0FF0">)
  result: bytes = right ^ left
  assert(result == hex<"0FF0">)
  result: bytes = left & right
  assert(result == hex<"000F">)
  result: bytes = right & left
  assert(result == hex<"000F">)
  concat_result: bytes = left + right
  assert(concat_result == hex<"FF0F0F">)
  concat_result: bytes = right + left
  assert(concat_result == hex<"0F0FFF">)
}

subroutine test_binary_ops_with_literal_bytes(left: bytes[1]): void
{
  result: bytes = left | hex<"0F0F">
  assert(result == hex<"0FFF">)
  result: bytes = hex<"0F0F"> | left
  assert(result == hex<"0FFF">)
  result: bytes = left ^ hex<"0F0F">
  assert(result == hex<"0FF0">)
  result: bytes = hex<"0F0F"> ^ left
  assert(result == hex<"0FF0">)
  result: bytes = left & hex<"0F0F">
  assert(result == hex<"000F">)
  result: bytes = hex<"0F0F"> & left
  assert(result == hex<"000F">)
  concat_result: bytes = left + hex<"0F0F">
  assert(concat_result == hex<"FF0F0F">)
  concat_result: bytes = hex<"0F0F"> + left
  assert(concat_result == hex<"0F0FFF">)
}

subroutine test_augmented_assignment_with_invalid_lengths(val: bytes[3], other: bytes[3]): void
{
  val1: bytes[3] = val
  val1 |= other
  assert(reinterpret_cast<bytes>(val1) == hex<"F0F0FFFF">)
  val2: bytes[3] = val
  val2 &= other
  assert(reinterpret_cast<bytes>(val2) == hex<"00000000">)
  val3: bytes[3] = val
  val3 ^= other
  assert(reinterpret_cast<bytes>(val3) == hex<"F0F0FFFF">)
}

subroutine test_augmented_assignment(val: bytes[1], other: bytes[1]): void
{
  val1: bytes[1] = val
  val1 |= other
  assert(reinterpret_cast<bytes>(val1) == hex<"FF">)
  val2: bytes[1] = val
  val2 &= other
  assert(reinterpret_cast<bytes>(val2) == hex<"00">)
  val3: bytes[1] = val
  val3 ^= other
  assert(reinterpret_cast<bytes>(val3) == hex<"FF">)
  bytes_value: bytes = val + hex<"74657374">
  bytes_value += reinterpret_cast<bytes>(other)
  assert(len(bytes_value) == 6u)
}

subroutine test_augmented_assignment_with_bytes(val: bytes[1], other: bytes): void
{
  val1: bytes[1] = val
  val1 |= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
  assert(reinterpret_cast<bytes>(val1) == hex<"FF">)
  val2: bytes[1] = val
  val2 &= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
  assert(reinterpret_cast<bytes>(val2) == hex<"00">)
  val3: bytes[1] = val
  val3 ^= checked_maybe((reinterpret_cast<bytes[1]>(other), len(other) == 1u))
  assert(reinterpret_cast<bytes>(val3) == hex<"FF">)
}

subroutine test_augmented_assignment_with_literal_bytes(val: bytes[1]): void
{
  val1: bytes[1] = val
  val1 |= hex<"0F">
  assert(reinterpret_cast<bytes>(val1) == hex<"FF">)
  val2: bytes[1] = val
  val2 &= hex<"0F">
  assert(reinterpret_cast<bytes>(val2) == hex<"00">)
  val3: bytes[1] = val
  val3 ^= hex<"0F">
  assert(reinterpret_cast<bytes>(val3) == hex<"FF">)
}

subroutine test_unary_ops(): void
{
  val: bytes[1] = hex<"0F">
  inverted: bytes[1] = b~(val)
  assert(inverted == hex<"F0">)
}

subroutine test_comparison_ops(): void
{
  val1: bytes[2] = hex<"ABCD">
  val2: bytes[2] = hex<"ABCD">
  val3: bytes[2] = hex<"1234">
  assert(val1 == val2)
  assert(reinterpret_cast<bytes>(val1) == hex<"ABCD">)
  assert(reinterpret_cast<bytes>(val1) == hex<"ABCD">)
  assert(val2 == val1)
  assert(reinterpret_cast<bytes>(val1) == hex<"ABCD">)
  assert(reinterpret_cast<bytes>(val1) == hex<"ABCD">)
  assert(val1 != val3)
  assert(reinterpret_cast<bytes>(val1) != hex<"1234">)
  assert(reinterpret_cast<bytes>(val1) != hex<"1234">)
  assert(val3 != val1)
  assert(reinterpret_cast<bytes>(val1) != hex<"1234">)
  assert(reinterpret_cast<bytes>(val1) != hex<"1234">)
  val4: bytes[3] = reinterpret_cast<bytes[3]>(hex<"ABCD123456">)
  assert(reinterpret_cast<bytes>(val4) == hex<"ABCD123456">)
  assert(3u == 3u)
  val5: bytes[3] = hex<"ABCD12">
  assert(val4 != val5)
  val6: bytes[2] = reinterpret_cast<bytes[2]>(hex<"ABCD12">)
  val7: bytes[2] = reinterpret_cast<bytes[2]>(hex<"ABCD12">)
  assert(val6 == val7)
}

subroutine test_sequence_ops(val: bytes[4]): void
{
  assert(4u == 4u)
  first_byte: bytes = val[0u]
  assert(first_byte == hex<"AB">)
  last_byte: bytes = val[3u]
  assert(last_byte == hex<"34">)
  assert(last_byte == val[4u - 1u])
  slice_result: bytes = val[1:3]
  assert(slice_result == hex<"CD12">)
  slice_result: bytes = val[:2]
  assert(slice_result == hex<"ABCD">)
  slice_result: bytes = val[2:]
  assert(slice_result == hex<"1234">)
  slice_result: bytes = val[:-1]
  assert(slice_result == hex<"ABCD12">)
  slice_result: bytes = val[-2:]
  assert(slice_result == hex<"1234">)
  slice_result: bytes = val[-3:-1]
  assert(slice_result == hex<"CD12">)
  count: uint64 = 0u
  for _byte in val {
    count += 1u
  }
  assert(count == 4u)
  count: uint64 = 0u
  for _byte in reversed(val) {
    count += 1u
  }
  assert(count == 4u)
}

subroutine test_construction(): void
{
  hex_val: bytes[2] = hex<"ABCD">
  assert(reinterpret_cast<bytes>(hex_val) == hex<"ABCD">)
  base64_val: bytes[2] = b64<"q80=">
  assert(reinterpret_cast<bytes>(base64_val) == hex<"ABCD">)
  base32_val: bytes[2] = b32<"VPGQ====">
  assert(reinterpret_cast<bytes>(base32_val) == hex<"ABCD">)
  direct_val: bytes[2] = hex<"ABCD">
  assert(reinterpret_cast<bytes>(direct_val) == hex<"ABCD">)
  bytes_val: bytes = reinterpret_cast<bytes>(hex_val)
  assert(bytes_val == hex<"ABCD">)
  from_bytes_val: bytes[2] = reinterpret_cast<bytes[2]>(hex<"ABCD">)
  assert(reinterpret_cast<bytes>(from_bytes_val) == hex<"ABCD">)
  from_txn_sender: bytes[32] = checked_maybe((reinterpret_cast<bytes[32]>(SINGLE_EVAL(id=1, source=reinterpret_cast<bytes>(txn<Sender>()))), len(SINGLE_EVAL(id=1)) == 32u))
  assert(32u == 32u)
  empty_1: bytes[4] = bzero(4u)
  assert(reinterpret_cast<bytes>(empty_1) == hex<"00000000">)
  empty_2: bytes[0] = hex<"">
  assert(reinterpret_cast<bytes>(empty_2) == hex<"">)
  abc: bytes[3] = (txn<ApplicationID>() == reinterpret_cast<application>(123u)) ? (hex<"313233">) : (hex<"616263">)
  assert(len(reinterpret_cast<bytes>(abc)) == 3u)
}

subroutine test_iteration(): void
{
  val: bytes[3] = hex<"ABCDEF">
  result: bytes = hex<"">
  for item in val {
    result += item
  }
  assert(reinterpret_cast<bytes>(val) == result)
  for (idx, byte) in enumerate(val) {
    assert(byte == val[idx])
    assert(reinterpret_cast<bytes>(checked_maybe((reinterpret_cast<bytes[1]>(byte), len(byte) == 1u))) == val[idx])
    assert(_puya_lib.bytes_.is_substring(byte, reinterpret_cast<bytes>(val)))
    assert(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(checked_maybe((reinterpret_cast<bytes[1]>(byte), len(byte) == 1u))), reinterpret_cast<bytes>(val)))
  }
  exploded: tuple<bytes,bytes,bytes> = (val[0u], val[1u], val[2u])
  assert(exploded[0] == hex<"AB">)
  assert(exploded[-1] == hex<"EF">)
}

subroutine test_size_of(): void
{
  hex_val: bytes[2] = hex<"ABCD">
  assert(size_of(bytes[2]) == 2u)
  assert(2u == 2u)
  from_txn_sender: bytes[32] = checked_maybe((reinterpret_cast<bytes[32]>(SINGLE_EVAL(id=2, source=reinterpret_cast<bytes>(txn<Sender>()))), len(SINGLE_EVAL(id=2)) == 32u))
  assert(size_of(bytes[32]) == 32u)
  assert(32u == 32u)
  from_bytes_empty: bytes[16] = reinterpret_cast<bytes[16]>(hex<"">)
  assert(size_of(bytes[16]) == 16u)
  from_bytes_less: bytes[16] = reinterpret_cast<bytes[16]>(hex<"41424344">)
  assert(size_of(bytes[16]) == 16u)
  from_bytes_more: bytes[2] = reinterpret_cast<bytes[2]>(hex<"41424344">)
  assert(size_of(bytes[2]) == 2u)
  empty: bytes[4] = bzero(4u)
  assert(size_of(bytes[4]) == 4u)
  assert(4u == 4u)
  arr: arc4.static_array<bytes[4], 8> = bzero(size_of(arc4.static_array<bytes[4], 8>))
  assert(size_of(arc4.static_array<bytes[4], 8>) == 32u)
  for v in arr {
    assert(v == bzero(4u))
  }
}

subroutine test_passing_fixed_bytes(): void
{
  assert(test_cases.fixed_bytes_ops.contract.bytes_to_bool(checked_maybe((reinterpret_cast<bytes[3]>(hex<"796179">), len(hex<"796179">) == 3u))))
  assert(!(test_cases.fixed_bytes_ops.contract.bytes_to_bool(hex<"6E6179">)))
  assert(test_cases.fixed_bytes_ops.contract.bool_to_bytes(true) == hex<"796179">)
  assert(test_cases.fixed_bytes_ops.contract.bool_to_bytes(false) == checked_maybe((reinterpret_cast<bytes[3]>(hex<"6E6179">), len(hex<"6E6179">) == 3u)))
}

subroutine bool_to_bytes(x: bool): bytes[3]
{
  return (x) ? (hex<"796179">) : (hex<"6E6179">)
}

subroutine bytes_to_bool(x: bytes[3]): bool
{
  return x == hex<"796179">
}

subroutine test_contains_fixed_bytes(x: bytes[4], y: bytes[2]): void
{
  assert(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), reinterpret_cast<bytes>(x)))
  assert(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(y), reinterpret_cast<bytes>(x)))
  assert(!(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), reinterpret_cast<bytes>(y))))
  assert(!(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), reinterpret_cast<bytes>(x))) == false)
  assert(!(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(y), reinterpret_cast<bytes>(x))) == false)
  assert(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), reinterpret_cast<bytes>(y)) == false)
}

subroutine test_contains_bytes(x: bytes[4], y: bytes): void
{
  assert(_puya_lib.bytes_.is_substring(y, reinterpret_cast<bytes>(x)))
  assert(!(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), y)))
  assert(!(_puya_lib.bytes_.is_substring(y, reinterpret_cast<bytes>(x))) == false)
  assert(_puya_lib.bytes_.is_substring(reinterpret_cast<bytes>(x), y) == false)
}

subroutine test_contains_literal_bytes(x: bytes[4]): void
{
  assert(_puya_lib.bytes_.is_substring(hex<"CD12">, reinterpret_cast<bytes>(x)))
  assert(!(_puya_lib.bytes_.is_substring(hex<"CD12">, reinterpret_cast<bytes>(x))) == false)
}

contract FixedBytesABI
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
    algopy._contract.Contract,
  )
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  abimethod test_cases.fixed_bytes_ops.abi_values.FixedBytesABI.test_passing_fixed_bytes(): void
  {
    app: application = submit_txn(create_inner_transaction(Fee=0u, TypeEnum=appl, ApprovalProgramPages=(SINGLE_EVAL(id=4, source=SINGLE_EVAL(id=3, source=compiled_contract(test_cases.fixed_bytes_ops.abi_values.CheckABIApp,,, prefix=None, variables={})).approval_program)[0], SINGLE_EVAL(id=4)[1]), ClearStateProgramPages=(SINGLE_EVAL(id=5, source=SINGLE_EVAL(id=3).clear_state_program)[0], SINGLE_EVAL(id=5)[1]), ExtraProgramPages=SINGLE_EVAL(id=3).extra_program_pages, GlobalNumByteSlice=SINGLE_EVAL(id=3).global_bytes, GlobalNumUint=SINGLE_EVAL(id=3).global_uints, LocalNumByteSlice=SINGLE_EVAL(id=3).local_bytes, LocalNumUint=SINGLE_EVAL(id=3).local_uints)).CreatedApplicationID
    submit_txn(create_inner_transaction(Fee=0u, TypeEnum=appl, ApplicationArgs=(Method("check_fixed_bytes(byte[11],byte[])void"), arc4_encode(hex<"48656C6C6F20576F726C64">, arc4.static_array<arc4.uint8, 11>), arc4_encode(hex<"48656C6C6F20576F726C64">, arc4.dynamic_array<arc4.uint8>)), ApplicationID=app))
  }
  
  baremethod test_cases.fixed_bytes_ops.abi_values.FixedBytesABI.__algopy_default_create(): void
  {
  }
  
  subroutine algopy._contract.Contract.__init__(): void
  {
  }
}

contract CheckABIApp
{
  method_resolution_order: (
    algopy.arc4.ARC4Contract,
    algopy._contract.Contract,
  )
  
  subroutine algopy.arc4.ARC4Contract.approval_program(): bool
  {
    return arc4_router()
  }
  
  subroutine algopy.arc4.ARC4Contract.clear_state_program(): bool
  {
    return true
  }
  
  abimethod test_cases.fixed_bytes_ops.abi_values.CheckABIApp.check_fixed_bytes(value: bytes[11], expected: bytes): void
  {
    assert(reinterpret_cast<bytes>(value) == expected, comment="expected to encode correctly")
  }
  
  baremethod test_cases.fixed_bytes_ops.abi_values.CheckABIApp.__algopy_default_create(): void
  {
  }
  
  subroutine algopy._contract.Contract.__init__(): void
  {
  }
}