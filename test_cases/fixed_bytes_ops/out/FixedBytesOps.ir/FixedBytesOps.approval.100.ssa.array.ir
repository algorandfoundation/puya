main test_cases.fixed_bytes_ops.contract.FixedBytesOps.approval_program:
    block@0: // L26
        let tmp%1#0: uint64 = (txn NumAppArgs)
        goto tmp%1#0 ? block@3 : block@33
    block@3: // if_body_L28
        let method#0: bytes = (txna ApplicationArgs 0)
        let tmp%4#0: uint64 = (txn NumAppArgs)
        let tmp%5#0: bool = (== tmp%4#0 1u)
        goto tmp%5#0 ? block@4 : block@10
    block@4: // if_body_L30
        let tmp%6#0: bool = (== method#0 0x6765745f73746174655f646174615f6f725f617373657274)
        goto tmp%6#0 ? block@5 : block@6
    block@5: // if_body_L31
        let for_account#1: account = (txn Sender)
        let (result#28: bytes[4], exists#0: bool) = (app_local_get_ex for_account#1 0u "local")
        (assert exists#0) // no data for account
        (log result#28)
        goto block@34
    block@6: // else_body_L32
        let tmp%9#0: bool = (== method#0 0x6765745f626f785f64617461)
        goto tmp%9#0 ? block@7 : block@34
    block@7: // if_body_L33
        let (aggregate%box_get%0#0: bytes, aggregate%box_get%1#0: bool) = (box_get "box")
        (assert aggregate%box_get%1#0) // check self.box exists
        let storage_value%0#0: bytes = aggregate%box_get%0#0
        (log storage_value%0#0)
        goto block@34
    block@10: // else_body_L34
        let tmp%10#0: uint64 = (txn NumAppArgs)
        let tmp%11#0: bool = (== tmp%10#0 2u)
        goto tmp%11#0 ? block@11 : block@20
    block@11: // if_body_L35
        let tmp%12#0: bool = (== method#0 0x7365745f73746174655f64617461)
        goto tmp%12#0 ? block@12 : block@13
    block@12: // if_body_L36
        let for_account#0: account = (txn Sender)
        let value#0: bytes[4] = (txna ApplicationArgs 1)
        (app_local_put for_account#0 "local" value#0)
        goto block@34
    block@13: // else_body_L40
        let tmp%14#0: bool = (== method#0 0x7365745f626f785f64617461)
        goto tmp%14#0 ? block@14 : block@15
    block@14: // if_body_L41
        let awst_tmp%0#0: bytes = (txna ApplicationArgs 1)
        let tmp%15#0: uint64 = (len awst_tmp%0#0)
        let tmp%16#0: bool = (== tmp%15#0 5u)
        (assert tmp%16#0) // expected bytes to be length 5
        (box_put "box" awst_tmp%0#0)
        goto block@34
    block@15: // else_body_L42
        let tmp%17#0: bool = (== method#0 0x76616c69646174655f66697865645f62797465735f33)
        goto tmp%17#0 ? block@16 : block@34
    block@16: // if_body_L43
        let val#9: bytes[3] = (txna ApplicationArgs 1)
        let len%0#0: uint64 = (len val#9)
        let eq%0#0: bool = (== len%0#0 3u)
        (assert eq%0#0) // invalid number of bytes for arc4.static_array<arc4.uint8, 3>
        goto block@34
    block@20: // else_body_L46
        let tmp%18#0: uint64 = (txn NumAppArgs)
        let tmp%19#0: bool = (== tmp%18#0 3u)
        goto tmp%19#0 ? block@21 : block@34
    block@21: // if_body_L47
        let tmp%20#0: bool = (== method#0 0x746573745f6175676d656e7465645f6f725f61737369676e6d656e745f776974685f6279746573)
        goto tmp%20#0 ? block@22 : block@23
    block@22: // if_body_L48
        let val#8: bytes[1] = (txna ApplicationArgs 1)
        let other#5: bytes = (txna ApplicationArgs 2)
        let tmp%0#20: uint64 = (len other#5)
        let tmp%1#20: bool = (== tmp%0#20 1u)
        (assert tmp%1#20) // expected bytes to be length 1
        let val1#14: bytes[1] = (b| val#8 other#5)
        (log val1#14)
        goto block@34
    block@23: // else_body_L52
        let tmp%22#0: bool = (== method#0 0x746573745f6175676d656e7465645f616e645f61737369676e6d656e745f776974685f6279746573)
        goto tmp%22#0 ? block@24 : block@25
    block@24: // if_body_L53
        let val#7: bytes[1] = (txna ApplicationArgs 1)
        let other#4: bytes = (txna ApplicationArgs 2)
        let tmp%0#19: uint64 = (len other#4)
        let tmp%1#19: bool = (== tmp%0#19 1u)
        (assert tmp%1#19) // expected bytes to be length 1
        let val1#12: bytes[1] = (b& val#7 other#4)
        (log val1#12)
        goto block@34
    block@25: // else_body_L57
        let tmp%24#0: bool = (== method#0 0x746573745f6175676d656e7465645f786f725f61737369676e6d656e745f776974685f6279746573)
        goto tmp%24#0 ? block@26 : block@34
    block@26: // if_body_L58
        let val#6: bytes[1] = (txna ApplicationArgs 1)
        let other#3: bytes = (txna ApplicationArgs 2)
        let tmp%0#18: uint64 = (len other#3)
        let tmp%1#18: bool = (== tmp%0#18 1u)
        (assert tmp%1#18) // expected bytes to be length 1
        let val1#10: bytes[1] = (b^ val#6 other#3)
        (log val1#10)
        goto block@34
    block@33: // else_body_L63
        test_cases.fixed_bytes_ops.contract.test_sequence_ops(0xabcd1234)
        test_cases.fixed_bytes_ops.contract.test_sequence_ops(0xabcd12345678)
        let empty_1#0: bytes[4] = (bzero 4u)
        let tmp%12#6: uint64 = (txn ApplicationID)
        let tmp%13#6: bool = (== tmp%12#6 123u)
        let abc#0: bytes[3] = (select 0x616263 0x313233 tmp%13#6)
        let tmp%14#6: uint64 = (len abc#0)
        let tmp%15#6: bool = (== tmp%14#6 3u)
        (assert tmp%15#6)
        let result#25: bytes = 0x
        let item_index_internal%0#0: uint64 = 0u
        goto block@58
    block@58: // for_header_L537
        let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@33, item_index_internal%0#2 <- block@59)
        let result#26: bytes = φ(result#25 <- block@33, result#27 <- block@59)
        let continue_looping%0#0: bool = (< item_index_internal%0#1 3u)
        goto continue_looping%0#0 ? block@59 : block@61
    block@59: // for_body_L538
        let item#0: bytes = (extract3 0xabcdef item_index_internal%0#1 1u)
        let result#27: bytes = (concat result#26 item#0)
        let item_index_internal%0#2: uint64 = (+ item_index_internal%0#1 1u)
        goto block@58
    block@61: // after_for_L537
        let tmp%1#12: bool = (== 0xabcdef result#26)
        (assert tmp%1#12)
        let item_index_internal%1#0: uint64 = 0u
        goto block@62
    block@62: // for_header_L541
        let idx#0: uint64 = φ(item_index_internal%1#0 <- block@61, item_index_internal%1#2 <- block@63)
        let continue_looping%1#0: bool = (< idx#0 3u)
        goto continue_looping%1#0 ? block@63 : block@65
    block@63: // for_body_L542
        let byte#0: bytes = (extract3 0xabcdef idx#0 1u)
        let tmp%3#11: uint64 = (len byte#0)
        let tmp%4#11: bool = (== tmp%3#11 1u)
        (assert tmp%4#11) // expected bytes to be length 1
        let tmp%6#9: bool = _puya_lib.bytes_.is_substring(byte#0, 0xabcdef)
        (assert tmp%6#9)
        let tmp%9#9: bool = _puya_lib.bytes_.is_substring(byte#0, 0xabcdef)
        (assert tmp%9#9)
        let item_index_internal%1#2: uint64 = (+ idx#0 1u)
        goto block@62
    block@65: // after_for_L541
        let arr#0: Encoded(uint8[4][8]) = (bzero 32u)
        let array_length%0#0: uint64 = 8u
        let item_index_internal%0#3: uint64 = 0u
        goto block@68
    block@68: // for_header_L579
        let item_index_internal%0#4: uint64 = φ(item_index_internal%0#3 <- block@65, item_index_internal%0#5 <- block@69)
        let continue_looping%0#1: bool = (< item_index_internal%0#4 array_length%0#0)
        goto continue_looping%0#1 ? block@69 : block@71
    block@69: // for_body_L580
        let aggregate%bytes_offset%0#0: uint64 = (* item_index_internal%0#4 4u)
        let aggregate%encoded_element%0#0: bytes = (extract3 arr#0 aggregate%bytes_offset%0#0 4u) // on error: index access is out of bounds
        let array_item%0#0: Encoded(uint8[4]) = aggregate%encoded_element%0#0
        let v#0: bytes[4] = array_item%0#0
        let tmp%15#7: bool = (== v#0 empty_1#0)
        (assert tmp%15#7)
        let item_index_internal%0#5: uint64 = (+ item_index_internal%0#4 1u)
        goto block@68
    block@71: // after_for_L579
        let tmp%0#15: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xabcd1234)
        (assert tmp%0#15)
        let tmp%1#15: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        (assert tmp%1#15)
        let tmp%2#14: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xcd12)
        let tmp%3#14: bool = (! tmp%2#14)
        (assert tmp%3#14)
        let tmp%4#14: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xabcd1234)
        let tmp%5#14: bool = (! tmp%4#14)
        let tmp%6#12: bool = (! tmp%5#14)
        (assert tmp%6#12)
        let tmp%7#12: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        let tmp%8#12: bool = (! tmp%7#12)
        let tmp%9#12: bool = (! tmp%8#12)
        (assert tmp%9#12)
        let tmp%10#11: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xcd12)
        let tmp%11#10: bool = (! tmp%10#11)
        (assert tmp%11#10)
        let tmp%0#16: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        (assert tmp%0#16)
        let tmp%1#16: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xcd12)
        let tmp%2#15: bool = (! tmp%1#16)
        (assert tmp%2#15)
        let tmp%3#15: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        let tmp%4#15: bool = (! tmp%3#15)
        let tmp%5#15: bool = (! tmp%4#15)
        (assert tmp%5#15)
        let tmp%6#13: bool = _puya_lib.bytes_.is_substring(0xabcd1234, 0xcd12)
        let tmp%7#13: bool = (! tmp%6#13)
        (assert tmp%7#13)
        let tmp%0#17: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        (assert tmp%0#17)
        let tmp%1#17: bool = _puya_lib.bytes_.is_substring(0xcd12, 0xabcd1234)
        let tmp%2#16: bool = (! tmp%1#17)
        let tmp%3#16: bool = (! tmp%2#16)
        (assert tmp%3#16)
        (log 0x68656c6c6f)
        goto block@34
    block@34: // after_if_else_L27
        return 1u

subroutine _puya_lib.bytes_.is_substring(item: bytes, sequence: bytes) -> bool:
    block@0: // L5
        let start#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L13
        let start#1: uint64 = φ(start#0 <- block@0, start#2 <- block@4)
        let tmp%0#0: uint64 = (len item#0)
        let tmp%1#0: uint64 = (+ start#1 tmp%0#0)
        let tmp%2#0: uint64 = (len sequence#0)
        let tmp%3#0: bool = (<= tmp%1#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@5
    block@2: // while_body_L14
        let tmp%6#0: bytes = (substring3 sequence#0 start#1 tmp%1#0)
        let tmp%7#0: bool = (== item#0 tmp%6#0)
        goto tmp%7#0 ? block@3 : block@4
    block@3: // if_body_L15
        return 1u
    block@4: // after_if_else_L14
        let start#2: uint64 = (+ start#1 1u)
        goto block@1
    block@5: // after_while_L13
        return 0u

subroutine test_cases.fixed_bytes_ops.contract.test_sequence_ops(val: bytes[4]) -> void:
    block@0: // L441
        let first_byte#0: bytes = ((extract 0 1) val#0)
        let tmp%1#0: bool = (== first_byte#0 0xab)
        (assert tmp%1#0)
        let last_byte#0: bytes = ((extract 3 1) val#0)
        let tmp%2#0: bool = (== last_byte#0 0x34)
        (assert tmp%2#0)
        let slice_result#0: bytes = ((substring 1 3) val#0)
        let tmp%6#0: bool = (== slice_result#0 0xcd12)
        (assert tmp%6#0)
        let slice_result#1: bytes = ((substring 0 2) val#0)
        let tmp%8#0: bool = (== slice_result#1 0xabcd)
        (assert tmp%8#0)
        let slice_result#2: bytes = ((substring 2 4) val#0)
        let tmp%10#0: bool = (== slice_result#2 0x1234)
        (assert tmp%10#0)
        let slice_result#3: bytes = ((substring 0 3) val#0)
        let tmp%12#0: bool = (== slice_result#3 0xabcd12)
        (assert tmp%12#0)
        let count#0: uint64 = 0u
        let item_index_internal%0#0: uint64 = 0u
        goto block@1
    block@1: // for_header_L477
        let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@0, item_index_internal%0#2 <- block@2)
        let count#1: uint64 = φ(count#0 <- block@0, count#2 <- block@2)
        let continue_looping%0#0: bool = (< item_index_internal%0#1 4u)
        goto continue_looping%0#0 ? block@2 : block@4
    block@2: // for_body_L478
        let count#2: uint64 = (+ count#1 1u)
        let item_index_internal%0#2: uint64 = (+ item_index_internal%0#1 1u)
        goto block@1
    block@4: // after_for_L477
        let tmp%18#0: bool = (== count#1 4u)
        (assert tmp%18#0)
        let count#3: uint64 = 0u
        let reverse_index_internal%1#0: uint64 = 4u
        goto block@5
    block@5: // for_header_L483
        let reverse_index_internal%1#1: uint64 = φ(reverse_index_internal%1#0 <- block@4, reverse_index_internal%1#2 <- block@6)
        let count#4: uint64 = φ(count#3 <- block@4, count#5 <- block@6)
        goto reverse_index_internal%1#1 ? block@6 : block@8
    block@6: // for_body_L484
        let reverse_index_internal%1#2: uint64 = (- reverse_index_internal%1#1 1u)
        let count#5: uint64 = (+ count#4 1u)
        goto block@5
    block@8: // after_for_L483
        let tmp%20#0: bool = (== count#4 4u)
        (assert tmp%20#0)
        return 