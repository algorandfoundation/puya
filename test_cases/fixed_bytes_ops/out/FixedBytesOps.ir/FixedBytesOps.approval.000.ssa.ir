main test_cases.fixed_bytes_ops.contract.FixedBytesOps.approval_program:
    block@0: // L26
        let tmp%0#0: bool = (txn ApplicationID)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // call __init___L1
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.__init__()
        goto block@2
    block@2: // after_if_else_L1
        let tmp%1#0: uint64 = (txn NumAppArgs)
        let tmp%2#0: bool = (> tmp%1#0 0u)
        goto tmp%2#0 ? block@3 : block@33
    block@3: // if_body_L28
        let tmp%3#0: bytes = (txna ApplicationArgs 0)
        let method#0: bytes = tmp%3#0
        let tmp%4#0: uint64 = (txn NumAppArgs)
        let tmp%5#0: bool = (== tmp%4#0 1u)
        goto tmp%5#0 ? block@4 : block@10
    block@4: // if_body_L30
        let tmp%6#0: bool = (== method#0 0x6765745f73746174655f646174615f6f725f617373657274)
        goto tmp%6#0 ? block@5 : block@6
    block@5: // if_body_L31
        let tmp%7#0: account = (txn Sender)
        let tmp%8#0: bytes[4] = test_cases.fixed_bytes_ops.contract.FixedBytesOps.get_state_data_or_assert(tmp%7#0)
        (log tmp%8#0)
        goto block@9
    block@6: // else_body_L32
        let tmp%9#0: bool = (== method#0 0x6765745f626f785f64617461)
        goto tmp%9#0 ? block@7 : block@8
    block@7: // if_body_L33
        let storage_value%0#0: bytes = box_read("box")
        (log storage_value%0#0)
        goto block@8
    block@8: // after_if_else_L32
        goto block@9
    block@9: // after_if_else_L30
        goto block@32
    block@10: // else_body_L34
        let tmp%10#0: uint64 = (txn NumAppArgs)
        let tmp%11#0: bool = (== tmp%10#0 2u)
        goto tmp%11#0 ? block@11 : block@20
    block@11: // if_body_L35
        let tmp%12#0: bool = (== method#0 0x7365745f73746174655f64617461)
        goto tmp%12#0 ? block@12 : block@13
    block@12: // if_body_L36
        let tmp%13#0: account = (txn Sender)
        let reinterpret_bytes[4]%0#0: bytes[4] = (txna ApplicationArgs 1)
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.set_state_data(tmp%13#0, reinterpret_bytes[4]%0#0)
        goto block@19
    block@13: // else_body_L40
        let tmp%14#0: bool = (== method#0 0x7365745f626f785f64617461)
        goto tmp%14#0 ? block@14 : block@15
    block@14: // if_body_L41
        let awst_tmp%0#0: bytes = (txna ApplicationArgs 1)
        let reinterpret_bytes[5]%0#0: bytes[5] = awst_tmp%0#0
        let tmp%15#0: uint64 = (len awst_tmp%0#0)
        let tmp%16#0: bool = (== tmp%15#0 5u)
        (assert tmp%16#0) // expected bytes to be length 5
        box_write("box", reinterpret_bytes[5]%0#0)
        goto block@18
    block@15: // else_body_L42
        let tmp%17#0: bool = (== method#0 0x76616c69646174655f66697865645f62797465735f33)
        goto tmp%17#0 ? block@16 : block@17
    block@16: // if_body_L43
        let reinterpret_bytes[3]%0#0: bytes[3] = (txna ApplicationArgs 1)
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.validate_fixed_bytes_3(reinterpret_bytes[3]%0#0)
        goto block@17
    block@17: // after_if_else_L42
        goto block@18
    block@18: // after_if_else_L40
        goto block@19
    block@19: // after_if_else_L35
        goto block@31
    block@20: // else_body_L46
        let tmp%18#0: uint64 = (txn NumAppArgs)
        let tmp%19#0: bool = (== tmp%18#0 3u)
        goto tmp%19#0 ? block@21 : block@30
    block@21: // if_body_L47
        let tmp%20#0: bool = (== method#0 0x746573745f6175676d656e7465645f6f725f61737369676e6d656e745f776974685f6279746573)
        goto tmp%20#0 ? block@22 : block@23
    block@22: // if_body_L48
        let reinterpret_bytes[1]%0#0: bytes[1] = (txna ApplicationArgs 1)
        let tmp%21#0: bytes = (txna ApplicationArgs 2)
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_or_assignment_with_bytes(reinterpret_bytes[1]%0#0, tmp%21#0)
        goto block@29
    block@23: // else_body_L52
        let tmp%22#0: bool = (== method#0 0x746573745f6175676d656e7465645f616e645f61737369676e6d656e745f776974685f6279746573)
        goto tmp%22#0 ? block@24 : block@25
    block@24: // if_body_L53
        let reinterpret_bytes[1]%1#0: bytes[1] = (txna ApplicationArgs 1)
        let tmp%23#0: bytes = (txna ApplicationArgs 2)
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_and_assignment_with_bytes(reinterpret_bytes[1]%1#0, tmp%23#0)
        goto block@28
    block@25: // else_body_L57
        let tmp%24#0: bool = (== method#0 0x746573745f6175676d656e7465645f786f725f61737369676e6d656e745f776974685f6279746573)
        goto tmp%24#0 ? block@26 : block@27
    block@26: // if_body_L58
        let reinterpret_bytes[1]%2#0: bytes[1] = (txna ApplicationArgs 1)
        let tmp%25#0: bytes = (txna ApplicationArgs 2)
        test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_xor_assignment_with_bytes(reinterpret_bytes[1]%2#0, tmp%25#0)
        goto block@27
    block@27: // after_if_else_L57
        goto block@28
    block@28: // after_if_else_L52
        goto block@29
    block@29: // after_if_else_L47
        goto block@30
    block@30: // after_if_else_L46
        goto block@31
    block@31: // after_if_else_L34
        goto block@32
    block@32: // after_if_else_L29
        goto block@34
    block@33: // else_body_L63
        test_cases.fixed_bytes_ops.contract.test_binary_ops(0xff, 0x0f)
        test_cases.fixed_bytes_ops.contract.test_binary_ops_with_fixed_bytes_of_different_size(0xff, 0x0f0f)
        test_cases.fixed_bytes_ops.contract.test_binary_ops_with_bytes_of_different_size(0xff, 0x0f0f)
        test_cases.fixed_bytes_ops.contract.test_binary_ops_with_literal_bytes(0xff)
        let reinterpret_bytes[3]%1#0: bytes[3] = 0xf0f0f0f0
        let reinterpret_bytes[3]%2#0: bytes[3] = 0x0f0f
        test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_invalid_lengths(reinterpret_bytes[3]%1#0, reinterpret_bytes[3]%2#0)
        test_cases.fixed_bytes_ops.contract.test_augmented_assignment(0xf0, 0x0f)
        test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_bytes(0xf0, 0x0f)
        test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_literal_bytes(0xf0)
        test_cases.fixed_bytes_ops.contract.test_unary_ops()
        test_cases.fixed_bytes_ops.contract.test_comparison_ops()
        test_cases.fixed_bytes_ops.contract.test_sequence_ops(0xabcd1234)
        let reinterpret_bytes[4]%1#0: bytes[4] = 0xabcd12345678
        test_cases.fixed_bytes_ops.contract.test_sequence_ops(reinterpret_bytes[4]%1#0)
        test_cases.fixed_bytes_ops.contract.test_construction()
        test_cases.fixed_bytes_ops.contract.test_iteration()
        test_cases.fixed_bytes_ops.contract.test_size_of()
        test_cases.fixed_bytes_ops.contract.test_passing_fixed_bytes()
        test_cases.fixed_bytes_ops.contract.test_contains_fixed_bytes(0xabcd1234, 0xcd12)
        test_cases.fixed_bytes_ops.contract.test_contains_bytes(0xabcd1234, 0xcd12)
        test_cases.fixed_bytes_ops.contract.test_contains_literal_bytes(0xabcd1234)
        let result#0: bytes[5] = 0x68656c6c6f
        (log result#0)
        goto block@34
    block@34: // after_if_else_L27
        return 1u

subroutine _puya_lib.bytes_.is_substring(item: bytes, sequence: bytes) -> bool:
    block@0: // L5
        let start#0: uint64 = 0u
        goto block@1
    block@1: // while_top_L13
        let start#1: uint64 = φ(start#0 <- block@0, start#2 <- block@4)
        let tmp%0#0: uint64 = (len item#0)
        let tmp%1#0: uint64 = (+ start#1 tmp%0#0)
        let tmp%2#0: uint64 = (len sequence#0)
        let tmp%3#0: bool = (<= tmp%1#0 tmp%2#0)
        goto tmp%3#0 ? block@2 : block@5
    block@2: // while_body_L14
        let tmp%4#0: uint64 = (len item#0)
        let tmp%5#0: uint64 = (+ start#1 tmp%4#0)
        let tmp%6#0: bytes = (substring3 sequence#0 start#1 tmp%5#0)
        let tmp%7#0: bool = (== item#0 tmp%6#0)
        goto tmp%7#0 ? block@3 : block@4
    block@3: // if_body_L15
        return 1u
    block@4: // after_if_else_L14
        let tmp%8#0: uint64 = (+ start#1 1u)
        let start#2: uint64 = tmp%8#0
        goto block@1
    block@5: // after_while_L13
        return 0u

subroutine test_cases.fixed_bytes_ops.contract.test_binary_ops(left: bytes[1], right: bytes[1]) -> void:
    block@0: // L158
        let tmp%0#0: bytes = (b| left#0 right#0)
        let result#0: bytes[1] = tmp%0#0
        let tmp%1#0: bool = (== result#0 0xff)
        (assert tmp%1#0)
        let tmp%2#0: bytes = (b| right#0 left#0)
        let result#1: bytes[1] = tmp%2#0
        let tmp%3#0: bool = (== result#1 0xff)
        (assert tmp%3#0)
        let tmp%4#0: bytes = (b^ left#0 right#0)
        let result#2: bytes[1] = tmp%4#0
        let tmp%5#0: bool = (== result#2 0xf0)
        (assert tmp%5#0)
        let tmp%6#0: bytes = (b^ right#0 left#0)
        let result#3: bytes[1] = tmp%6#0
        let tmp%7#0: bool = (== result#3 0xf0)
        (assert tmp%7#0)
        let tmp%8#0: bytes = (b& left#0 right#0)
        let result#4: bytes[1] = tmp%8#0
        let tmp%9#0: bool = (== result#4 0x0f)
        (assert tmp%9#0)
        let tmp%10#0: bytes = (b& right#0 left#0)
        let result#5: bytes[1] = tmp%10#0
        let tmp%11#0: bool = (== result#5 0x0f)
        (assert tmp%11#0)
        let tmp%12#0: bytes = (concat left#0 right#0)
        let concat_result#0: bytes = tmp%12#0
        let tmp%13#0: bool = (== concat_result#0 0xff0f)
        (assert tmp%13#0)
        let tmp%14#0: bytes = (concat right#0 left#0)
        let concat_result#1: bytes = tmp%14#0
        let tmp%15#0: bool = (== concat_result#1 0x0fff)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_binary_ops_with_fixed_bytes_of_different_size(left: bytes[1], right: bytes[2]) -> void:
    block@0: // L197
        let tmp%0#0: bytes = (b| left#0 right#0)
        let result#0: bytes = tmp%0#0
        let tmp%1#0: bool = (== result#0 0x0fff)
        (assert tmp%1#0)
        let tmp%2#0: bytes = (b| right#0 left#0)
        let result#1: bytes = tmp%2#0
        let tmp%3#0: bool = (== result#1 0x0fff)
        (assert tmp%3#0)
        let tmp%4#0: bytes = (b^ left#0 right#0)
        let result#2: bytes = tmp%4#0
        let tmp%5#0: bool = (== result#2 0x0ff0)
        (assert tmp%5#0)
        let tmp%6#0: bytes = (b^ right#0 left#0)
        let result#3: bytes = tmp%6#0
        let tmp%7#0: bool = (== result#3 0x0ff0)
        (assert tmp%7#0)
        let tmp%8#0: bytes = (b& left#0 right#0)
        let result#4: bytes = tmp%8#0
        let tmp%9#0: bool = (== result#4 0x000f)
        (assert tmp%9#0)
        let tmp%10#0: bytes = (b& right#0 left#0)
        let result#5: bytes = tmp%10#0
        let tmp%11#0: bool = (== result#5 0x000f)
        (assert tmp%11#0)
        let tmp%12#0: bytes = (concat left#0 right#0)
        let concat_result#0: bytes = tmp%12#0
        let tmp%13#0: bool = (== concat_result#0 0xff0f0f)
        (assert tmp%13#0)
        let tmp%14#0: bytes = (concat right#0 left#0)
        let concat_result#1: bytes = tmp%14#0
        let tmp%15#0: bool = (== concat_result#1 0x0f0fff)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_binary_ops_with_bytes_of_different_size(left: bytes[1], right: bytes) -> void:
    block@0: // L235
        let tmp%0#0: bytes = (b| left#0 right#0)
        let result#0: bytes = tmp%0#0
        let tmp%1#0: bool = (== result#0 0x0fff)
        (assert tmp%1#0)
        let tmp%2#0: bytes = (b| right#0 left#0)
        let result#1: bytes = tmp%2#0
        let tmp%3#0: bool = (== result#1 0x0fff)
        (assert tmp%3#0)
        let tmp%4#0: bytes = (b^ left#0 right#0)
        let result#2: bytes = tmp%4#0
        let tmp%5#0: bool = (== result#2 0x0ff0)
        (assert tmp%5#0)
        let tmp%6#0: bytes = (b^ right#0 left#0)
        let result#3: bytes = tmp%6#0
        let tmp%7#0: bool = (== result#3 0x0ff0)
        (assert tmp%7#0)
        let tmp%8#0: bytes = (b& left#0 right#0)
        let result#4: bytes = tmp%8#0
        let tmp%9#0: bool = (== result#4 0x000f)
        (assert tmp%9#0)
        let tmp%10#0: bytes = (b& right#0 left#0)
        let result#5: bytes = tmp%10#0
        let tmp%11#0: bool = (== result#5 0x000f)
        (assert tmp%11#0)
        let tmp%12#0: bytes = (concat left#0 right#0)
        let concat_result#0: bytes = tmp%12#0
        let tmp%13#0: bool = (== concat_result#0 0xff0f0f)
        (assert tmp%13#0)
        let tmp%14#0: bytes = (concat right#0 left#0)
        let concat_result#1: bytes = tmp%14#0
        let tmp%15#0: bool = (== concat_result#1 0x0f0fff)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_binary_ops_with_literal_bytes(left: bytes[1]) -> void:
    block@0: // L274
        let tmp%0#0: bytes = (b| left#0 0x0f0f)
        let result#0: bytes = tmp%0#0
        let tmp%1#0: bool = (== result#0 0x0fff)
        (assert tmp%1#0)
        let tmp%2#0: bytes = (b| 0x0f0f left#0)
        let result#1: bytes = tmp%2#0
        let tmp%3#0: bool = (== result#1 0x0fff)
        (assert tmp%3#0)
        let tmp%4#0: bytes = (b^ left#0 0x0f0f)
        let result#2: bytes = tmp%4#0
        let tmp%5#0: bool = (== result#2 0x0ff0)
        (assert tmp%5#0)
        let tmp%6#0: bytes = (b^ 0x0f0f left#0)
        let result#3: bytes = tmp%6#0
        let tmp%7#0: bool = (== result#3 0x0ff0)
        (assert tmp%7#0)
        let tmp%8#0: bytes = (b& left#0 0x0f0f)
        let result#4: bytes = tmp%8#0
        let tmp%9#0: bool = (== result#4 0x000f)
        (assert tmp%9#0)
        let tmp%10#0: bytes = (b& 0x0f0f left#0)
        let result#5: bytes = tmp%10#0
        let tmp%11#0: bool = (== result#5 0x000f)
        (assert tmp%11#0)
        let tmp%12#0: bytes = (concat left#0 0x0f0f)
        let concat_result#0: bytes = tmp%12#0
        let tmp%13#0: bool = (== concat_result#0 0xff0f0f)
        (assert tmp%13#0)
        let tmp%14#0: bytes = (concat 0x0f0f left#0)
        let concat_result#1: bytes = tmp%14#0
        let tmp%15#0: bool = (== concat_result#1 0x0f0fff)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_invalid_lengths(val: bytes[3], other: bytes[3]) -> void:
    block@0: // L311
        let val1#0: bytes[3] = val#0
        let tmp%0#0: bytes = (b| val1#0 other#0)
        let val1#1: bytes[3] = tmp%0#0
        let tmp%1#0: bool = (== val1#1 0xf0f0ffff)
        (assert tmp%1#0)
        let val2#0: bytes[3] = val#0
        let tmp%2#0: bytes = (b& val2#0 other#0)
        let val2#1: bytes[3] = tmp%2#0
        let tmp%3#0: bool = (== val2#1 0x00000000)
        (assert tmp%3#0)
        let val3#0: bytes[3] = val#0
        let tmp%4#0: bytes = (b^ val3#0 other#0)
        let val3#1: bytes[3] = tmp%4#0
        let tmp%5#0: bool = (== val3#1 0xf0f0ffff)
        (assert tmp%5#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_augmented_assignment(val: bytes[1], other: bytes[1]) -> void:
    block@0: // L330
        let val1#0: bytes[1] = val#0
        let tmp%0#0: bytes = (b| val1#0 other#0)
        let val1#1: bytes[1] = tmp%0#0
        let tmp%1#0: bool = (== val1#1 0xff)
        (assert tmp%1#0)
        let val2#0: bytes[1] = val#0
        let tmp%2#0: bytes = (b& val2#0 other#0)
        let val2#1: bytes[1] = tmp%2#0
        let tmp%3#0: bool = (== val2#1 0x00)
        (assert tmp%3#0)
        let val3#0: bytes[1] = val#0
        let tmp%4#0: bytes = (b^ val3#0 other#0)
        let val3#1: bytes[1] = tmp%4#0
        let tmp%5#0: bool = (== val3#1 0xff)
        (assert tmp%5#0)
        let tmp%6#0: bytes = (concat val#0 0x74657374)
        let bytes_value#0: bytes = tmp%6#0
        let tmp%7#0: bytes = (concat bytes_value#0 other#0)
        let bytes_value#1: bytes = tmp%7#0
        let tmp%8#0: uint64 = (len bytes_value#1)
        let tmp%9#0: bool = (== tmp%8#0 6u)
        (assert tmp%9#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_bytes(val: bytes[1], other: bytes) -> void:
    block@0: // L355
        let val1#0: bytes[1] = val#0
        let reinterpret_bytes[1]%0#0: bytes[1] = other#0
        let tmp%0#0: uint64 = (len other#0)
        let tmp%1#0: bool = (== tmp%0#0 1u)
        (assert tmp%1#0) // expected bytes to be length 1
        let tmp%2#0: bytes = (b| val1#0 reinterpret_bytes[1]%0#0)
        let val1#1: bytes[1] = tmp%2#0
        let tmp%3#0: bool = (== val1#1 0xff)
        (assert tmp%3#0)
        let val2#0: bytes[1] = val#0
        let reinterpret_bytes[1]%1#0: bytes[1] = other#0
        let tmp%4#0: uint64 = (len other#0)
        let tmp%5#0: bool = (== tmp%4#0 1u)
        (assert tmp%5#0) // expected bytes to be length 1
        let tmp%6#0: bytes = (b& val2#0 reinterpret_bytes[1]%1#0)
        let val2#1: bytes[1] = tmp%6#0
        let tmp%7#0: bool = (== val2#1 0x00)
        (assert tmp%7#0)
        let val3#0: bytes[1] = val#0
        let reinterpret_bytes[1]%2#0: bytes[1] = other#0
        let tmp%8#0: uint64 = (len other#0)
        let tmp%9#0: bool = (== tmp%8#0 1u)
        (assert tmp%9#0) // expected bytes to be length 1
        let tmp%10#0: bytes = (b^ val3#0 reinterpret_bytes[1]%2#0)
        let val3#1: bytes[1] = tmp%10#0
        let tmp%11#0: bool = (== val3#1 0xff)
        (assert tmp%11#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_augmented_assignment_with_literal_bytes(val: bytes[1]) -> void:
    block@0: // L374
        let val1#0: bytes[1] = val#0
        let tmp%0#0: bytes = (b| val1#0 0x0f)
        let val1#1: bytes[1] = tmp%0#0
        let tmp%1#0: bool = (== val1#1 0xff)
        (assert tmp%1#0)
        let val2#0: bytes[1] = val#0
        let tmp%2#0: bytes = (b& val2#0 0x0f)
        let val2#1: bytes[1] = tmp%2#0
        let tmp%3#0: bool = (== val2#1 0x00)
        (assert tmp%3#0)
        let val3#0: bytes[1] = val#0
        let tmp%4#0: bytes = (b^ val3#0 0x0f)
        let val3#1: bytes[1] = tmp%4#0
        let tmp%5#0: bool = (== val3#1 0xff)
        (assert tmp%5#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_unary_ops() -> void:
    block@0: // L393
        let val#0: bytes[1] = 0x0f
        let tmp%0#0: bytes = (b~ val#0)
        let inverted#0: bytes[1] = tmp%0#0
        let tmp%1#0: bool = (== inverted#0 0xf0)
        (assert tmp%1#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_comparison_ops() -> void:
    block@0: // L403
        let val1#0: bytes[2] = 0xabcd
        let val2#0: bytes[2] = 0xabcd
        let val3#0: bytes[2] = 0x1234
        let tmp%0#0: bool = (== val1#0 val2#0)
        (assert tmp%0#0)
        let tmp%1#0: bool = (== val1#0 0xabcd)
        (assert tmp%1#0)
        let tmp%2#0: bool = (== val1#0 0xabcd)
        (assert tmp%2#0)
        let tmp%3#0: bool = (== val2#0 val1#0)
        (assert tmp%3#0)
        let tmp%4#0: bool = (== val1#0 0xabcd)
        (assert tmp%4#0)
        let tmp%5#0: bool = (== val1#0 0xabcd)
        (assert tmp%5#0)
        let tmp%6#0: bool = (!= val1#0 val3#0)
        (assert tmp%6#0)
        let tmp%7#0: bool = (!= val1#0 0x1234)
        (assert tmp%7#0)
        let tmp%8#0: bool = (!= val1#0 0x1234)
        (assert tmp%8#0)
        let tmp%9#0: bool = (!= val3#0 val1#0)
        (assert tmp%9#0)
        let tmp%10#0: bool = (!= val1#0 0x1234)
        (assert tmp%10#0)
        let tmp%11#0: bool = (!= val1#0 0x1234)
        (assert tmp%11#0)
        let reinterpret_bytes[3]%0#0: bytes[3] = 0xabcd123456
        let val4#0: bytes[3] = reinterpret_bytes[3]%0#0
        let tmp%12#0: bool = (== val4#0 0xabcd123456)
        (assert tmp%12#0)
        let tmp%13#0: bool = (== 3u 3u)
        (assert tmp%13#0)
        let val5#0: bytes[3] = 0xabcd12
        let tmp%14#0: bool = (!= val4#0 val5#0)
        (assert tmp%14#0)
        let reinterpret_bytes[2]%0#0: bytes[2] = 0xabcd12
        let val6#0: bytes[2] = reinterpret_bytes[2]%0#0
        let reinterpret_bytes[2]%1#0: bytes[2] = 0xabcd12
        let val7#0: bytes[2] = reinterpret_bytes[2]%1#0
        let tmp%15#0: bool = (== val6#0 val7#0)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_sequence_ops(val: bytes[4]) -> void:
    block@0: // L441
        let tmp%0#0: bool = (== 4u 4u)
        (assert tmp%0#0)
        let extract%0#0: bytes = (extract3 val#0 0u 1u)
        let first_byte#0: bytes = extract%0#0
        let tmp%1#0: bool = (== first_byte#0 0xab)
        (assert tmp%1#0)
        let extract%1#0: bytes = (extract3 val#0 3u 1u)
        let last_byte#0: bytes = extract%1#0
        let tmp%2#0: bool = (== last_byte#0 0x34)
        (assert tmp%2#0)
        let tmp%3#0: uint64 = (- 4u 1u)
        let extract%2#0: bytes = (extract3 val#0 tmp%3#0 1u)
        let tmp%4#0: bool = (== last_byte#0 extract%2#0)
        (assert tmp%4#0)
        let is_out_of_bounds%0#0: bool = (>= 1u 4u)
        let bounded_index%0#0: uint64 = (select 1u 4u is_out_of_bounds%0#0)
        let is_out_of_bounds%1#0: bool = (>= 3u 4u)
        let bounded_index%1#0: uint64 = (select 3u 4u is_out_of_bounds%1#0)
        let tmp%5#0: bytes = (substring3 val#0 bounded_index%0#0 bounded_index%1#0)
        let slice_result#0: bytes = tmp%5#0
        let tmp%6#0: bool = (== slice_result#0 0xcd12)
        (assert tmp%6#0)
        let is_out_of_bounds%2#0: bool = (>= 2u 4u)
        let bounded_index%2#0: uint64 = (select 2u 4u is_out_of_bounds%2#0)
        let tmp%7#0: bytes = (substring3 val#0 0u bounded_index%2#0)
        let slice_result#1: bytes = tmp%7#0
        let tmp%8#0: bool = (== slice_result#1 0xabcd)
        (assert tmp%8#0)
        let is_out_of_bounds%3#0: bool = (>= 2u 4u)
        let bounded_index%3#0: uint64 = (select 2u 4u is_out_of_bounds%3#0)
        let tmp%9#0: bytes = (substring3 val#0 bounded_index%3#0 4u)
        let slice_result#2: bytes = tmp%9#0
        let tmp%10#0: bool = (== slice_result#2 0x1234)
        (assert tmp%10#0)
        let is_out_of_bounds%4#0: bool = (>= 1u 4u)
        let bounded_offset%0#0: uint64 = (select 1u 4u is_out_of_bounds%4#0)
        let bounded_index%4#0: uint64 = (- 4u bounded_offset%0#0)
        let tmp%11#0: bytes = (substring3 val#0 0u bounded_index%4#0)
        let slice_result#3: bytes = tmp%11#0
        let tmp%12#0: bool = (== slice_result#3 0xabcd12)
        (assert tmp%12#0)
        let is_out_of_bounds%5#0: bool = (>= 2u 4u)
        let bounded_offset%1#0: uint64 = (select 2u 4u is_out_of_bounds%5#0)
        let bounded_index%5#0: uint64 = (- 4u bounded_offset%1#0)
        let tmp%13#0: bytes = (substring3 val#0 bounded_index%5#0 4u)
        let slice_result#4: bytes = tmp%13#0
        let tmp%14#0: bool = (== slice_result#4 0x1234)
        (assert tmp%14#0)
        let is_out_of_bounds%6#0: bool = (>= 3u 4u)
        let bounded_offset%2#0: uint64 = (select 3u 4u is_out_of_bounds%6#0)
        let bounded_index%6#0: uint64 = (- 4u bounded_offset%2#0)
        let is_out_of_bounds%7#0: bool = (>= 1u 4u)
        let bounded_offset%3#0: uint64 = (select 1u 4u is_out_of_bounds%7#0)
        let bounded_index%7#0: uint64 = (- 4u bounded_offset%3#0)
        let tmp%15#0: bytes = (substring3 val#0 bounded_index%6#0 bounded_index%7#0)
        let slice_result#5: bytes = tmp%15#0
        let tmp%16#0: bool = (== slice_result#5 0xcd12)
        (assert tmp%16#0)
        let count#0: uint64 = 0u
        let bytes_length%0#0: uint64 = 4u
        let item_index_internal%0#0: uint64 = 0u
        let reverse_index_internal%0#0: uint64 = bytes_length%0#0
        goto block@1
    block@1: // for_header_L477
        let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@0, item_index_internal%0#2 <- block@3)
        let count#1: uint64 = φ(count#0 <- block@0, count#2 <- block@3)
        let continue_looping%0#0: bool = (< item_index_internal%0#1 bytes_length%0#0)
        goto continue_looping%0#0 ? block@2 : block@4
    block@2: // for_body_L478
        let _byte#0: bytes = (extract3 val#0 item_index_internal%0#1 1u)
        let tmp%17#0: uint64 = (+ count#1 1u)
        let count#2: uint64 = tmp%17#0
        goto block@3
    block@3: // for_footer_L477
        let item_index_internal%0#2: uint64 = (+ item_index_internal%0#1 1u)
        goto block@1
    block@4: // after_for_L477
        let tmp%18#0: bool = (== count#1 4u)
        (assert tmp%18#0)
        let count#3: uint64 = 0u
        let bytes_length%1#0: uint64 = 4u
        let item_index_internal%1#0: uint64 = 0u
        let reverse_index_internal%1#0: uint64 = bytes_length%1#0
        goto block@5
    block@5: // for_header_L483
        let reverse_index_internal%1#1: uint64 = φ(reverse_index_internal%1#0 <- block@4, reverse_index_internal%1#2 <- block@7)
        let count#4: uint64 = φ(count#3 <- block@4, count#5 <- block@7)
        let continue_looping%1#0: bool = (> reverse_index_internal%1#1 0u)
        goto continue_looping%1#0 ? block@6 : block@8
    block@6: // for_body_L484
        let reverse_index_internal%1#2: uint64 = (- reverse_index_internal%1#1 1u)
        let _byte#1: bytes = (extract3 val#0 reverse_index_internal%1#2 1u)
        let tmp%19#0: uint64 = (+ count#4 1u)
        let count#5: uint64 = tmp%19#0
        goto block@7
    block@7: // for_footer_L483
        goto block@5
    block@8: // after_for_L483
        let tmp%20#0: bool = (== count#4 4u)
        (assert tmp%20#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_construction() -> void:
    block@0: // L488
        let hex_val#0: bytes[2] = 0xabcd
        let tmp%0#0: bool = (== hex_val#0 0xabcd)
        (assert tmp%0#0)
        let base64_val#0: bytes[2] = q80=
        let tmp%1#0: bool = (== base64_val#0 0xabcd)
        (assert tmp%1#0)
        let base32_val#0: bytes[2] = VPGQ
        let tmp%2#0: bool = (== base32_val#0 0xabcd)
        (assert tmp%2#0)
        let direct_val#0: bytes[2] = 0xabcd
        let tmp%3#0: bool = (== direct_val#0 0xabcd)
        (assert tmp%3#0)
        let bytes_val#0: bytes = hex_val#0
        let tmp%4#0: bool = (== bytes_val#0 0xabcd)
        (assert tmp%4#0)
        let from_bytes_val#0: bytes[2] = 0xabcd
        let tmp%5#0: bool = (== from_bytes_val#0 0xabcd)
        (assert tmp%5#0)
        let awst_tmp%0#0: account = (txn Sender)
        let reinterpret_bytes[32]%0#0: bytes[32] = awst_tmp%0#0
        let tmp%6#0: uint64 = (len awst_tmp%0#0)
        let tmp%7#0: bool = (== tmp%6#0 32u)
        (assert tmp%7#0) // expected bytes to be length 32
        let from_txn_sender#0: bytes[32] = reinterpret_bytes[32]%0#0
        let tmp%8#0: bool = (== 32u 32u)
        (assert tmp%8#0)
        let tmp%9#0: bytes[4] = (bzero 4u)
        let empty_1#0: bytes[4] = tmp%9#0
        let tmp%10#0: bool = (== empty_1#0 0x00000000)
        (assert tmp%10#0)
        let empty_2#0: bytes[0] = 0x
        let tmp%11#0: bool = (== empty_2#0 0x)
        (assert tmp%11#0)
        let tmp%12#0: uint64 = (txn ApplicationID)
        let tmp%13#0: bool = (== tmp%12#0 123u)
        let select%0#0: bytes[3] = (select 0x616263 0x313233 tmp%13#0)
        let abc#0: bytes[3] = select%0#0
        let tmp%14#0: uint64 = (len abc#0)
        let tmp%15#0: bool = (== tmp%14#0 3u)
        (assert tmp%15#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_iteration() -> void:
    block@0: // L531
        let val#0: bytes[3] = 0xabcdef
        let result#0: bytes = 0x
        let bytes_length%0#0: uint64 = 3u
        let item_index_internal%0#0: uint64 = 0u
        let reverse_index_internal%0#0: uint64 = bytes_length%0#0
        goto block@1
    block@1: // for_header_L537
        let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@0, item_index_internal%0#2 <- block@3)
        let result#1: bytes = φ(result#0 <- block@0, result#2 <- block@3)
        let continue_looping%0#0: bool = (< item_index_internal%0#1 bytes_length%0#0)
        goto continue_looping%0#0 ? block@2 : block@4
    block@2: // for_body_L538
        let item#0: bytes = (extract3 val#0 item_index_internal%0#1 1u)
        let tmp%0#0: bytes = (concat result#1 item#0)
        let result#2: bytes = tmp%0#0
        goto block@3
    block@3: // for_footer_L537
        let item_index_internal%0#2: uint64 = (+ item_index_internal%0#1 1u)
        goto block@1
    block@4: // after_for_L537
        let tmp%1#0: bool = (== val#0 result#1)
        (assert tmp%1#0)
        let bytes_length%1#0: uint64 = 3u
        let item_index_internal%1#0: uint64 = 0u
        let reverse_index_internal%1#0: uint64 = bytes_length%1#0
        goto block@5
    block@5: // for_header_L541
        let item_index_internal%1#1: uint64 = φ(item_index_internal%1#0 <- block@4, item_index_internal%1#2 <- block@7)
        let continue_looping%1#0: bool = (< item_index_internal%1#1 bytes_length%1#0)
        goto continue_looping%1#0 ? block@6 : block@8
    block@6: // for_body_L542
        let byte#0: bytes = (extract3 val#0 item_index_internal%1#1 1u)
        let idx#0: uint64 = item_index_internal%1#1
        let extract%0#0: bytes = (extract3 val#0 idx#0 1u)
        let tmp%2#0: bool = (== byte#0 extract%0#0)
        (assert tmp%2#0)
        let reinterpret_bytes[1]%0#0: bytes[1] = byte#0
        let tmp%3#0: uint64 = (len byte#0)
        let tmp%4#0: bool = (== tmp%3#0 1u)
        (assert tmp%4#0) // expected bytes to be length 1
        let extract%1#0: bytes = (extract3 val#0 idx#0 1u)
        let tmp%5#0: bool = (== reinterpret_bytes[1]%0#0 extract%1#0)
        (assert tmp%5#0)
        let tmp%6#0: bool = _puya_lib.bytes_.is_substring(byte#0, val#0)
        (assert tmp%6#0)
        let reinterpret_bytes[1]%1#0: bytes[1] = byte#0
        let tmp%7#0: uint64 = (len byte#0)
        let tmp%8#0: bool = (== tmp%7#0 1u)
        (assert tmp%8#0) // expected bytes to be length 1
        let tmp%9#0: bool = _puya_lib.bytes_.is_substring(reinterpret_bytes[1]%1#0, val#0)
        (assert tmp%9#0)
        goto block@7
    block@7: // for_footer_L541
        let item_index_internal%1#2: uint64 = (+ item_index_internal%1#1 1u)
        goto block@5
    block@8: // after_for_L541
        let extract%2#0: bytes = (extract3 val#0 0u 1u)
        let extract%3#0: bytes = (extract3 val#0 1u 1u)
        let extract%4#0: bytes = (extract3 val#0 2u 1u)
        let (exploded.0#0: bytes, exploded.1#0: bytes, exploded.2#0: bytes) = (extract%2#0, extract%3#0, extract%4#0)
        let tmp%10#0: bool = (== exploded.0#0 0xab)
        (assert tmp%10#0)
        let tmp%11#0: bool = (== exploded.2#0 0xef)
        (assert tmp%11#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_size_of() -> void:
    block@0: // L553
        let hex_val#0: bytes[2] = 0xabcd
        let tmp%0#0: bool = (== 2u 2u)
        (assert tmp%0#0)
        let tmp%1#0: bool = (== 2u 2u)
        (assert tmp%1#0)
        let awst_tmp%0#0: account = (txn Sender)
        let reinterpret_bytes[32]%0#0: bytes[32] = awst_tmp%0#0
        let tmp%2#0: uint64 = (len awst_tmp%0#0)
        let tmp%3#0: bool = (== tmp%2#0 32u)
        (assert tmp%3#0) // expected bytes to be length 32
        let from_txn_sender#0: bytes[32] = reinterpret_bytes[32]%0#0
        let tmp%4#0: bool = (== 32u 32u)
        (assert tmp%4#0)
        let tmp%5#0: bool = (== 32u 32u)
        (assert tmp%5#0)
        let reinterpret_bytes[16]%0#0: bytes[16] = 0x
        let from_bytes_empty#0: bytes[16] = reinterpret_bytes[16]%0#0
        let tmp%6#0: bool = (== 16u 16u)
        (assert tmp%6#0)
        let reinterpret_bytes[16]%1#0: bytes[16] = 0x41424344
        let from_bytes_less#0: bytes[16] = reinterpret_bytes[16]%1#0
        let tmp%7#0: bool = (== 16u 16u)
        (assert tmp%7#0)
        let reinterpret_bytes[2]%0#0: bytes[2] = 0x41424344
        let from_bytes_more#0: bytes[2] = reinterpret_bytes[2]%0#0
        let tmp%8#0: bool = (== 2u 2u)
        (assert tmp%8#0)
        let tmp%9#0: bytes[4] = (bzero 4u)
        let empty#0: bytes[4] = tmp%9#0
        let tmp%10#0: bool = (== 4u 4u)
        (assert tmp%10#0)
        let tmp%11#0: bool = (== 4u 4u)
        (assert tmp%11#0)
        let tmp%12#0: Encoded(uint8[4][8]) = (bzero 32u)
        let arr#0: Encoded(uint8[4][8]) = tmp%12#0
        let tmp%13#0: bool = (== 32u 32u)
        (assert tmp%13#0)
        let array_length%0#0: uint64 = array_len(arr#0)
        let item_index_internal%0#0: uint64 = 0u
        let reverse_index_internal%0#0: uint64 = array_length%0#0
        goto block@1
    block@1: // for_header_L579
        let item_index_internal%0#1: uint64 = φ(item_index_internal%0#0 <- block@0, item_index_internal%0#2 <- block@3)
        let continue_looping%0#0: bool = (< item_index_internal%0#1 array_length%0#0)
        goto continue_looping%0#0 ? block@2 : block@4
    block@2: // for_body_L580
        let array_item%0#0: Encoded(uint8[4]) = extract_value(arr#0, item_index_internal%0#1)
        let values%0#0: bytes[4] = decode_bytes<bytes[4]>(array_item%0#0)
        let v#0: bytes[4] = values%0#0
        let tmp%14#0: bytes[4] = (bzero 4u)
        let tmp%15#0: bool = (== v#0 tmp%14#0)
        (assert tmp%15#0)
        goto block@3
    block@3: // for_footer_L579
        let item_index_internal%0#2: uint64 = (+ item_index_internal%0#1 1u)
        goto block@1
    block@4: // after_for_L579
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_passing_fixed_bytes() -> void:
    block@0: // L583
        let tmp%0#0: uint64 = (len 0x796179)
        let tmp%1#0: bool = (== tmp%0#0 3u)
        (assert tmp%1#0) // expected bytes to be length 3
        let tmp%2#0: bool = test_cases.fixed_bytes_ops.contract.bytes_to_bool(0x796179)
        (assert tmp%2#0)
        let tmp%3#0: bool = test_cases.fixed_bytes_ops.contract.bytes_to_bool(0x6e6179)
        let tmp%4#0: bool = (! tmp%3#0)
        (assert tmp%4#0)
        let tmp%5#0: bytes[3] = test_cases.fixed_bytes_ops.contract.bool_to_bytes(1u)
        let tmp%6#0: bool = (== tmp%5#0 0x796179)
        (assert tmp%6#0)
        let tmp%7#0: bytes[3] = test_cases.fixed_bytes_ops.contract.bool_to_bytes(0u)
        let tmp%8#0: uint64 = (len 0x6e6179)
        let tmp%9#0: bool = (== tmp%8#0 3u)
        (assert tmp%9#0) // expected bytes to be length 3
        let tmp%10#0: bool = (== tmp%7#0 0x6e6179)
        (assert tmp%10#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.bool_to_bytes(x: bool) -> bytes[3]:
    block@0: // L592
        let select%0#0: bytes[3] = (select 0x6e6179 0x796179 x#0)
        return select%0#0

subroutine test_cases.fixed_bytes_ops.contract.bytes_to_bool(x: bytes[3]) -> bool:
    block@0: // L597
        let tmp%0#0: bool = (== x#0 0x796179)
        return tmp%0#0

subroutine test_cases.fixed_bytes_ops.contract.test_contains_fixed_bytes(x: bytes[4], y: bytes[2]) -> void:
    block@0: // L602
        let tmp%0#0: bool = _puya_lib.bytes_.is_substring(x#0, x#0)
        (assert tmp%0#0)
        let tmp%1#0: bool = _puya_lib.bytes_.is_substring(y#0, x#0)
        (assert tmp%1#0)
        let tmp%2#0: bool = _puya_lib.bytes_.is_substring(x#0, y#0)
        let tmp%3#0: bool = (! tmp%2#0)
        (assert tmp%3#0)
        let tmp%4#0: bool = _puya_lib.bytes_.is_substring(x#0, x#0)
        let tmp%5#0: bool = (! tmp%4#0)
        let tmp%6#0: bool = (== tmp%5#0 0u)
        (assert tmp%6#0)
        let tmp%7#0: bool = _puya_lib.bytes_.is_substring(y#0, x#0)
        let tmp%8#0: bool = (! tmp%7#0)
        let tmp%9#0: bool = (== tmp%8#0 0u)
        (assert tmp%9#0)
        let tmp%10#0: bool = _puya_lib.bytes_.is_substring(x#0, y#0)
        let tmp%11#0: bool = (== tmp%10#0 0u)
        (assert tmp%11#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_contains_bytes(x: bytes[4], y: bytes) -> void:
    block@0: // L615
        let tmp%0#0: bool = _puya_lib.bytes_.is_substring(y#0, x#0)
        (assert tmp%0#0)
        let tmp%1#0: bool = _puya_lib.bytes_.is_substring(x#0, y#0)
        let tmp%2#0: bool = (! tmp%1#0)
        (assert tmp%2#0)
        let tmp%3#0: bool = _puya_lib.bytes_.is_substring(y#0, x#0)
        let tmp%4#0: bool = (! tmp%3#0)
        let tmp%5#0: bool = (== tmp%4#0 0u)
        (assert tmp%5#0)
        let tmp%6#0: bool = _puya_lib.bytes_.is_substring(x#0, y#0)
        let tmp%7#0: bool = (== tmp%6#0 0u)
        (assert tmp%7#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.test_contains_literal_bytes(x: bytes[4]) -> void:
    block@0: // L624
        let tmp%0#0: bool = _puya_lib.bytes_.is_substring(0xcd12, x#0)
        (assert tmp%0#0)
        let tmp%1#0: bool = _puya_lib.bytes_.is_substring(0xcd12, x#0)
        let tmp%2#0: bool = (! tmp%1#0)
        let tmp%3#0: bool = (== tmp%2#0 0u)
        (assert tmp%3#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.__init__() -> void:
    block@0: // L22
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.set_state_data(for_account: account, value: bytes[4]) -> void:
    block@0: // L119
        (app_local_put for_account#0 "local" value#0)
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.get_state_data_or_assert(for_account: account) -> bytes[4]:
    block@0: // L123
        let (maybe_value%0#0: bytes, maybe_exists%0#0: bool) = (app_local_get_ex for_account#0 0u "local")
        let result#0: bytes[4] = maybe_value%0#0
        let exists#0: bool = maybe_exists%0#0
        (assert exists#0) // no data for account
        return result#0

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_or_assignment_with_bytes(val: bytes[1], other: bytes) -> void:
    block@0: // L129
        let val1#0: bytes[1] = val#0
        let reinterpret_bytes[1]%0#0: bytes[1] = other#0
        let tmp%0#0: uint64 = (len other#0)
        let tmp%1#0: bool = (== tmp%0#0 1u)
        (assert tmp%1#0) // expected bytes to be length 1
        let tmp%2#0: bytes = (b| val1#0 reinterpret_bytes[1]%0#0)
        let val1#1: bytes[1] = tmp%2#0
        (log val1#1)
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_and_assignment_with_bytes(val: bytes[1], other: bytes) -> void:
    block@0: // L137
        let val1#0: bytes[1] = val#0
        let reinterpret_bytes[1]%0#0: bytes[1] = other#0
        let tmp%0#0: uint64 = (len other#0)
        let tmp%1#0: bool = (== tmp%0#0 1u)
        (assert tmp%1#0) // expected bytes to be length 1
        let tmp%2#0: bytes = (b& val1#0 reinterpret_bytes[1]%0#0)
        let val1#1: bytes[1] = tmp%2#0
        (log val1#1)
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.test_augmented_xor_assignment_with_bytes(val: bytes[1], other: bytes) -> void:
    block@0: // L145
        let val1#0: bytes[1] = val#0
        let reinterpret_bytes[1]%0#0: bytes[1] = other#0
        let tmp%0#0: uint64 = (len other#0)
        let tmp%1#0: bool = (== tmp%0#0 1u)
        (assert tmp%1#0) // expected bytes to be length 1
        let tmp%2#0: bytes = (b^ val1#0 reinterpret_bytes[1]%0#0)
        let val1#1: bytes[1] = tmp%2#0
        (log val1#1)
        return 

subroutine test_cases.fixed_bytes_ops.contract.FixedBytesOps.validate_fixed_bytes_3(val: bytes[3]) -> void:
    block@0: // L153
        let len%0#0: uint64 = (len val#0)
        let eq%0#0: bool = (== len%0#0 3u)
        (assert eq%0#0) // invalid number of bytes for arc4.static_array<arc4.uint8, 3>
        let as_Encoded(uint8[3])%0#0: Encoded(uint8[3]) = val#0
        return 