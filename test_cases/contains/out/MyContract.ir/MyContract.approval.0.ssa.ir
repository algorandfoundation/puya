main test_cases.contains.contract.MyContract.approval_program:
    block@0: // L7
        let not_ten#0: uint64 = 15u
        let materialized_values%0#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_1(10u, 10u, not_ten#0, 0x66697665)
        let one_true#0: bool = materialized_values%0#0
        let materialized_values%1#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_1(5u, 10u, not_ten#0, 0x66697665)
        let one_false#0: bool = materialized_values%1#0
        (assert one_true#0) // Should be true
        let tmp%0#0: bool = (! one_false#0)
        (assert tmp%0#0) // Should be false
        let materialized_values%2#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_2(0x68656c6c6f, 0x68656c6c6f, 0u, 0x626f6e6a6f7572)
        let two_true#0: bool = materialized_values%2#0
        let materialized_values%3#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_2(0x6369616f, 0x68656c6c6f, 0u, 0x626f6e6a6f7572)
        let two_false#0: bool = materialized_values%3#0
        (assert two_true#0) // Should be true
        let tmp%1#0: bool = (! two_false#0)
        (assert tmp%1#0) // Should be false
        let materialized_values%4#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_3(32323423423423b, 32323423423423b, 8439439483934b)
        let three_true#0: bool = materialized_values%4#0
        let tmp%2#0: biguint = (b+ 32323423423423b 32323423423423b)
        let materialized_values%5#0: bool = test_cases.contains.contract.MyContract.is_in_tuple_3(tmp%2#0, 32323423423423b, 8439439483934b)
        let three_false#0: bool = materialized_values%5#0
        (assert three_true#0) // Should be true
        let tmp%3#0: bool = (! three_false#0)
        (assert tmp%3#0) // Should be false
        test_cases.contains.contract.MyContract.test_string_types()
        test_cases.contains.contract.MyContract.test_numeric_types()
        return 1u

subroutine test_cases.contains.contract.one_u64() -> uint64:
    block@0: // L137
        return 1u

subroutine test_cases.contains.contract.one_arc4u64() -> Encoded(uint64):
    block@0: // L142
        return 0x0000000000000001

subroutine test_cases.contains.contract.two_u64() -> uint64:
    block@0: // L147
        return 2u

subroutine test_cases.contains.contract.two_u8() -> Encoded(uint8):
    block@0: // L152
        return 0x02

subroutine test_cases.contains.contract.three_u512() -> Encoded(uint512):
    block@0: // L157
        return 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003

subroutine test_cases.contains.contract.four_biguint() -> biguint:
    block@0: // L162
        return 4b

subroutine test_cases.contains.contract.foo_string() -> string:
    block@0: // L167
        return "foo"

subroutine test_cases.contains.contract.foo_arc4() -> Encoded(len+utf8[]):
    block@0: // L172
        let length%0#0: uint64 = (len 0x666f6f)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 0x666f6f)
        let as_Encoded(len+utf8[])%0#0: Encoded(len+utf8[]) = encoded_value%0#0
        return as_Encoded(len+utf8[])%0#0

subroutine test_cases.contains.contract.bar_string() -> string:
    block@0: // L177
        return "bar"

subroutine test_cases.contains.contract.bar_arc4() -> Encoded(len+utf8[]):
    block@0: // L182
        let length%0#0: uint64 = (len 0x626172)
        let as_bytes%0#0: bytes[8] = (itob length%0#0)
        let length_uint16%0#0: bytes = ((extract 6 2) as_bytes%0#0)
        let encoded_value%0#0: bytes = (concat length_uint16%0#0 0x626172)
        let as_Encoded(len+utf8[])%0#0: Encoded(len+utf8[]) = encoded_value%0#0
        return as_Encoded(len+utf8[])%0#0

subroutine test_cases.contains.contract.baz_string() -> string:
    block@0: // L187
        return "baz"

subroutine test_cases.contains.contract.MyContract.is_in_tuple_1(x: uint64, y.0: uint64, y.1: uint64, y.2: bytes) -> bool:
    block@0: // L42
        let tmp%0#0: bool = (== x#0 y.0#0)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L44
        let tmp%1#0: bool = (== x#0 y.1#0)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L44
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L44
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L44
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        return or_result%0#2

subroutine test_cases.contains.contract.MyContract.is_in_tuple_2(x: bytes, y.0: bytes, y.1: uint64, y.2: bytes) -> bool:
    block@0: // L46
        let tmp%0#0: bool = (== x#0 y.0#0)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L48
        let tmp%1#0: bool = (== x#0 y.2#0)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L48
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L48
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L48
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        return or_result%0#2

subroutine test_cases.contains.contract.MyContract.is_in_tuple_3(x: biguint, y.0: biguint, y.1: biguint) -> bool:
    block@0: // L50
        let tmp%0#0: bool = (b== x#0 y.0#0)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // or_contd_L52
        let tmp%1#0: bool = (b== x#0 y.1#0)
        goto tmp%1#0 ? block@2 : block@3
    block@2: // bool_true_L52
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L52
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L52
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        return or_result%0#2

subroutine test_cases.contains.contract.MyContract.test_string_types() -> void:
    block@0: // L54
        let awst_tmp%0#0: string = test_cases.contains.contract.foo_string()
        let tmp%0#0: string = test_cases.contains.contract.foo_string()
        let tmp%1#0: string = test_cases.contains.contract.baz_string()
        let tmp%2#0: bool = (== awst_tmp%0#0 tmp%0#0)
        goto tmp%2#0 ? block@2 : block@1
    block@1: // or_contd_L56
        let tmp%3#0: bool = (== awst_tmp%0#0 tmp%1#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L56
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L56
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L56
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // foo in (foo, baz)
        let awst_tmp%1#0: string = test_cases.contains.contract.foo_string()
        let tmp%4#0: string = test_cases.contains.contract.bar_string()
        let tmp%5#0: string = test_cases.contains.contract.baz_string()
        let tmp%6#0: bool = (== awst_tmp%1#0 tmp%4#0)
        goto tmp%6#0 ? block@6 : block@5
    block@5: // or_contd_L57
        let tmp%7#0: bool = (== awst_tmp%1#0 tmp%5#0)
        goto tmp%7#0 ? block@6 : block@7
    block@6: // bool_true_L57
        let or_result%1#0: bool = 1u
        goto block@8
    block@7: // bool_false_L57
        let or_result%1#1: bool = 0u
        goto block@8
    block@8: // bool_merge_L57
        let or_result%1#2: bool = φ(or_result%1#0 <- block@6, or_result%1#1 <- block@7)
        let tmp%8#0: bool = (! or_result%1#2)
        (assert tmp%8#0) // foo not in (bar, baz)
        let tmp%9#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%10#0: string = test_cases.contains.contract.baz_string()
        let tmp%11#0: string = test_cases.contains.contract.bar_string()
        let tmp%12#0: bytes = ((extract 2 0) tmp%9#0)
        let awst_tmp%2#0: string = test_cases.contains.contract.foo_string()
        let tmp%13#0: bool = (== tmp%12#0 awst_tmp%2#0)
        goto tmp%13#0 ? block@11 : block@9
    block@9: // or_contd_L58
        let tmp%14#0: bool = (== awst_tmp%2#0 tmp%10#0)
        goto tmp%14#0 ? block@11 : block@10
    block@10: // or_contd_L58
        let tmp%15#0: bool = (== awst_tmp%2#0 tmp%11#0)
        goto tmp%15#0 ? block@11 : block@12
    block@11: // bool_true_L58
        let or_result%2#0: bool = 1u
        goto block@13
    block@12: // bool_false_L58
        let or_result%2#1: bool = 0u
        goto block@13
    block@13: // bool_merge_L58
        let or_result%2#2: bool = φ(or_result%2#0 <- block@11, or_result%2#1 <- block@12)
        (assert or_result%2#2) // foo in (foo, baz, bar)
        let awst_tmp%3#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%16#0: bytes = ((extract 2 0) awst_tmp%3#0)
        let tmp%17#0: string = test_cases.contains.contract.foo_string()
        let tmp%18#0: string = test_cases.contains.contract.baz_string()
        let tmp%19#0: string = test_cases.contains.contract.bar_string()
        let tmp%20#0: bool = (== tmp%16#0 tmp%17#0)
        goto tmp%20#0 ? block@16 : block@14
    block@14: // or_contd_L59
        let tmp%21#0: bytes = ((extract 2 0) awst_tmp%3#0)
        let tmp%22#0: bool = (== tmp%21#0 tmp%18#0)
        goto tmp%22#0 ? block@16 : block@15
    block@15: // or_contd_L59
        let tmp%23#0: bytes = ((extract 2 0) awst_tmp%3#0)
        let tmp%24#0: bool = (== tmp%23#0 tmp%19#0)
        goto tmp%24#0 ? block@16 : block@17
    block@16: // bool_true_L59
        let or_result%3#0: bool = 1u
        goto block@18
    block@17: // bool_false_L59
        let or_result%3#1: bool = 0u
        goto block@18
    block@18: // bool_merge_L59
        let or_result%3#2: bool = φ(or_result%3#0 <- block@16, or_result%3#1 <- block@17)
        (assert or_result%3#2) // foo in (foo, baz, bar)
        let tmp%25#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%26#0: string = test_cases.contains.contract.baz_string()
        let tmp%27#0: bytes = ((extract 2 0) tmp%25#0)
        let awst_tmp%4#0: string = test_cases.contains.contract.foo_string()
        let tmp%28#0: bool = (== tmp%27#0 awst_tmp%4#0)
        goto tmp%28#0 ? block@20 : block@19
    block@19: // or_contd_L60
        let tmp%29#0: bool = (== awst_tmp%4#0 tmp%26#0)
        goto tmp%29#0 ? block@20 : block@21
    block@20: // bool_true_L60
        let or_result%4#0: bool = 1u
        goto block@22
    block@21: // bool_false_L60
        let or_result%4#1: bool = 0u
        goto block@22
    block@22: // bool_merge_L60
        let or_result%4#2: bool = φ(or_result%4#0 <- block@20, or_result%4#1 <- block@21)
        let tmp%30#0: bool = (! or_result%4#2)
        (assert tmp%30#0) // foo not in (bar, baz)
        let awst_tmp%5#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%31#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%32#0: string = test_cases.contains.contract.baz_string()
        let tmp%33#0: bool = (== awst_tmp%5#0 tmp%31#0)
        goto tmp%33#0 ? block@24 : block@23
    block@23: // or_contd_L61
        let tmp%34#0: bytes = ((extract 2 0) awst_tmp%5#0)
        let tmp%35#0: bool = (== tmp%34#0 tmp%32#0)
        goto tmp%35#0 ? block@24 : block@25
    block@24: // bool_true_L61
        let or_result%5#0: bool = 1u
        goto block@26
    block@25: // bool_false_L61
        let or_result%5#1: bool = 0u
        goto block@26
    block@26: // bool_merge_L61
        let or_result%5#2: bool = φ(or_result%5#0 <- block@24, or_result%5#1 <- block@25)
        let tmp%36#0: bool = (! or_result%5#2)
        (assert tmp%36#0) // foo not in (bar, baz)
        let tmp%37#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%38#0: string = test_cases.contains.contract.baz_string()
        let tmp%39#0: string = test_cases.contains.contract.foo_string()
        let tmp%40#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%41#0: bytes = ((extract 2 0) tmp%37#0)
        let awst_tmp%6#0: string = test_cases.contains.contract.foo_string()
        let tmp%42#0: bool = (== tmp%41#0 awst_tmp%6#0)
        goto tmp%42#0 ? block@29 : block@27
    block@27: // or_contd_L62
        let tmp%43#0: bool = (== awst_tmp%6#0 tmp%38#0)
        goto tmp%43#0 ? block@29 : block@28
    block@28: // or_contd_L62
        let tmp%44#0: bool = (== awst_tmp%6#0 tmp%39#0)
        goto tmp%44#0 ? block@29 : block@30
    block@29: // bool_true_L62
        let or_result%6#0: bool = 1u
        goto block@31
    block@30: // bool_false_L62
        let or_result%6#1: bool = 0u
        goto block@31
    block@31: // bool_merge_L62
        let or_result%6#2: bool = φ(or_result%6#0 <- block@29, or_result%6#1 <- block@30)
        (assert or_result%6#2) // foo in (bar, baz, foo, 1)
        let awst_tmp%7#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%45#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%46#0: string = test_cases.contains.contract.baz_string()
        let tmp%47#0: string = test_cases.contains.contract.foo_string()
        let tmp%48#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%49#0: bool = (== awst_tmp%7#0 tmp%45#0)
        goto tmp%49#0 ? block@34 : block@32
    block@32: // or_contd_L68
        let tmp%50#0: bytes = ((extract 2 0) awst_tmp%7#0)
        let tmp%51#0: bool = (== tmp%50#0 tmp%46#0)
        goto tmp%51#0 ? block@34 : block@33
    block@33: // or_contd_L68
        let tmp%52#0: bytes = ((extract 2 0) awst_tmp%7#0)
        let tmp%53#0: bool = (== tmp%52#0 tmp%47#0)
        goto tmp%53#0 ? block@34 : block@35
    block@34: // bool_true_L68
        let or_result%7#0: bool = 1u
        goto block@36
    block@35: // bool_false_L68
        let or_result%7#1: bool = 0u
        goto block@36
    block@36: // bool_merge_L68
        let or_result%7#2: bool = φ(or_result%7#0 <- block@34, or_result%7#1 <- block@35)
        (assert or_result%7#2) // foo in (bar, baz, foo, 1)
        let tmp%54#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%55#0: string = test_cases.contains.contract.baz_string()
        let tmp%56#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%57#0: bytes = ((extract 2 0) tmp%54#0)
        let awst_tmp%8#0: string = test_cases.contains.contract.foo_string()
        let tmp%58#0: bool = (== tmp%57#0 awst_tmp%8#0)
        goto tmp%58#0 ? block@38 : block@37
    block@37: // or_contd_L74
        let tmp%59#0: bool = (== awst_tmp%8#0 tmp%55#0)
        goto tmp%59#0 ? block@38 : block@39
    block@38: // bool_true_L74
        let or_result%8#0: bool = 1u
        goto block@40
    block@39: // bool_false_L74
        let or_result%8#1: bool = 0u
        goto block@40
    block@40: // bool_merge_L74
        let or_result%8#2: bool = φ(or_result%8#0 <- block@38, or_result%8#1 <- block@39)
        let tmp%60#0: bool = (! or_result%8#2)
        (assert tmp%60#0) // foo not in (bar, baz, 1)
        let awst_tmp%9#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%61#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%62#0: string = test_cases.contains.contract.baz_string()
        let tmp%63#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%64#0: bool = (== awst_tmp%9#0 tmp%61#0)
        goto tmp%64#0 ? block@42 : block@41
    block@41: // or_contd_L79
        let tmp%65#0: bytes = ((extract 2 0) awst_tmp%9#0)
        let tmp%66#0: bool = (== tmp%65#0 tmp%62#0)
        goto tmp%66#0 ? block@42 : block@43
    block@42: // bool_true_L79
        let or_result%9#0: bool = 1u
        goto block@44
    block@43: // bool_false_L79
        let or_result%9#1: bool = 0u
        goto block@44
    block@44: // bool_merge_L79
        let or_result%9#2: bool = φ(or_result%9#0 <- block@42, or_result%9#1 <- block@43)
        let tmp%67#0: bool = (! or_result%9#2)
        (assert tmp%67#0) // foo not in (bar, baz, 1)
        let tmp%68#0: string = test_cases.contains.contract.foo_string()
        let tmp%69#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%70#0: bool = (== 0x666f6f 0x626172)
        let tmp%71#0: bool = (! tmp%70#0)
        (assert tmp%71#0) // b'foo' not in (foo, foo, b'bar')
        return 

subroutine test_cases.contains.contract.MyContract.test_numeric_types() -> void:
    block@0: // L86
        let awst_tmp%0#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%0#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%1#0: uint64 = test_cases.contains.contract.two_u64()
        let tmp%2#0: bool = (== awst_tmp%0#0 tmp%0#0)
        goto tmp%2#0 ? block@2 : block@1
    block@1: // or_contd_L88
        let tmp%3#0: bool = (== awst_tmp%0#0 tmp%1#0)
        goto tmp%3#0 ? block@2 : block@3
    block@2: // bool_true_L88
        let or_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L88
        let or_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L88
        let or_result%0#2: bool = φ(or_result%0#0 <- block@2, or_result%0#1 <- block@3)
        (assert or_result%0#2) // 1 in (1, 2)
        let awst_tmp%1#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%4#0: uint64 = test_cases.contains.contract.two_u64()
        let tmp%5#0: bool = (== awst_tmp%1#0 3u)
        goto tmp%5#0 ? block@6 : block@5
    block@5: // or_contd_L89
        let tmp%6#0: bool = (== awst_tmp%1#0 tmp%4#0)
        goto tmp%6#0 ? block@6 : block@7
    block@6: // bool_true_L89
        let or_result%1#0: bool = 1u
        goto block@8
    block@7: // bool_false_L89
        let or_result%1#1: bool = 0u
        goto block@8
    block@8: // bool_merge_L89
        let or_result%1#2: bool = φ(or_result%1#0 <- block@6, or_result%1#1 <- block@7)
        let tmp%7#0: bool = (! or_result%1#2)
        (assert tmp%7#0) // 1 not in (3, 2)
        let awst_tmp%2#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%8#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%9#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%10#0: bool = (== awst_tmp%2#0 tmp%8#0)
        goto tmp%10#0 ? block@11 : block@9
    block@9: // or_contd_L91
        let tmp%11#0: bool = (== awst_tmp%2#0 3u)
        goto tmp%11#0 ? block@11 : block@10
    block@10: // or_contd_L91
        let reinterpret_biguint%0#0: biguint = tmp%9#0
        let tmp%12#0: biguint = (itob awst_tmp%2#0)
        let tmp%13#0: bool = (b== reinterpret_biguint%0#0 tmp%12#0)
        goto tmp%13#0 ? block@11 : block@12
    block@11: // bool_true_L91
        let or_result%2#0: bool = 1u
        goto block@13
    block@12: // bool_false_L91
        let or_result%2#1: bool = 0u
        goto block@13
    block@13: // bool_merge_L91
        let or_result%2#2: bool = φ(or_result%2#0 <- block@11, or_result%2#1 <- block@12)
        (assert or_result%2#2) // 1 in (1, 3, 2)
        let tmp%14#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let tmp%15#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%1#0: biguint = tmp%14#0
        let awst_tmp%3#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%16#0: biguint = (itob awst_tmp%3#0)
        let tmp%17#0: bool = (b== reinterpret_biguint%1#0 tmp%16#0)
        goto tmp%17#0 ? block@16 : block@14
    block@14: // or_contd_L92
        let tmp%18#0: bool = (== awst_tmp%3#0 4u)
        goto tmp%18#0 ? block@16 : block@15
    block@15: // or_contd_L92
        let reinterpret_biguint%2#0: biguint = tmp%15#0
        let tmp%19#0: biguint = (itob awst_tmp%3#0)
        let tmp%20#0: bool = (b== reinterpret_biguint%2#0 tmp%19#0)
        goto tmp%20#0 ? block@16 : block@17
    block@16: // bool_true_L92
        let or_result%3#0: bool = 1u
        goto block@18
    block@17: // bool_false_L92
        let or_result%3#1: bool = 0u
        goto block@18
    block@18: // bool_merge_L92
        let or_result%3#2: bool = φ(or_result%3#0 <- block@16, or_result%3#1 <- block@17)
        (assert or_result%3#2) // 1 in (1, 4, 2)
        let tmp%21#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let tmp%22#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%3#0: biguint = tmp%21#0
        let tmp%23#0: biguint = (itob 2u)
        let tmp%24#0: bool = (b== reinterpret_biguint%3#0 tmp%23#0)
        goto tmp%24#0 ? block@21 : block@19
    block@19: // or_contd_L93
        let tmp%25#0: bool = (== 2u 3u)
        goto tmp%25#0 ? block@21 : block@20
    block@20: // or_contd_L93
        let reinterpret_biguint%4#0: biguint = tmp%22#0
        let tmp%26#0: biguint = (itob 2u)
        let tmp%27#0: bool = (b== reinterpret_biguint%4#0 tmp%26#0)
        goto tmp%27#0 ? block@21 : block@22
    block@21: // bool_true_L93
        let or_result%4#0: bool = 1u
        goto block@23
    block@22: // bool_false_L93
        let or_result%4#1: bool = 0u
        goto block@23
    block@23: // bool_merge_L93
        let or_result%4#2: bool = φ(or_result%4#0 <- block@21, or_result%4#1 <- block@22)
        (assert or_result%4#2) // 2 in (1, 3, 2)
        let awst_tmp%4#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%5#0: biguint = awst_tmp%4#0
        let tmp%28#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let tmp%29#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%6#0: biguint = tmp%28#0
        let tmp%30#0: bool = (b== reinterpret_biguint%5#0 reinterpret_biguint%6#0)
        goto tmp%30#0 ? block@26 : block@24
    block@24: // or_contd_L94
        let reinterpret_biguint%7#0: biguint = awst_tmp%4#0
        let tmp%31#0: biguint = (itob 3u)
        let tmp%32#0: bool = (b== reinterpret_biguint%7#0 tmp%31#0)
        goto tmp%32#0 ? block@26 : block@25
    block@25: // or_contd_L94
        let reinterpret_biguint%8#0: biguint = awst_tmp%4#0
        let reinterpret_biguint%9#0: biguint = tmp%29#0
        let tmp%33#0: bool = (b== reinterpret_biguint%8#0 reinterpret_biguint%9#0)
        goto tmp%33#0 ? block@26 : block@27
    block@26: // bool_true_L94
        let or_result%5#0: bool = 1u
        goto block@28
    block@27: // bool_false_L94
        let or_result%5#1: bool = 0u
        goto block@28
    block@28: // bool_merge_L94
        let or_result%5#2: bool = φ(or_result%5#0 <- block@26, or_result%5#1 <- block@27)
        (assert or_result%5#2) // 2 in (1, 3, 2)
        let awst_tmp%5#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%10#0: biguint = awst_tmp%5#0
        let tmp%34#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let reinterpret_biguint%11#0: biguint = tmp%34#0
        let tmp%35#0: bool = (b== reinterpret_biguint%10#0 reinterpret_biguint%11#0)
        goto tmp%35#0 ? block@31 : block@29
    block@29: // or_contd_L95
        let reinterpret_biguint%12#0: biguint = awst_tmp%5#0
        let tmp%36#0: biguint = (itob 2u)
        let tmp%37#0: bool = (b== reinterpret_biguint%12#0 tmp%36#0)
        goto tmp%37#0 ? block@31 : block@30
    block@30: // or_contd_L95
        let reinterpret_biguint%13#0: biguint = awst_tmp%5#0
        let tmp%38#0: biguint = (itob 3u)
        let tmp%39#0: bool = (b== reinterpret_biguint%13#0 tmp%38#0)
        goto tmp%39#0 ? block@31 : block@32
    block@31: // bool_true_L95
        let or_result%6#0: bool = 1u
        goto block@33
    block@32: // bool_false_L95
        let or_result%6#1: bool = 0u
        goto block@33
    block@33: // bool_merge_L95
        let or_result%6#2: bool = φ(or_result%6#0 <- block@31, or_result%6#1 <- block@32)
        (assert or_result%6#2) // 2 in (1, 2, 3)
        let awst_tmp%6#0: Encoded(uint512) = test_cases.contains.contract.three_u512()
        let reinterpret_biguint%14#0: biguint = awst_tmp%6#0
        let tmp%40#0: biguint = (itob 3u)
        let tmp%41#0: bool = (b== reinterpret_biguint%14#0 tmp%40#0)
        goto tmp%41#0 ? block@35 : block@34
    block@34: // or_contd_L96
        let reinterpret_biguint%15#0: biguint = awst_tmp%6#0
        let tmp%42#0: biguint = (itob 4u)
        let tmp%43#0: bool = (b== reinterpret_biguint%15#0 tmp%42#0)
        goto tmp%43#0 ? block@35 : block@36
    block@35: // bool_true_L96
        let or_result%7#0: bool = 1u
        goto block@37
    block@36: // bool_false_L96
        let or_result%7#1: bool = 0u
        goto block@37
    block@37: // bool_merge_L96
        let or_result%7#2: bool = φ(or_result%7#0 <- block@35, or_result%7#1 <- block@36)
        (assert or_result%7#2) // 3 in (3, 4)
        let awst_tmp%7#0: biguint = test_cases.contains.contract.four_biguint()
        let tmp%44#0: biguint = (itob 5u)
        let tmp%45#0: bool = (b== awst_tmp%7#0 tmp%44#0)
        goto tmp%45#0 ? block@39 : block@38
    block@38: // or_contd_L97
        let tmp%46#0: biguint = (itob 4u)
        let tmp%47#0: bool = (b== awst_tmp%7#0 tmp%46#0)
        goto tmp%47#0 ? block@39 : block@40
    block@39: // bool_true_L97
        let or_result%8#0: bool = 1u
        goto block@41
    block@40: // bool_false_L97
        let or_result%8#1: bool = 0u
        goto block@41
    block@41: // bool_merge_L97
        let or_result%8#2: bool = φ(or_result%8#0 <- block@39, or_result%8#1 <- block@40)
        (assert or_result%8#2) // 4 in (5, 4)
        let awst_tmp%8#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%48#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%49#0: bool = (== awst_tmp%8#0 5u)
        goto tmp%49#0 ? block@43 : block@42
    block@42: // or_contd_L99
        let reinterpret_biguint%16#0: biguint = tmp%48#0
        let tmp%50#0: biguint = (itob awst_tmp%8#0)
        let tmp%51#0: bool = (b== reinterpret_biguint%16#0 tmp%50#0)
        goto tmp%51#0 ? block@43 : block@44
    block@43: // bool_true_L99
        let or_result%9#0: bool = 1u
        goto block@45
    block@44: // bool_false_L99
        let or_result%9#1: bool = 0u
        goto block@45
    block@45: // bool_merge_L99
        let or_result%9#2: bool = φ(or_result%9#0 <- block@43, or_result%9#1 <- block@44)
        let tmp%52#0: bool = (! or_result%9#2)
        (assert tmp%52#0) // 1 not in (5, 2)
        let awst_tmp%9#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%53#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%54#0: bool = (== awst_tmp%9#0 3u)
        goto tmp%54#0 ? block@47 : block@46
    block@46: // or_contd_L100
        let reinterpret_biguint%17#0: biguint = tmp%53#0
        let tmp%55#0: biguint = (itob awst_tmp%9#0)
        let tmp%56#0: bool = (b== reinterpret_biguint%17#0 tmp%55#0)
        goto tmp%56#0 ? block@47 : block@48
    block@47: // bool_true_L100
        let or_result%10#0: bool = 1u
        goto block@49
    block@48: // bool_false_L100
        let or_result%10#1: bool = 0u
        goto block@49
    block@49: // bool_merge_L100
        let or_result%10#2: bool = φ(or_result%10#0 <- block@47, or_result%10#1 <- block@48)
        let tmp%57#0: bool = (! or_result%10#2)
        (assert tmp%57#0) // 1 not in (app(1), 3, 2)
        let awst_tmp%10#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%58#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%59#0: bool = (== awst_tmp%10#0 3u)
        goto tmp%59#0 ? block@51 : block@50
    block@50: // or_contd_L101
        let reinterpret_biguint%18#0: biguint = tmp%58#0
        let tmp%60#0: biguint = (itob awst_tmp%10#0)
        let tmp%61#0: bool = (b== reinterpret_biguint%18#0 tmp%60#0)
        goto tmp%61#0 ? block@51 : block@52
    block@51: // bool_true_L101
        let or_result%11#0: bool = 1u
        goto block@53
    block@52: // bool_false_L101
        let or_result%11#1: bool = 0u
        goto block@53
    block@53: // bool_merge_L101
        let or_result%11#2: bool = φ(or_result%11#0 <- block@51, or_result%11#1 <- block@52)
        let tmp%62#0: bool = (! or_result%11#2)
        (assert tmp%62#0) // 1 not in (3, 2)
        let tmp%63#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let reinterpret_biguint%19#0: biguint = tmp%63#0
        let tmp%64#0: biguint = (itob 2u)
        let tmp%65#0: bool = (b== reinterpret_biguint%19#0 tmp%64#0)
        goto tmp%65#0 ? block@55 : block@54
    block@54: // or_contd_L102
        let tmp%66#0: bool = (== 2u 3u)
        goto tmp%66#0 ? block@55 : block@56
    block@55: // bool_true_L102
        let or_result%12#0: bool = 1u
        goto block@57
    block@56: // bool_false_L102
        let or_result%12#1: bool = 0u
        goto block@57
    block@57: // bool_merge_L102
        let or_result%12#2: bool = φ(or_result%12#0 <- block@55, or_result%12#1 <- block@56)
        let tmp%67#0: bool = (! or_result%12#2)
        (assert tmp%67#0) // 2 not in (1, 3)
        let awst_tmp%11#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%20#0: biguint = awst_tmp%11#0
        let tmp%68#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let reinterpret_biguint%21#0: biguint = tmp%68#0
        let tmp%69#0: bool = (b== reinterpret_biguint%20#0 reinterpret_biguint%21#0)
        goto tmp%69#0 ? block@59 : block@58
    block@58: // or_contd_L103
        let reinterpret_biguint%22#0: biguint = awst_tmp%11#0
        let tmp%70#0: biguint = (itob 3u)
        let tmp%71#0: bool = (b== reinterpret_biguint%22#0 tmp%70#0)
        goto tmp%71#0 ? block@59 : block@60
    block@59: // bool_true_L103
        let or_result%13#0: bool = 1u
        goto block@61
    block@60: // bool_false_L103
        let or_result%13#1: bool = 0u
        goto block@61
    block@61: // bool_merge_L103
        let or_result%13#2: bool = φ(or_result%13#0 <- block@59, or_result%13#1 <- block@60)
        let tmp%72#0: bool = (! or_result%13#2)
        (assert tmp%72#0) // 2 not in (1, 3)
        let awst_tmp%12#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%23#0: biguint = awst_tmp%12#0
        let tmp%73#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let reinterpret_biguint%24#0: biguint = tmp%73#0
        let tmp%74#0: bool = (b== reinterpret_biguint%23#0 reinterpret_biguint%24#0)
        goto tmp%74#0 ? block@63 : block@62
    block@62: // or_contd_L104
        let reinterpret_biguint%25#0: biguint = awst_tmp%12#0
        let tmp%75#0: biguint = (itob 3u)
        let tmp%76#0: bool = (b== reinterpret_biguint%25#0 tmp%75#0)
        goto tmp%76#0 ? block@63 : block@64
    block@63: // bool_true_L104
        let or_result%14#0: bool = 1u
        goto block@65
    block@64: // bool_false_L104
        let or_result%14#1: bool = 0u
        goto block@65
    block@65: // bool_merge_L104
        let or_result%14#2: bool = φ(or_result%14#0 <- block@63, or_result%14#1 <- block@64)
        let tmp%77#0: bool = (! or_result%14#2)
        (assert tmp%77#0) // 2 not in (1, 3)
        let awst_tmp%13#0: Encoded(uint512) = test_cases.contains.contract.three_u512()
        let reinterpret_biguint%26#0: biguint = awst_tmp%13#0
        let tmp%78#0: biguint = (itob 5u)
        let tmp%79#0: bool = (b== reinterpret_biguint%26#0 tmp%78#0)
        goto tmp%79#0 ? block@67 : block@66
    block@66: // or_contd_L105
        let reinterpret_biguint%27#0: biguint = awst_tmp%13#0
        let tmp%80#0: biguint = (itob 7u)
        let tmp%81#0: bool = (b== reinterpret_biguint%27#0 tmp%80#0)
        goto tmp%81#0 ? block@67 : block@68
    block@67: // bool_true_L105
        let or_result%15#0: bool = 1u
        goto block@69
    block@68: // bool_false_L105
        let or_result%15#1: bool = 0u
        goto block@69
    block@69: // bool_merge_L105
        let or_result%15#2: bool = φ(or_result%15#0 <- block@67, or_result%15#1 <- block@68)
        let tmp%82#0: bool = (! or_result%15#2)
        (assert tmp%82#0) // 3 not in (5, 7)
        let awst_tmp%14#0: biguint = test_cases.contains.contract.four_biguint()
        let tmp%83#0: biguint = (itob 2u)
        let tmp%84#0: bool = (b== awst_tmp%14#0 tmp%83#0)
        goto tmp%84#0 ? block@71 : block@70
    block@70: // or_contd_L106
        let tmp%85#0: biguint = (itob 9u)
        let tmp%86#0: bool = (b== awst_tmp%14#0 tmp%85#0)
        goto tmp%86#0 ? block@71 : block@72
    block@71: // bool_true_L106
        let or_result%16#0: bool = 1u
        goto block@73
    block@72: // bool_false_L106
        let or_result%16#1: bool = 0u
        goto block@73
    block@73: // bool_merge_L106
        let or_result%16#2: bool = φ(or_result%16#0 <- block@71, or_result%16#1 <- block@72)
        let tmp%87#0: bool = (! or_result%16#2)
        (assert tmp%87#0) // 4 not in (2, 9)
        let awst_tmp%15#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%88#0: string = test_cases.contains.contract.foo_string()
        let tmp%89#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%90#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%91#0: bool = (== awst_tmp%15#0 tmp%89#0)
        goto tmp%91#0 ? block@76 : block@74
    block@74: // or_contd_L108
        let tmp%92#0: bool = (== awst_tmp%15#0 3u)
        goto tmp%92#0 ? block@76 : block@75
    block@75: // or_contd_L108
        let reinterpret_biguint%28#0: biguint = tmp%90#0
        let tmp%93#0: biguint = (itob awst_tmp%15#0)
        let tmp%94#0: bool = (b== reinterpret_biguint%28#0 tmp%93#0)
        goto tmp%94#0 ? block@76 : block@77
    block@76: // bool_true_L108
        let or_result%17#0: bool = 1u
        goto block@78
    block@77: // bool_false_L108
        let or_result%17#1: bool = 0u
        goto block@78
    block@78: // bool_merge_L108
        let or_result%17#2: bool = φ(or_result%17#0 <- block@76, or_result%17#1 <- block@77)
        (assert or_result%17#2) // 1 in (foo, 1, 3, 2)
        let tmp%95#0: Encoded(uint64) = test_cases.contains.contract.one_arc4u64()
        let tmp%96#0: string = test_cases.contains.contract.bar_string()
        let tmp%97#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%29#0: biguint = tmp%95#0
        let awst_tmp%16#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%98#0: biguint = (itob awst_tmp%16#0)
        let tmp%99#0: bool = (b== reinterpret_biguint%29#0 tmp%98#0)
        goto tmp%99#0 ? block@80 : block@79
    block@79: // or_contd_L114
        let reinterpret_biguint%30#0: biguint = tmp%97#0
        let tmp%100#0: biguint = (itob awst_tmp%16#0)
        let tmp%101#0: bool = (b== reinterpret_biguint%30#0 tmp%100#0)
        goto tmp%101#0 ? block@80 : block@81
    block@80: // bool_true_L114
        let or_result%18#0: bool = 1u
        goto block@82
    block@81: // bool_false_L114
        let or_result%18#1: bool = 0u
        goto block@82
    block@82: // bool_merge_L114
        let or_result%18#2: bool = φ(or_result%18#0 <- block@80, or_result%18#1 <- block@81)
        (assert or_result%18#2) // 1 in (1, bar, 2)
        let tmp%102#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%103#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%104#0: bool = (== 2u 3u)
        goto tmp%104#0 ? block@84 : block@83
    block@83: // or_contd_L115
        let reinterpret_biguint%31#0: biguint = tmp%103#0
        let tmp%105#0: biguint = (itob 2u)
        let tmp%106#0: bool = (b== reinterpret_biguint%31#0 tmp%105#0)
        goto tmp%106#0 ? block@84 : block@85
    block@84: // bool_true_L115
        let or_result%19#0: bool = 1u
        goto block@86
    block@85: // bool_false_L115
        let or_result%19#1: bool = 0u
        goto block@86
    block@86: // bool_merge_L115
        let or_result%19#2: bool = φ(or_result%19#0 <- block@84, or_result%19#1 <- block@85)
        (assert or_result%19#2) // 2 in (foo, 3, 2)
        let awst_tmp%17#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%32#0: biguint = awst_tmp%17#0
        let tmp%107#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%108#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%109#0: biguint = (itob 3u)
        let tmp%110#0: bool = (b== reinterpret_biguint%32#0 tmp%109#0)
        goto tmp%110#0 ? block@88 : block@87
    block@87: // or_contd_L116
        let reinterpret_biguint%33#0: biguint = awst_tmp%17#0
        let reinterpret_biguint%34#0: biguint = tmp%108#0
        let tmp%111#0: bool = (b== reinterpret_biguint%33#0 reinterpret_biguint%34#0)
        goto tmp%111#0 ? block@88 : block@89
    block@88: // bool_true_L116
        let or_result%20#0: bool = 1u
        goto block@90
    block@89: // bool_false_L116
        let or_result%20#1: bool = 0u
        goto block@90
    block@90: // bool_merge_L116
        let or_result%20#2: bool = φ(or_result%20#0 <- block@88, or_result%20#1 <- block@89)
        (assert or_result%20#2) // 2 in (bar, 3, 2)
        let awst_tmp%18#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%35#0: biguint = awst_tmp%18#0
        let tmp%112#0: string = test_cases.contains.contract.foo_string()
        let tmp%113#0: biguint = (itob 2u)
        let tmp%114#0: bool = (b== reinterpret_biguint%35#0 tmp%113#0)
        goto tmp%114#0 ? block@92 : block@91
    block@91: // or_contd_L117
        let reinterpret_biguint%36#0: biguint = awst_tmp%18#0
        let tmp%115#0: biguint = (itob 3u)
        let tmp%116#0: bool = (b== reinterpret_biguint%36#0 tmp%115#0)
        goto tmp%116#0 ? block@92 : block@93
    block@92: // bool_true_L117
        let or_result%21#0: bool = 1u
        goto block@94
    block@93: // bool_false_L117
        let or_result%21#1: bool = 0u
        goto block@94
    block@94: // bool_merge_L117
        let or_result%21#2: bool = φ(or_result%21#0 <- block@92, or_result%21#1 <- block@93)
        (assert or_result%21#2) // 2 in foo(2, 3)
        let awst_tmp%19#0: Encoded(uint512) = test_cases.contains.contract.three_u512()
        let reinterpret_biguint%37#0: biguint = awst_tmp%19#0
        let tmp%117#0: string = test_cases.contains.contract.foo_string()
        let tmp%118#0: biguint = (itob 5u)
        let tmp%119#0: bool = (b== reinterpret_biguint%37#0 tmp%118#0)
        goto tmp%119#0 ? block@96 : block@95
    block@95: // or_contd_L118
        let reinterpret_biguint%38#0: biguint = awst_tmp%19#0
        let tmp%120#0: biguint = (itob 3u)
        let tmp%121#0: bool = (b== reinterpret_biguint%38#0 tmp%120#0)
        goto tmp%121#0 ? block@96 : block@97
    block@96: // bool_true_L118
        let or_result%22#0: bool = 1u
        goto block@98
    block@97: // bool_false_L118
        let or_result%22#1: bool = 0u
        goto block@98
    block@98: // bool_merge_L118
        let or_result%22#2: bool = φ(or_result%22#0 <- block@96, or_result%22#1 <- block@97)
        (assert or_result%22#2) // 3 in (5, 3, foo)
        let awst_tmp%20#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%122#0: string = test_cases.contains.contract.foo_string()
        let tmp%123#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let tmp%124#0: bool = (== awst_tmp%20#0 3u)
        goto tmp%124#0 ? block@100 : block@99
    block@99: // or_contd_L120
        let reinterpret_biguint%39#0: biguint = tmp%123#0
        let tmp%125#0: biguint = (itob awst_tmp%20#0)
        let tmp%126#0: bool = (b== reinterpret_biguint%39#0 tmp%125#0)
        goto tmp%126#0 ? block@100 : block@101
    block@100: // bool_true_L120
        let or_result%23#0: bool = 1u
        goto block@102
    block@101: // bool_false_L120
        let or_result%23#1: bool = 0u
        goto block@102
    block@102: // bool_merge_L120
        let or_result%23#2: bool = φ(or_result%23#0 <- block@100, or_result%23#1 <- block@101)
        let tmp%127#0: bool = (! or_result%23#2)
        (assert tmp%127#0) // 1 not in (foo, 3, 2)
        let tmp%128#0: string = test_cases.contains.contract.bar_string()
        let tmp%129#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%40#0: biguint = tmp%129#0
        let awst_tmp%21#0: uint64 = test_cases.contains.contract.one_u64()
        let tmp%130#0: biguint = (itob awst_tmp%21#0)
        let tmp%131#0: bool = (b== reinterpret_biguint%40#0 tmp%130#0)
        let tmp%132#0: bool = (! tmp%131#0)
        (assert tmp%132#0) // 1 not in (bar, 2)
        let tmp%133#0: Encoded(len+utf8[]) = test_cases.contains.contract.foo_arc4()
        let tmp%134#0: bool = (== 2u 3u)
        let tmp%135#0: bool = (! tmp%134#0)
        (assert tmp%135#0) // 2 not in (foo, 3)
        let awst_tmp%22#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%41#0: biguint = awst_tmp%22#0
        let tmp%136#0: Encoded(len+utf8[]) = test_cases.contains.contract.bar_arc4()
        let tmp%137#0: biguint = (itob 3u)
        let tmp%138#0: bool = (b== reinterpret_biguint%41#0 tmp%137#0)
        let tmp%139#0: bool = (! tmp%138#0)
        (assert tmp%139#0) // 2 not in (bar, 3)
        let awst_tmp%23#0: Encoded(uint8) = test_cases.contains.contract.two_u8()
        let reinterpret_biguint%42#0: biguint = awst_tmp%23#0
        let tmp%140#0: string = test_cases.contains.contract.foo_string()
        let tmp%141#0: biguint = (itob 3u)
        let tmp%142#0: bool = (b== reinterpret_biguint%42#0 tmp%141#0)
        let tmp%143#0: bool = (! tmp%142#0)
        (assert tmp%143#0) // 2 not in (foo, 3)
        let awst_tmp%24#0: Encoded(uint512) = test_cases.contains.contract.three_u512()
        let reinterpret_biguint%43#0: biguint = awst_tmp%24#0
        let tmp%144#0: string = test_cases.contains.contract.foo_string()
        let tmp%145#0: biguint = (itob 5u)
        let tmp%146#0: bool = (b== reinterpret_biguint%43#0 tmp%145#0)
        let tmp%147#0: bool = (! tmp%146#0)
        (assert tmp%147#0) // 3 not in (5, foo)
        let reinterpret_biguint%44#0: biguint = 0x41
        let tmp%148#0: biguint = (itob 64u)
        let tmp%149#0: bool = (b== reinterpret_biguint%44#0 tmp%148#0)
        goto tmp%149#0 ? block@104 : block@103
    block@103: // or_contd_L130
        let reinterpret_biguint%45#0: biguint = 0x41
        let tmp%150#0: biguint = (itob 66u)
        let tmp%151#0: bool = (b== reinterpret_biguint%45#0 tmp%150#0)
        goto tmp%151#0 ? block@104 : block@105
    block@104: // bool_true_L130
        let or_result%24#0: bool = 1u
        goto block@106
    block@105: // bool_false_L130
        let or_result%24#1: bool = 0u
        goto block@106
    block@106: // bool_merge_L130
        let or_result%24#2: bool = φ(or_result%24#0 <- block@104, or_result%24#1 <- block@105)
        let tmp%152#0: bool = (! or_result%24#2)
        (assert tmp%152#0) // 65 not in (b'A', 64, 66)
        return 