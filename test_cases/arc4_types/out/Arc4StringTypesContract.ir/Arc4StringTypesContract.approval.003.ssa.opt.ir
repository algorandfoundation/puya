main test_cases.arc4_types.string.Arc4StringTypesContract.approval_program:
    block@0: // L7
        let some_bytes_as_string#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>(0x48656c6c6f20576f726c6421)
        let tmp%2#0: bool = (!= some_bytes_as_string#0 0x48656c6c6f20576f726c6421)
        (assert tmp%2#0) // Original bytes should not match encoded bytes
        let length%0#0: uint64 = (len some_bytes_as_string#0)
        let is_out_of_bounds%0#0: bool = (>= 2u length%0#0)
        let bounded_index%0#0: uint64 = (select 2u length%0#0 is_out_of_bounds%0#0)
        let tmp%3#0: bytes = (substring3 some_bytes_as_string#0 bounded_index%0#0 length%0#0)
        let tmp%4#0: bool = (== tmp%3#0 0x48656c6c6f20576f726c6421)
        (assert tmp%4#0) // Original bytes should match encoded if we strip the length header
        let hello#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("Hello")
        let space#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>(" ")
        let world#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("World!")
        let tmp%9#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("Hello World!")
        let extract_to_end%0#0: bytes = ((extract 2 0) space#0)
        let tmp%10#0: uint64 = array_len(space#0)
        let tmp%11#0: Encoded(len+utf8[]) = array_concat(hello#0, extract_to_end%0#0, tmp%10#0)
        let extract_to_end%1#0: bytes = ((extract 2 0) world#0)
        let tmp%12#0: uint64 = array_len(world#0)
        let tmp%13#0: Encoded(len+utf8[]) = array_concat(tmp%11#0, extract_to_end%1#0, tmp%12#0)
        let tmp%14#0: bool = (== tmp%9#0 tmp%13#0)
        (assert tmp%14#0)
        let thing#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("hi")
        let extract_to_end%2#0: bytes = ((extract 2 0) thing#0)
        let tmp%16#0: uint64 = array_len(thing#0)
        let thing#1: Encoded(len+utf8[]) = array_concat(thing#0, extract_to_end%2#0, tmp%16#0)
        let tmp%18#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("hihi")
        let tmp%19#0: bool = (== thing#1 tmp%18#0)
        (assert tmp%19#0)
        let tmp%20#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("a")
        let tmp%21#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("b")
        let extract_to_end%3#0: bytes = ((extract 2 0) tmp%21#0)
        let tmp%22#0: uint64 = array_len(tmp%21#0)
        let tmp%23#0: Encoded(len+utf8[]) = array_concat(tmp%20#0, extract_to_end%3#0, tmp%22#0)
        let tmp%24#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("cd")
        let extract_to_end%4#0: bytes = ((extract 2 0) tmp%24#0)
        let tmp%25#0: uint64 = array_len(tmp%24#0)
        let value#0: Encoded(len+utf8[]) = array_concat(tmp%23#0, extract_to_end%4#0, tmp%25#0)
        let tmp%27#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("e")
        let extract_to_end%5#0: bytes = ((extract 2 0) tmp%27#0)
        let tmp%28#0: uint64 = array_len(tmp%27#0)
        let value#1: Encoded(len+utf8[]) = array_concat(value#0, extract_to_end%5#0, tmp%28#0)
        let tmp%30#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("f")
        let extract_to_end%6#0: bytes = ((extract 2 0) tmp%30#0)
        let tmp%31#0: uint64 = array_len(tmp%30#0)
        let value#2: Encoded(len+utf8[]) = array_concat(value#1, extract_to_end%6#0, tmp%31#0)
        let tmp%33#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("g")
        let extract_to_end%7#0: bytes = ((extract 2 0) tmp%33#0)
        let tmp%34#0: uint64 = array_len(tmp%33#0)
        let value#3: Encoded(len+utf8[]) = array_concat(value#2, extract_to_end%7#0, tmp%34#0)
        let tmp%36#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("abcdefg")
        let tmp%37#0: bool = (== tmp%36#0 value#3)
        (assert tmp%37#0)
        let tmp%44#0: uint64 = (txn NumAppArgs)
        goto tmp%44#0 ? block@1 : block@2
    block@1: // ternary_true_L41
        let ternary_result%0#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("aye")
        goto block@3
    block@2: // ternary_false_L41
        let ternary_result%0#1: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("bee")
        goto block@3
    block@3: // ternary_merge_L41
        let ternary_result%0#2: Encoded(len+utf8[]) = Ï†(ternary_result%0#0 <- block@1, ternary_result%0#1 <- block@2)
        let tmp%46#0: Encoded(len+utf8[]) = bytes_encode<(len+utf8[])>("bee")
        let tmp%47#0: bool = (== ternary_result%0#2 tmp%46#0)
        (assert tmp%47#0)
        return 1u