// Op                                                                                            Stack (out)
// algopy.arc4.ARC4Contract.approval_program() -> uint64:
subroutine main:
    main_block@0:
        // arc4_types/uint_overflow.py:4
        // class UIntOverflow(arc4.ARC4Contract):
        txn NumAppArgs                                                                           tmp%0#1
        bz main_bare_routing@8 ; b main_abi_routing@2

    main_abi_routing@2:
        // arc4_types/uint_overflow.py:4
        // class UIntOverflow(arc4.ARC4Contract):
        txna ApplicationArgs 0                                                                   tmp%2#0
        method test_uint8()void                                                                  tmp%2#0,Method(test_uint8()void)
        method test_uint16()void                                                                 tmp%2#0,Method(test_uint8()void),Method(test_uint16()void)
        method test_uint32()void                                                                 tmp%2#0,Method(test_uint8()void),Method(test_uint16()void),Method(test_uint32()void)
        l-load tmp%2#0 3                                                                         Method(test_uint8()void),Method(test_uint16()void),Method(test_uint32()void),tmp%2#0
        match main_test_uint8_route@3 main_test_uint16_route@4 main_test_uint32_route@5 ; b main_after_if_else@12 

    main_test_uint8_route@3:
        // arc4_types/uint_overflow.py:5
        // @arc4.abimethod()
        txn OnCompletion                                                                         tmp%3#0
        !                                                                                        tmp%4#0
        assert // OnCompletion is not NoOp
        txn ApplicationID                                                                        tmp%5#0
        assert // can only call when not creating
        callsub test_uint8
        int 1                                                                                    test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__%0#0
        v-store tmp%0#0
        b main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13 

    main_test_uint16_route@4:
        // arc4_types/uint_overflow.py:10
        // @arc4.abimethod()
        txn OnCompletion                                                                         tmp%7#0
        !                                                                                        tmp%8#0
        assert // OnCompletion is not NoOp
        txn ApplicationID                                                                        tmp%9#0
        assert // can only call when not creating
        callsub test_uint16
        int 1                                                                                    test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__%0#0
        v-store tmp%0#0
        b main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13 

    main_test_uint32_route@5:
        // arc4_types/uint_overflow.py:15
        // @arc4.abimethod()
        txn OnCompletion                                                                         tmp%11#0
        !                                                                                        tmp%12#0
        assert // OnCompletion is not NoOp
        txn ApplicationID                                                                        tmp%13#0
        assert // can only call when not creating
        callsub test_uint32
        int 1                                                                                    test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__%0#0
        v-store tmp%0#0
        b main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13 

    main_bare_routing@8:
        // arc4_types/uint_overflow.py:4
        // class UIntOverflow(arc4.ARC4Contract):
        txn OnCompletion                                                                         tmp%15#0
        bz main___algopy_default_create@9 ; b main_after_if_else@12

    main___algopy_default_create@9:
        txn ApplicationID                                                                        tmp%16#0
        !                                                                                        tmp%17#0
        assert // can only call when creating
        int 1                                                                                    test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__%0#0
        v-store tmp%0#0
        b main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13 

    main_after_if_else@12:
        // arc4_types/uint_overflow.py:4
        // class UIntOverflow(arc4.ARC4Contract):
        int 0                                                                                    test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__%0#0
        v-store tmp%0#0
        b main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13 

    main_after_inlined_test_cases.arc4_types.uint_overflow.UIntOverflow.__puya_arc4_router__@13:
        v-load tmp%0#0                                                                           tmp%0#0
        return


// test_cases.arc4_types.uint_overflow.UIntOverflow.test_uint8() -> void:
subroutine test_uint8:
    test_uint8_block@0:
        // arc4_types/uint_overflow.py:7
        // too_big = arc4.UInt8(Txn.num_app_args + 2**8)  # should fail here with overflow
        txn NumAppArgs                                                                           tmp%0#0
        int 256                                                                                  tmp%0#0,256
        +                                                                                        tmp%1#0
        itob                                                                                     aggregate%val_as_bytes%0#1
        l-load-copy aggregate%val_as_bytes%0#1 0                                                 aggregate%val_as_bytes%0#1,aggregate%val_as_bytes%0#1 (copy)
        bitlen                                                                                   aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1
        int 8                                                                                    aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1,8
        <=                                                                                       aggregate%val_as_bytes%0#1,aggregate%no_overflow%0#1
        assert // overflow                                                                       aggregate%val_as_bytes%0#1
        l-load aggregate%val_as_bytes%0#1 0                                                      aggregate%val_as_bytes%0#1
        extract 7 1                                                                              too_big#0
        // arc4_types/uint_overflow.py:8
        // assert too_big.bytes != b"\x01", "this should not happen"
        byte 0x01                                                                                too_big#0,0x01
        !=                                                                                       tmp%3#0
        assert // this should not happen
        retsub


// test_cases.arc4_types.uint_overflow.UIntOverflow.test_uint16() -> void:
subroutine test_uint16:
    test_uint16_block@0:
        // arc4_types/uint_overflow.py:12
        // too_big = arc4.UInt16(Txn.num_app_args + 2**16)  # should fail here with overflow
        txn NumAppArgs                                                                           tmp%0#0
        int 65536                                                                                tmp%0#0,65536
        +                                                                                        tmp%1#0
        itob                                                                                     aggregate%val_as_bytes%0#1
        l-load-copy aggregate%val_as_bytes%0#1 0                                                 aggregate%val_as_bytes%0#1,aggregate%val_as_bytes%0#1 (copy)
        bitlen                                                                                   aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1
        int 16                                                                                   aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1,16
        <=                                                                                       aggregate%val_as_bytes%0#1,aggregate%no_overflow%0#1
        assert // overflow                                                                       aggregate%val_as_bytes%0#1
        l-load aggregate%val_as_bytes%0#1 0                                                      aggregate%val_as_bytes%0#1
        extract 6 2                                                                              too_big#0
        // arc4_types/uint_overflow.py:13
        // assert too_big.bytes != b"\x00\x01", "this should not happen"
        byte 0x0001                                                                              too_big#0,0x0001
        !=                                                                                       tmp%3#0
        assert // this should not happen
        retsub


// test_cases.arc4_types.uint_overflow.UIntOverflow.test_uint32() -> void:
subroutine test_uint32:
    test_uint32_block@0:
        // arc4_types/uint_overflow.py:17
        // too_big = arc4.UInt32(Txn.num_app_args + 2**32)  # should fail here with overflow
        txn NumAppArgs                                                                           tmp%0#0
        int 4294967296                                                                           tmp%0#0,4294967296
        +                                                                                        tmp%1#0
        itob                                                                                     aggregate%val_as_bytes%0#1
        l-load-copy aggregate%val_as_bytes%0#1 0                                                 aggregate%val_as_bytes%0#1,aggregate%val_as_bytes%0#1 (copy)
        bitlen                                                                                   aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1
        int 32                                                                                   aggregate%val_as_bytes%0#1,aggregate%bitlen%0#1,32
        <=                                                                                       aggregate%val_as_bytes%0#1,aggregate%no_overflow%0#1
        assert // overflow                                                                       aggregate%val_as_bytes%0#1
        l-load aggregate%val_as_bytes%0#1 0                                                      aggregate%val_as_bytes%0#1
        extract 4 4                                                                              too_big#0
        // arc4_types/uint_overflow.py:18
        // assert too_big.bytes != b"\x00\x00\x00\x01", "this should not happen"
        byte 0x00000001                                                                          too_big#0,0x00000001
        !=                                                                                       tmp%3#0
        assert // this should not happen
        retsub


