HELLO_WORLD = b'Hello World!'

contract Arc4StringTypesContract
{
  approval_program(): bool
  {
    some_bytes_as_string: puyapy.arc4.String = arc4_encode(reinterpret_cast<puyapy.String>(hex<"48656C6C6F20576F726C6421">), puyapy.arc4.String)
    some_bytes_as_bytes_again: puyapy.Bytes = reinterpret_cast<puyapy.Bytes>(arc4_decode(some_bytes_as_string, puyapy.String))
    assert(reinterpret_cast<puyapy.Bytes>(some_bytes_as_string) != 'Hello World!', comment="Original bytes should not match encoded bytes")
    assert(SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string))[select(len(SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string))), 2u, 2u < len(SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string)))):] == 'Hello World!', comment="Original bytes should match encoded if we strip the length header")
    assert(some_bytes_as_bytes_again == 'Hello World!')
    hello: puyapy.arc4.String = arc4_encode('Hello', puyapy.arc4.String)
    space: puyapy.arc4.String = arc4_encode(' ', puyapy.arc4.String)
    world: puyapy.arc4.String = arc4_encode('World!', puyapy.arc4.String)
    assert(reinterpret_cast<puyapy.Bytes>(arc4_encode('Hello World!', puyapy.arc4.String)) == reinterpret_cast<puyapy.Bytes>(hello + space + world))
    thing: puyapy.arc4.String = arc4_encode('hi', puyapy.arc4.String)
    thing.extend(thing)
    assert(reinterpret_cast<puyapy.Bytes>(thing) == reinterpret_cast<puyapy.Bytes>(arc4_encode('hihi', puyapy.arc4.String)))
    value: puyapy.arc4.String = arc4_encode('a', puyapy.arc4.String) + arc4_encode('b', puyapy.arc4.String) + arc4_encode('cd', puyapy.arc4.String)
    value.extend(arc4_encode('e', puyapy.arc4.String))
    value.extend(arc4_encode('f', puyapy.arc4.String))
    value.extend(arc4_encode('g', puyapy.arc4.String))
    assert(reinterpret_cast<puyapy.Bytes>(arc4_encode('abcdefg', puyapy.arc4.String)) == reinterpret_cast<puyapy.Bytes>(value))
    return true
  }
  
  clear_state_program(): bool
  {
    return true
  }
}