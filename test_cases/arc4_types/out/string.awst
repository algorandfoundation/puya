HELLO_WORLD = b'Hello World!'

contract Arc4StringTypesContract
{
  approval_program(): bool
  {
    some_bytes_as_string: arc4.string = arc4_encode(reinterpret_cast<string>(hex<"48656C6C6F20576F726C6421">), arc4.string)
    some_bytes_as_bytes_again: bytes = reinterpret_cast<bytes>(arc4_decode(some_bytes_as_string, string))
    assert(reinterpret_cast<bytes>(some_bytes_as_string) != 'Hello World!', comment="Original bytes should not match encoded bytes")
    assert(reinterpret_cast<bytes>(some_bytes_as_string)[2:] == 'Hello World!', comment="Original bytes should match encoded if we strip the length header")
    assert(some_bytes_as_bytes_again == 'Hello World!')
    hello: arc4.string = arc4_encode('Hello', arc4.string)
    space: arc4.string = arc4_encode(' ', arc4.string)
    world: arc4.string = arc4_encode('World!', arc4.string)
    assert(reinterpret_cast<bytes>(arc4_encode('Hello World!', arc4.string)) == reinterpret_cast<bytes>(hello + space + world))
    thing: arc4.string = arc4_encode('hi', arc4.string)
    thing.extend(thing)
    assert(reinterpret_cast<bytes>(thing) == reinterpret_cast<bytes>(arc4_encode('hihi', arc4.string)))
    value: arc4.string = arc4_encode('a', arc4.string) + arc4_encode('b', arc4.string) + arc4_encode('cd', arc4.string)
    value.extend(arc4_encode('e', arc4.string))
    value.extend(arc4_encode('f', arc4.string))
    value.extend(arc4_encode('g', arc4.string))
    assert(reinterpret_cast<bytes>(arc4_encode('abcdefg', arc4.string)) == reinterpret_cast<bytes>(value))
    assert(arc4_decode(arc4_encode('', arc4.string), string) == '')
    return true
  }
  
  clear_state_program(): bool
  {
    return true
  }
}