contract Arc4StringTypesContract
{
  approval_program(): bool
  {
    some_bytes: puyapy.Bytes = 'Hello World!'
    some_bytes_as_string: puyapy.arc4.String = arc4_encode(some_bytes, puyapy.arc4.String)
    some_bytes_as_bytes_again: puyapy.Bytes = arc4_decode(some_bytes_as_string, puyapy.Bytes)
    assert(some_bytes != reinterpret_cast<puyapy.Bytes>(some_bytes_as_string), comment="Original bytes should not match encoded bytes")
    assert(some_bytes == SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string))[select(len(SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string))), 2u, 2u < len(SINGLE_EVAL(id=0, source=reinterpret_cast<puyapy.Bytes>(some_bytes_as_string)))):], comment="Original bytes should match encoded if we strip the length header")
    assert(some_bytes == some_bytes_as_bytes_again)
    hello: puyapy.arc4.String = arc4_encode('Hello', puyapy.arc4.String)
    space: puyapy.arc4.String = arc4_encode(' ', puyapy.arc4.String)
    world: puyapy.arc4.String = arc4_encode('World!', puyapy.arc4.String)
    assert(reinterpret_cast<puyapy.Bytes>(arc4_encode('Hello World!', puyapy.arc4.String)) == reinterpret_cast<puyapy.Bytes>(hello + space + world))
    thing: puyapy.arc4.String = arc4_encode('hi', puyapy.arc4.String)
    thing.extend(thing)
    assert(reinterpret_cast<puyapy.Bytes>(thing) == reinterpret_cast<puyapy.Bytes>(arc4_encode('hihi', puyapy.arc4.String)))
    value: puyapy.arc4.String = arc4_encode('a', puyapy.arc4.String) + arc4_encode('b', puyapy.arc4.String) + arc4_encode('cd', puyapy.arc4.String)
    value.extend(arc4_encode('e', puyapy.arc4.String))
    value.extend(arc4_encode('f', puyapy.arc4.String))
    value.extend(arc4_encode('g', puyapy.arc4.String))
    assert(reinterpret_cast<puyapy.Bytes>(arc4_encode('abcdefg', puyapy.arc4.String)) == reinterpret_cast<puyapy.Bytes>(value))
    return true
  }
  
  clear_state_program(): bool
  {
    return true
  }
}