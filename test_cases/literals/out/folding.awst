subroutine unary_str(): void
{
  assert(true)
  assert(true)
}

subroutine compare_str(): void
{
  assert(!(false))
  assert(true)
  assert(true)
  assert(true)
  assert(!(false))
  assert(!(false))
  assert(!(false))
  assert(!(false))
  assert(true)
  b: string = 'b'
  assert(!(b == 'a'))
  assert(b != 'a')
  assert(!(algopy_lib_bytes::is_substring(item=reinterpret_cast<bytes>('a'), sequence=reinterpret_cast<bytes>(b))))
  assert(!(algopy_lib_bytes::is_substring(item=reinterpret_cast<bytes>('a'), sequence=reinterpret_cast<bytes>(b))))
  assert(algopy_lib_bytes::is_substring(item=reinterpret_cast<bytes>('a'), sequence=reinterpret_cast<bytes>('abc')))
}

subroutine unary_bytes(): void
{
  assert(true)
  assert(true)
}

subroutine unary_int(): void
{
  assert(true)
  assert(true)
  assert(true)
  assert(true)
  assert(true)
}

subroutine compare_int(): void
{
  assert(!(false))
  assert(true)
  assert(true)
  assert(true)
  assert(!(false))
  assert(!(false))
  one: uint64 = 1u
  assert(!(one == 0u))
  assert(one != 0u)
  assert(one > 0u)
  assert(one >= 0u)
  assert(!(one < 0u))
  assert(!(one <= 0u))
}

subroutine unary_bool(): void
{
  assert(true)
  assert(true)
  assert(true)
  assert(true)
  assert(true)
}

contract LiteralFolding
{
  approval_program(): bool
  {
    test_cases.literals.folding::unary_str()
    test_cases.literals.folding::compare_str()
    test_cases.literals.folding::unary_bytes()
    test_cases.literals.folding::unary_int()
    test_cases.literals.folding::compare_int()
    test_cases.literals.folding::unary_bool()
    return true
  }
  
  clear_state_program(): bool
  {
    return true
  }
}