#pragma version 10

test_cases.typed_abi_call.logger.Logger.approval_program:
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@10
    method "echo(string)string"
    method "log_uint64(uint64)void"
    method "log_uint512(uint512)void"
    method "log_string(string)void"
    method "log_bool(bool)void"
    method "log_bytes(byte[])void"
    txna ApplicationArgs 0
    match main_echo_route@2 main_log_uint64_route@3 main_log_uint512_route@4 main_log_string_route@5 main_log_bool_route@6 main_log_bytes_route@7
    err // reject transaction

main_echo_route@2:
    // typed_abi_call/logger.py:5
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:5
    // @arc4.abimethod
    callsub echo
    byte 0x151f7c75
    swap
    concat
    log
    int 1
    return

main_log_uint64_route@3:
    // typed_abi_call/logger.py:9
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:9
    // @arc4.abimethod
    callsub log_uint64
    int 1
    return

main_log_uint512_route@4:
    // typed_abi_call/logger.py:13
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:13
    // @arc4.abimethod
    callsub log_uint512
    int 1
    return

main_log_string_route@5:
    // typed_abi_call/logger.py:17
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:17
    // @arc4.abimethod
    callsub log_string
    int 1
    return

main_log_bool_route@6:
    // typed_abi_call/logger.py:21
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:21
    // @arc4.abimethod
    callsub log_bool
    int 1
    return

main_log_bytes_route@7:
    // typed_abi_call/logger.py:25
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txna ApplicationArgs 1
    // typed_abi_call/logger.py:25
    // @arc4.abimethod
    callsub log_bytes
    int 1
    return

main_bare_routing@10:
    // typed_abi_call/logger.py:4
    // class Logger(ARC4Contract):
    txn OnCompletion
    !
    assert // reject transaction
    txn ApplicationID
    !
    assert // is creating
    int 1
    return


// test_cases.typed_abi_call.logger.Logger.echo(value: bytes) -> bytes:
echo:
    // typed_abi_call/logger.py:5-6
    // @arc4.abimethod
    // def echo(self, value: arc4.String) -> arc4.String:
    proto 1 1
    // typed_abi_call/logger.py:7
    // return "echo: " + value
    frame_dig -1
    extract 2 0
    byte "echo: "
    swap
    concat
    dup
    len
    itob
    extract 6 0
    swap
    concat
    retsub


// test_cases.typed_abi_call.logger.Logger.log_uint64(value: bytes) -> void:
log_uint64:
    // typed_abi_call/logger.py:9-10
    // @arc4.abimethod
    // def log_uint64(self, value: arc4.UInt64) -> None:
    proto 1 0
    // typed_abi_call/logger.py:11
    // log(value)
    frame_dig -1
    log
    retsub


// test_cases.typed_abi_call.logger.Logger.log_uint512(value: bytes) -> void:
log_uint512:
    // typed_abi_call/logger.py:13-14
    // @arc4.abimethod
    // def log_uint512(self, value: arc4.UInt512) -> None:
    proto 1 0
    // typed_abi_call/logger.py:15
    // log(value)
    frame_dig -1
    log
    retsub


// test_cases.typed_abi_call.logger.Logger.log_string(value: bytes) -> void:
log_string:
    // typed_abi_call/logger.py:17-18
    // @arc4.abimethod
    // def log_string(self, value: arc4.String) -> None:
    proto 1 0
    // typed_abi_call/logger.py:19
    // log(value.decode())  # decode to remove header
    frame_dig -1
    extract 2 0
    log
    retsub


// test_cases.typed_abi_call.logger.Logger.log_bool(value: bytes) -> void:
log_bool:
    // typed_abi_call/logger.py:21-22
    // @arc4.abimethod
    // def log_bool(self, value: arc4.Bool) -> None:
    proto 1 0
    // typed_abi_call/logger.py:23
    // log(Bytes(b"True") if value.decode() else Bytes(b"False"))
    frame_dig -1
    int 0
    getbit
    bz log_bool_ternary_false@2
    byte "True"
    b log_bool_ternary_merge@3

log_bool_ternary_false@2:
    // typed_abi_call/logger.py:23
    // log(Bytes(b"True") if value.decode() else Bytes(b"False"))
    byte "False"

log_bool_ternary_merge@3:
    // typed_abi_call/logger.py:23
    // log(Bytes(b"True") if value.decode() else Bytes(b"False"))
    log
    retsub


// test_cases.typed_abi_call.logger.Logger.log_bytes(value: bytes) -> void:
log_bytes:
    // typed_abi_call/logger.py:25-26
    // @arc4.abimethod
    // def log_bytes(self, value: arc4.DynamicBytes) -> None:
    proto 1 0
    // typed_abi_call/logger.py:27
    // log(value.bytes[2:])  # decode to remove header
    frame_dig -1
    len
    int 2
    dig 1
    <
    swap
    dup
    int 2
    uncover 3
    select
    frame_dig -1
    swap
    uncover 2
    substring3
    log
    retsub
