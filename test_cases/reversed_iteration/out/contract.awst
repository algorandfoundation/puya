contract MyContract
{
  approval_program(): bool
  {
    for i in reversed(range(0u, 0u, 1u)) {
      log(itob(i))
    }
    for x in reversed(arc4_array_encode([], puyapy.arc4.StaticArray[puyapy.arc4.UIntN[typing.Literal[8]], typing.Literal[0]])) {
      log(reinterpret_cast<puyapy.Bytes>(x))
    }
    test_array: puyapy.arc4.StaticArray[puyapy.arc4.UIntN[typing.Literal[8]], typing.Literal[4]] = arc4_array_encode([0arc4u8, 0arc4u8, 0arc4u8, 0arc4u8], puyapy.arc4.StaticArray[puyapy.arc4.UIntN[typing.Literal[8]], typing.Literal[4]])
    for (index, item) in enumerate(reversed(range(0u, 4u, 1u))) {
      test_array[index]: puyapy.arc4.UIntN[typing.Literal[8]] = arc4_encode(item, puyapy.arc4.UIntN[typing.Literal[8]])
    }
    assert(reinterpret_cast<puyapy.Bytes>(test_array) == hex<"03020100">)
    for (index, item) in reversed(enumerate(reversed(range(4u, 8u, 1u)))) {
      test_array[index]: puyapy.arc4.UIntN[typing.Literal[8]] = arc4_encode(item, puyapy.arc4.UIntN[typing.Literal[8]])
      if (index == 2u) {
        break
      }
    }
    assert(reinterpret_cast<puyapy.Bytes>(test_array) == hex<"03020504">)
    some_strings: puyapy.arc4.StaticArray[puyapy.arc4.String, typing.Literal[3]] = arc4_array_encode([arc4_encode('a', puyapy.arc4.String), arc4_encode('b', puyapy.arc4.String), arc4_encode('c', puyapy.arc4.String)], puyapy.arc4.StaticArray[puyapy.arc4.String, typing.Literal[3]])
    some_string_reversed: puyapy.arc4.String = arc4_encode('', puyapy.arc4.String)
    for str_item in reversed(some_strings) {
      some_string_reversed.extend(str_item)
    }
    assert(reinterpret_cast<puyapy.Bytes>(some_string_reversed) == reinterpret_cast<puyapy.Bytes>(arc4_encode('cba', puyapy.arc4.String)))
    bytes_reversed_with_index: puyapy.Bytes = ''
    for (index, bytes_item) in reversed(enumerate('HELLO')) {
      bytes_reversed_with_index += SINGLE_EVAL(id=0, source=itob(index))[len(SINGLE_EVAL(id=0, source=itob(index))) - select(len(SINGLE_EVAL(id=0, source=itob(index))), 1u, 1u < len(SINGLE_EVAL(id=0, source=itob(index)))):] + bytes_item
    }
    assert(bytes_reversed_with_index == '\x04O\x03L\x02L\x01E\x00H')
    for (index, tuple_item) in enumerate(reversed((0u, 1u, 2u, 3u))) {
      assert(index + tuple_item == 3u)
    }
    prev_item: puyapy.UInt64 = 0u
    prev_index: puyapy.UInt64 = 99u
    for (index, tuple_item) in reversed(enumerate(reversed((5u, 6u, 7u, 8u)))) {
      assert(prev_item < tuple_item)
      assert(prev_index > index)
      assert(index + tuple_item == 8u)
      prev_item: puyapy.UInt64 = tuple_item
      prev_index: puyapy.UInt64 = index
    }
    return true
  }
  
  clear_state_program(): bool
  {
    return true
  }
}