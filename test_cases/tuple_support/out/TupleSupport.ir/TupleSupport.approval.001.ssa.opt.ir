main test_cases.tuple_support.tuple_support.TupleSupport.approval_program:
    block@0: // L8
        let tmp%0#0: bool = (txn ApplicationID)
        goto tmp%0#0 ? block@2 : block@1
    block@1: // call __init___L1
        (app_global_put "state" 0u)
        goto block@2
    block@2: // after_if_else_L1
        let total#0: uint64 = test_cases.tuple_support.tuple_support.add_three_values(101u, 102u, 103u)
        let tmp%2#0: bytes = (itob total#0)
        (log tmp%2#0)
        let (did_overflow#0: uint64, result.1#0: uint64) = (addw 1u 2u)
        (app_global_put "state" result.1#0)
        let tmp%5#0: bool = (! did_overflow#0)
        (assert tmp%5#0) // overflow!
        let tmp%6#0: bool = 1u
        let tmp%10#0: bool = 0u
        let tup.0#1: uint64 = 3u
        let tup.1#1: uint64 = 3u
        goto block@5
    block@5: // after_if_else_L20
        let (tup.0#2: uint64, tup.1#2: uint64) = (tup.0#1, tup.1#1)
        let tmp%11#0: bool = 1u
        let tmp%12#0: bool = 1u
        let tmp%13#0: bool = (== 3u tup.0#2)
        (assert tmp%13#0)
        let tmp%14#0: bool = (== 3u tup.1#2)
        (assert tmp%14#0)
        let tmp%15#0: bool = 1u
        let tmp%16#0: bool = 1u
        let tmp%17#0: bool = 1u
        let ternary_result%0.0#0: uint64 = 1u
        let ternary_result%0.1#0: uint64 = 2u
        goto block@8
    block@8: // ternary_merge_L29
        let (m#0: uint64, n#0: uint64) = (ternary_result%0.0#0, ternary_result%0.1#0)
        let tmp%18#0: bool = (== m#0 1u)
        let tmp%19#0: bool = (== n#0 2u)
        let tmp%20#0: bool = (&& tmp%18#0 tmp%19#0)
        (assert tmp%20#0)
        let result#0: bytes = 0x48656c6c6f2c20776f726c6421
        (log 0x48656c6c6f2c20776f726c6421)
        let (a.0#0: uint64, a.1#0: uint64) = (addw 18446744073709551615u 18446744073709551615u)
        let (lo_carry#0: uint64, c_lo#0: uint64) = (addw a.1#0 result.1#0)
        let (hi_carry1#0: uint64, c_mid#0: uint64) = (addw a.0#0 did_overflow#0)
        let (hi_carry2#0: uint64, c_mid#1: uint64) = (addw c_mid#0 lo_carry#0)
        let (did_overflow#1: uint64, c_hi#0: uint64) = (addw hi_carry1#0 hi_carry2#0)
        let tmp%8#1: bool = (! did_overflow#1)
        (assert tmp%8#1) // is such a thing even possible? ðŸ‘½
        let tmp%29#0: bytes = (itob c_hi#0)
        (log tmp%29#0)
        let tmp%30#0: bytes = (itob c_mid#1)
        (log tmp%30#0)
        let tmp%31#0: bytes = (itob c_lo#0)
        (log tmp%31#0)
        let result#1: bytes = 0x
        let _i#0: uint64 = 0u
        goto block@24
    block@24: // for_header_L133
        let _i#1: uint64 = Ï†(_i#0 <- block@8, _i#2 <- block@25)
        let result#2: bytes = Ï†(result#1 <- block@8, result#3 <- block@25)
        let continue_looping%0#0: bool = (< _i#1 5u)
        goto continue_looping%0#0 ? block@25 : block@27
    block@25: // for_body_L134
        let result#3: bytes = (concat result#2 0x6e61)
        let _i#2: uint64 = (+ _i#1 1u)
        goto block@24
    block@27: // after_for_L133
        (log result#2)
        let a#2: uint64 = 1u
        let b#3: uint64 = 2u
        let tmp%2#2: bool = 1u
        let tmp%3#2: bool = 1u
        let tmp%0#6: uint64 = test_cases.tuple_support.tuple_support.add_three_values(1u, 2u, 3u)
        let tmp%1#3: uint64 = 3u
        let tmp%2#3: uint64 = 6u
        let tmp%3#3: bool = (== tmp%0#6 6u)
        (assert tmp%3#3)
        let tmp%4#2: bool = 1u
        let tmp%5#2: bool = 1u
        let tmp%6#2: bool = 1u
        let tmp%7#2: bool = 1u
        let tmp%8#2: bool = 1u
        let tmp%9#1: bool = 1u
        let tmp%0#7: bool = 1u
        let tmp%1#4: bool = 1u
        let tmp%2#4: bool = 1u
        let tmp%3#4: bool = 1u
        let tmp%4#3: bool = 1u
        let tmp%5#3: bool = 1u
        let tmp%6#3: bool = 1u
        let tmp%7#3: bool = 1u
        let tmp%8#3: bool = 1u
        let tmp%9#2: bool = 1u
        let tmp%10#1: bool = 1u
        let tmp%11#1: bool = 1u
        let tmp%12#1: bool = 1u
        let tmp%13#1: bool = 1u
        let tmp%14#1: bool = 1u
        let tmp%15#1: bool = 1u
        (log "non_empty_tuple called")
        let tmp%33#0: bool = 1u
        let tmp%34#0: bool = 1u
        let tmp%35#0: bool = 1u
        (log "not empty")
        (log "get_uint_with_side_effect called")
        let tmp%36#0: bool = 1u
        (log "not empty2")
        let tmp%0#1: bool = 1u
        let tmp%37#0: bool = 1u
        let tmp%38#0: bool = 1u
        let tmp%39#0: uint64 = 3u
        return 3u

subroutine test_cases.tuple_support.tuple_support.add_three_values(values.0: uint64, values.1: uint64, values.2: uint64) -> uint64:
    block@0: // L138
        let total#0: uint64 = 0u
        let loop_counter%0#0: uint64 = 0u
        goto block@1
    block@1: // for_body_L142
        let loop_counter%0#1: uint64 = Ï†(loop_counter%0#0 <- block@0, loop_counter%0#2 <- block@3, loop_counter%0#3 <- block@4)
        let total#1: uint64 = Ï†(total#0 <- block@0, total#2 <- block@3, total#2 <- block@4)
        let value#1: uint64 = Ï†(values.0#0 <- block@0, values.1#0 <- block@3, values.2#0 <- block@4)
        let total#2: uint64 = (+ total#1 value#1)
        goto_nth [block@3, block@4][loop_counter%0#1] else goto block@5
    block@3: // for_header_1_L141
        let loop_counter%0#2: uint64 = 1u
        goto block@1
    block@4: // for_header_2_L141
        let loop_counter%0#3: uint64 = 2u
        goto block@1
    block@5: // after_for_L141
        return total#2