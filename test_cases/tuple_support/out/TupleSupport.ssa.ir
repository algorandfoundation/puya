contract test_cases.tuple_support.tuple_support.TupleSupport:
    program approval:
        subroutine test_cases.tuple_support.tuple_support.TupleSupport.approval_program() -> uint64:
            block@0: // L8
                let app_id%0#0: uint64 = (txn ApplicationID)
                goto app_id%0#0 ? block@2 : block@1
            block@1: // on_create_L5
                test_cases.tuple_support.tuple_support.TupleSupport.__init__()
                goto block@2
            block@2: // entrypoint_L5
                let total#0: uint64 = test_cases.tuple_support.tuple_support.add_three_values(101u, 102u, 103u)
                let tmp%0#0: bytes = (itob total#0)
                (log tmp%0#0)
                let a#0: uint64 = 1u
                let b#0: uint64 = 2u
                let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64) = (addw a#0 b#0)
                let did_overflow#0: uint64 = tuple_assignment%0#0
                (app_global_put "state" tuple_assignment%1#0)
                let reinterpret_bool%0#0: bool = did_overflow#0
                let tmp%1#0: bool = (! reinterpret_bool%0#0)
                (assert tmp%1#0) // overflow!
                let (ab.0#0: uint64, ab.1#0: uint64) = (a#0, b#0)
                let tmp%2#0: bool = (== ab.1#0 ab.1#0)
                (assert tmp%2#0)
                let (result.0#0: uint64, result.1#0: uint64) = (addw a#0 b#0)
                let reinterpret_bool%1#0: bool = result.0#0
                let tmp%3#0: bool = (! reinterpret_bool%1#0)
                (assert tmp%3#0) // overflow!
                let d#0: uint64 = 3u
                let c#0: uint64 = 3u
                let a2#0: uint64 = ab.0#0
                let b2#0: uint64 = ab.1#0
                let (cd.0#0: uint64, cd.1#0: uint64) = (c#0, d#0)
                let (ab2.0#0: uint64, ab2.1#0: uint64) = (ab.0#0, ab.1#0)
                let tmp%4#0: bool = (== a#0 b#0)
                goto tmp%4#0 ? block@3 : block@4
            block@3: // if_body_L21
                let (tup.0#0: uint64, tup.1#0: uint64) = (ab2.0#0, ab2.1#0)
                goto block@5
            block@4: // else_body_L23
                let (tup.0#1: uint64, tup.1#1: uint64) = (cd.0#0, cd.1#0)
                goto block@5
            block@5: // after_if_else_L20
                let tup.0#2: uint64 = Ï†(tup.0#0 <- block@3, tup.0#1 <- block@4)
                let tup.1#2: uint64 = Ï†(tup.1#0 <- block@3, tup.1#1 <- block@4)
                let tmp%5#0: bool = (== a2#0 a#0)
                (assert tmp%5#0)
                let tmp%6#0: bool = (== b2#0 b#0)
                (assert tmp%6#0)
                let tmp%7#0: bool = (== cd.0#0 tup.0#2)
                (assert tmp%7#0)
                let tmp%8#0: bool = (== cd.1#0 tup.1#2)
                (assert tmp%8#0)
                let tmp%9#0: bytes = test_cases.tuple_support.tuple_support.bytes_combine(0x48656c6c6f2c20, 0x776f726c6421)
                (log tmp%9#0)
                let max_uint64#0: uint64 = 18446744073709551615u
                let (tmp%10#0: uint64, tmp%11#0: uint64) = (addw max_uint64#0 max_uint64#0)
                let (tmp%12#0: uint64, tmp%13#0: uint64) = (addw a#0 b#0)
                let (tuple_assignment%2#0: uint64, tuple_assignment%3#0: uint64, tuple_assignment%4#0: uint64) = test_cases.tuple_support.tuple_support.addw2(tmp%10#0, tmp%11#0, tmp%12#0, tmp%13#0)
                let hi#0: uint64 = tuple_assignment%2#0
                let mid#0: uint64 = tuple_assignment%3#0
                let lo#0: uint64 = tuple_assignment%4#0
                let tmp%14#0: bytes = (itob hi#0)
                (log tmp%14#0)
                let tmp%15#0: bytes = (itob mid#0)
                (log tmp%15#0)
                let tmp%16#0: bytes = (itob lo#0)
                (log tmp%16#0)
                let tmp%17#0: bytes = test_cases.tuple_support.tuple_support.bytes_multiply(0x6e61, 5u)
                (log tmp%17#0)
                test_cases.tuple_support.tuple_support.test_tuple_swap(0u)
                test_cases.tuple_support.tuple_support.slicing(1u, 2u, 3u, 4u, 5u, 6u, 7u, 8u)
                test_cases.tuple_support.tuple_support.bin_ops()
                let (awst_tmp%0#0: uint64, awst_tmp%1#0: uint64) = test_cases.tuple_support.tuple_support.non_empty_tuple()
                let awst_tmp%2#0: uint64 = awst_tmp%0#0
                let tmp%18#0: bool = (== awst_tmp%2#0 awst_tmp%2#0)
                let awst_tmp%3#0: uint64 = awst_tmp%1#0
                let tmp%19#0: bool = (== awst_tmp%3#0 awst_tmp%3#0)
                let tmp%20#0: bool = (|| tmp%18#0 tmp%19#0)
                goto tmp%20#0 ? block@6 : block@7
            block@6: // if_body_L53
                (log "not empty")
                goto block@7
            block@7: // after_if_else_L52
                let awst_tmp%4#0: uint64 = test_cases.tuple_support.tuple_support.get_uint_with_side_effect()
                let tmp%21#0: bool = (== awst_tmp%4#0 awst_tmp%4#0)
                goto tmp%21#0 ? block@8 : block@9
            block@8: // if_body_L55
                (log "not empty2")
                goto block@9
            block@9: // after_if_else_L54
                test_cases.tuple_support.tuple_support.single_tuple()
                let (x.0#0: uint64, x.1#0: bytes) = (0u, 0x)
                let tmp%22#0: bool = (== x.0#0 0u)
                (assert tmp%22#0)
                let tmp%23#0: bool = (== x.1#0 0x)
                (assert tmp%23#0)
                let tmp%24#0: uint64 = (+ a#0 b#0)
                return tmp%24#0
        
        subroutine test_cases.tuple_support.tuple_support.add_three_values(values.0: uint64, values.1: uint64, values.2: uint64) -> uint64:
            block@0: // L130
                let total#0: uint64 = 0u
                let loop_counter%0#0: uint64 = 0u
                let value#0: uint64 = values.0#0
                goto block@1
            block@1: // for_body_L134
                let loop_counter%0#1: uint64 = Ï†(loop_counter%0#0 <- block@0, loop_counter%0#2 <- block@3, loop_counter%0#3 <- block@4)
                let total#1: uint64 = Ï†(total#0 <- block@0, total#2 <- block@3, total#2 <- block@4)
                let value#1: uint64 = Ï†(value#0 <- block@0, value#2 <- block@3, value#3 <- block@4)
                let total#2: uint64 = (+ total#1 value#1)
                goto block@2
            block@2: // for_footer_L133
                goto_nth [block@3, block@4][loop_counter%0#1] else goto block@5
            block@3: // for_header_1_L133
                let loop_counter%0#2: uint64 = 1u
                let value#2: uint64 = values.1#0
                goto block@1
            block@4: // for_header_2_L133
                let loop_counter%0#3: uint64 = 2u
                let value#3: uint64 = values.2#0
                goto block@1
            block@5: // after_for_L133
                return total#2
        
        subroutine test_cases.tuple_support.tuple_support.bytes_combine(arg.0: bytes, arg.1: bytes) -> bytes:
            block@0: // L114
                let a#0: bytes = arg.0#0
                let b#0: bytes = arg.1#0
                let result#0: bytes = (concat a#0 b#0)
                return result#0
        
        subroutine test_cases.tuple_support.tuple_support.addw2(a.0: uint64, a.1: uint64, b.0: uint64, b.1: uint64) -> <uint64, uint64, uint64>:
            block@0: // L139
                let a_hi#0: uint64 = a.0#0
                let a_lo#0: uint64 = a.1#0
                let b_hi#0: uint64 = b.0#0
                let b_lo#0: uint64 = b.1#0
                let (tuple_assignment%0#0: uint64, tuple_assignment%1#0: uint64) = (addw a_lo#0 b_lo#0)
                let lo_carry#0: uint64 = tuple_assignment%0#0
                let c_lo#0: uint64 = tuple_assignment%1#0
                let (tuple_assignment%2#0: uint64, tuple_assignment%3#0: uint64) = (addw a_hi#0 b_hi#0)
                let hi_carry1#0: uint64 = tuple_assignment%2#0
                let c_mid#0: uint64 = tuple_assignment%3#0
                let (tuple_assignment%4#0: uint64, tuple_assignment%5#0: uint64) = (addw c_mid#0 lo_carry#0)
                let hi_carry2#0: uint64 = tuple_assignment%4#0
                let c_mid#1: uint64 = tuple_assignment%5#0
                let (tuple_assignment%6#0: uint64, tuple_assignment%7#0: uint64) = (addw hi_carry1#0 hi_carry2#0)
                let did_overflow#0: uint64 = tuple_assignment%6#0
                let c_hi#0: uint64 = tuple_assignment%7#0
                let reinterpret_bool%0#0: bool = did_overflow#0
                let tmp%0#0: bool = (! reinterpret_bool%0#0)
                (assert tmp%0#0) // is such a thing even possible? ðŸ‘½
                return c_hi#0 c_mid#1 c_lo#0
        
        subroutine test_cases.tuple_support.tuple_support.bytes_multiply(arg.0: bytes, arg.1: uint64) -> bytes:
            block@0: // L121
                let b#0: bytes = arg.0#0
                let count#0: uint64 = arg.1#0
                let result#0: bytes = 0x
                (assert 1u) // Step cannot be zero
                let _i#0: uint64 = 0u
                goto block@1
            block@1: // for_header_L125
                let _i#1: uint64 = Ï†(_i#0 <- block@0, _i#2 <- block@3)
                let result#1: bytes = Ï†(result#0 <- block@0, result#2 <- block@3)
                let continue_looping%0#0: bool = (< _i#1 count#0)
                goto continue_looping%0#0 ? block@2 : block@4
            block@2: // for_body_L126
                let result#2: bytes = (concat result#1 b#0)
                goto block@3
            block@3: // for_footer_L125
                let _i#2: uint64 = (+ _i#1 1u)
                goto block@1
            block@4: // after_for_L125
                return result#1
        
        subroutine test_cases.tuple_support.tuple_support.test_tuple_swap(zero: uint64) -> void:
            block@0: // L151
                let a#0: uint64 = (+ zero#0 1u)
                let b#0: uint64 = (+ zero#0 2u)
                let a#1: uint64 = b#0
                let b#1: uint64 = a#0
                let tmp%0#0: bool = (== a#1 2u)
                (assert tmp%0#0) // a should be two
                let tmp%1#0: bool = (== b#1 1u)
                (assert tmp%1#0) // b should be one
                return 
        
        subroutine test_cases.tuple_support.tuple_support.slicing(values.0: uint64, values.1: uint64, values.2: uint64, values.3: uint64, values.4: uint64, values.5: uint64, values.6: uint64, values.7: uint64) -> void:
            block@0: // L160
                let (one_to_three.0#0: uint64, one_to_three.1#0: uint64, one_to_three.2#0: uint64) = (values.0#0, values.1#0, values.2#0)
                let tmp%0#0: uint64 = test_cases.tuple_support.tuple_support.add_three_values(one_to_three.0#0, one_to_three.1#0, one_to_three.2#0)
                let tmp%1#0: uint64 = (+ values.0#0 values.1#0)
                let tmp%2#0: uint64 = (+ tmp%1#0 values.2#0)
                let tmp%3#0: bool = (== tmp%0#0 tmp%2#0)
                (assert tmp%3#0)
                let tmp%4#0: bool = (== one_to_three.1#0 one_to_three.1#0)
                (assert tmp%4#0)
                let (awst_tmp%0#0: uint64, awst_tmp%1#0: uint64, awst_tmp%2#0: uint64) = (one_to_three.0#0, one_to_three.1#0, one_to_three.2#0)
                let tmp%5#0: bool = (== one_to_three.0#0 awst_tmp%0#0)
                let tmp%6#0: bool = (== one_to_three.1#0 awst_tmp%1#0)
                let tmp%7#0: bool = (&& tmp%5#0 tmp%6#0)
                let tmp%8#0: bool = (== one_to_three.2#0 awst_tmp%2#0)
                let tmp%9#0: bool = (&& tmp%7#0 tmp%8#0)
                (assert tmp%9#0)
                return 
        
        subroutine test_cases.tuple_support.tuple_support.bin_ops() -> void:
            block@0: // L86
                let (a.0#0: uint64, a.1#0: uint64, a.2#0: uint64) = (1u, 1u, 1u)
                let tmp%0#0: bool = (== a.0#0 1u)
                (assert tmp%0#0)
                let tmp%1#0: bool = (== a.1#0 1u)
                (assert tmp%1#0)
                let tmp%2#0: bool = (== a.2#0 1u)
                (assert tmp%2#0)
                let (tup.0#0: uint64, tup.1#0: uint64) = (1u, 2u)
                let (b.0#0: uint64, b.1#0: uint64, b.2#0: uint64, b.3#0: uint64, b.4#0: uint64, b.5#0: uint64) = (tup.0#0, tup.1#0, tup.0#0, tup.1#0, tup.0#0, tup.1#0)
                let tmp%3#0: bool = (== b.0#0 1u)
                (assert tmp%3#0)
                let tmp%4#0: bool = (== b.1#0 2u)
                (assert tmp%4#0)
                let tmp%5#0: bool = (== b.2#0 1u)
                (assert tmp%5#0)
                let tmp%6#0: bool = (== b.3#0 2u)
                (assert tmp%6#0)
                let tmp%7#0: bool = (== b.4#0 1u)
                (assert tmp%7#0)
                let tmp%8#0: bool = (== b.5#0 2u)
                (assert tmp%8#0)
                let (c.0#0: uint64, c.1#0: bytes, c.2#0: uint64) = (1u, 0x32, 3u)
                let tmp%9#0: bool = (== c.0#0 1u)
                (assert tmp%9#0)
                let tmp%10#0: bool = (== c.1#0 0x32)
                (assert tmp%10#0)
                let tmp%11#0: bool = (== c.2#0 3u)
                (assert tmp%11#0)
                let (d.0#0: uint64, d.1#0: uint64, d.2#0: uint64, d.3#0: uint64) = (tup.0#0, tup.1#0, tup.0#0, tup.1#0)
                let tmp%12#0: bool = (== d.0#0 1u)
                (assert tmp%12#0)
                let tmp%13#0: bool = (== d.1#0 2u)
                (assert tmp%13#0)
                let tmp%14#0: bool = (== d.2#0 1u)
                (assert tmp%14#0)
                let tmp%15#0: bool = (== d.3#0 2u)
                (assert tmp%15#0)
                return 
        
        subroutine test_cases.tuple_support.tuple_support.non_empty_tuple() -> <uint64, uint64>:
            block@0: // L80
                (log "non_empty_tuple called")
                return 4u 2u
        
        subroutine test_cases.tuple_support.tuple_support.get_uint_with_side_effect() -> uint64:
            block@0: // L74
                (log "get_uint_with_side_effect called")
                return 4u
        
        subroutine test_cases.tuple_support.tuple_support.single_tuple() -> void:
            block@0: // L68
                let tup.0#0: uint64 = (1u)
                let tmp%0#0: bool = (== tup.0#0 1u)
                (assert tmp%0#0)
                return 
        
        subroutine test_cases.tuple_support.tuple_support.TupleSupport.__init__() -> void:
            block@0: // L5
                (app_global_put "state" 0u)
                return 
    
    program clear-state:
        subroutine test_cases.tuple_support.tuple_support.TupleSupport.clear_state_program() -> uint64:
            block@0: // L64
                return 0u