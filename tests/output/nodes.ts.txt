/* AUTOGENERATED FILE - DO NOT EDIT (see puya/scripts/generate_ts_nodes.py) */
import { classes } from 'polytype'
import type { Props } from '../typescript-helpers'
import type { ContractReference, LogicSigReference, OnCompletionAction } from './models'
import type { SourceLocation } from './source-location'
import type { TxnField } from './txn-fields'
import type { wtypes } from './wtypes'
export abstract class Node{
  constructor(props: Props<Node>) {
    this.sourceLocation = props.sourceLocation
  }
  readonly sourceLocation: SourceLocation
}
export abstract class Statement extends Node {
  constructor(props: Props<Statement>) {
    super(props)
  }
  abstract accept<T>(visitor: StatementVisitor<T>): T
}
export abstract class Expression extends Node {
  constructor(props: Props<Expression>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  abstract accept<T>(visitor: ExpressionVisitor<T>): T
}
export class ExpressionStatement extends Statement {
  constructor(props: Props<ExpressionStatement>) {
    super(props)
    this.expr = props.expr
    this.sourceLocation = props.sourceLocation
  }
  readonly expr: Expression
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitExpressionStatement(this)
   }
}
export class Block extends Statement {
  constructor(props: Props<Block>) {
    super(props)
    this.body = props.body
    this.label = props.label
    this.comment = props.comment
  }
  readonly body: Array<Statement>
  readonly label: string | null
  readonly comment: string | null
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitBlock(this)
   }
}
export class Goto extends Statement {
  constructor(props: Props<Goto>) {
    super(props)
    this.target = props.target
  }
  readonly target: string
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitGoto(this)
   }
}
export class IfElse extends Statement {
  constructor(props: Props<IfElse>) {
    super(props)
    this.condition = props.condition
    this.ifBranch = props.ifBranch
    this.elseBranch = props.elseBranch
  }
  readonly condition: Expression
  readonly ifBranch: Block
  readonly elseBranch: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitIfElse(this)
   }
}
export class Switch extends Statement {
  constructor(props: Props<Switch>) {
    super(props)
    this.value = props.value
    this.cases = props.cases
    this.defaultCase = props.defaultCase
  }
  readonly value: Expression
  readonly cases: Map<Expression, Block>
  readonly defaultCase: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitSwitch(this)
   }
}
export class WhileLoop extends Statement {
  constructor(props: Props<WhileLoop>) {
    super(props)
    this.condition = props.condition
    this.loopBody = props.loopBody
  }
  readonly condition: Expression
  readonly loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitWhileLoop(this)
   }
}
export class LoopExit extends Statement {
  constructor(props: Props<LoopExit>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitLoopExit(this)
   }
}
export class LoopContinue extends Statement {
  constructor(props: Props<LoopContinue>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitLoopContinue(this)
   }
}
export class ReturnStatement extends Statement {
  constructor(props: Props<ReturnStatement>) {
    super(props)
    this.value = props.value
  }
  readonly value: Expression | null
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitReturnStatement(this)
   }
}
export class AssertExpression extends Expression {
  constructor(props: Props<AssertExpression>) {
    super(props)
    this.condition = props.condition
    this.errorMessage = props.errorMessage
    this.wtype = props.wtype
  }
  readonly condition: Expression | null
  readonly errorMessage: string | null
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitAssertExpression(this)
   }
}
export class IntegerConstant extends Expression {
  constructor(props: Props<IntegerConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.tealAlias = props.tealAlias
  }
  readonly wtype: wtypes.WType
  readonly value: bigint
  readonly tealAlias: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitIntegerConstant(this)
   }
}
export class DecimalConstant extends Expression {
  constructor(props: Props<DecimalConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.ARC4UFixedNxM
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitDecimalConstant(this)
   }
}
export class BoolConstant extends Expression {
  constructor(props: Props<BoolConstant>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: boolean
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBoolConstant(this)
   }
}
export enum BytesEncoding {
  unknown = "unknown",
  base16 = "base16",
  base32 = "base32",
  base64 = "base64",
  utf8 = "utf8",
}
export class BytesConstant extends Expression {
  constructor(props: Props<BytesConstant>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
    this.encoding = props.encoding
  }
  readonly value: Uint8Array
  readonly wtype: wtypes.WType
  readonly encoding: BytesEncoding
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBytesConstant(this)
   }
}
export class StringConstant extends Expression {
  constructor(props: Props<StringConstant>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: string
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitStringConstant(this)
   }
}
export class VoidConstant extends Expression {
  constructor(props: Props<VoidConstant>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitVoidConstant(this)
   }
}
export class TemplateVar extends Expression {
  constructor(props: Props<TemplateVar>) {
    super(props)
    this.wtype = props.wtype
    this.name = props.name
  }
  readonly wtype: wtypes.WType
  readonly name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitTemplateVar(this)
   }
}
export class MethodConstant extends Expression {
  constructor(props: Props<MethodConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.WType
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitMethodConstant(this)
   }
}
export class AddressConstant extends Expression {
  constructor(props: Props<AddressConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.WType
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitAddressConstant(this)
   }
}
export class ARC4Encode extends Expression {
  constructor(props: Props<ARC4Encode>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: Expression
  readonly wtype: wtypes.ARC4Type
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitARC4Encode(this)
   }
}
export class ARC4Decode extends Expression {
  constructor(props: Props<ARC4Decode>) {
    super(props)
    this.value = props.value
  }
  readonly value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitARC4Decode(this)
   }
}
export class Copy extends Expression {
  constructor(props: Props<Copy>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCopy(this)
   }
}
export class ArrayConcat extends Expression {
  constructor(props: Props<ArrayConcat>) {
    super(props)
    this.left = props.left
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly right: Expression
  readonly wtype: wtypes.ARC4DynamicArray | wtypes.StackArray
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitArrayConcat(this)
   }
}
export class ArrayExtend extends Expression {
  constructor(props: Props<ArrayExtend>) {
    super(props)
    this.base = props.base
    this.other = props.other
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly other: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitArrayExtend(this)
   }
}
export class ArrayPop extends Expression {
  constructor(props: Props<ArrayPop>) {
    super(props)
    this.base = props.base
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitArrayPop(this)
   }
}
export class ArrayReplace extends Expression {
  constructor(props: Props<ArrayReplace>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly index: Expression
  readonly value: Expression
  readonly wtype: wtypes.StackArray
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitArrayReplace(this)
   }
}
export class SizeOf extends Expression {
  constructor(props: Props<SizeOf>) {
    super(props)
    this.sizeWtype = props.sizeWtype
    this.wtype = props.wtype
  }
  readonly sizeWtype: wtypes.WType
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSizeOf(this)
   }
}
export class IntrinsicCall extends Expression {
  constructor(props: Props<IntrinsicCall>) {
    super(props)
    this.opCode = props.opCode
    this.immediates = props.immediates
    this.stackArgs = props.stackArgs
  }
  readonly opCode: string
  readonly immediates: Array<string | bigint>
  readonly stackArgs: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitIntrinsicCall(this)
   }
}
export class CreateInnerTransaction extends Expression {
  constructor(props: Props<CreateInnerTransaction>) {
    super(props)
    this.wtype = props.wtype
    this.fields = props.fields
  }
  readonly wtype: wtypes.WInnerTransactionFields
  readonly fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCreateInnerTransaction(this)
   }
}
export class UpdateInnerTransaction extends Expression {
  constructor(props: Props<UpdateInnerTransaction>) {
    super(props)
    this.itxn = props.itxn
    this.fields = props.fields
    this.wtype = props.wtype
  }
  readonly itxn: Expression
  readonly fields: Map<TxnField, Expression>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitUpdateInnerTransaction(this)
   }
}
export class GroupTransactionReference extends Expression {
  constructor(props: Props<GroupTransactionReference>) {
    super(props)
    this.index = props.index
    this.wtype = props.wtype
  }
  readonly index: Expression
  readonly wtype: wtypes.WGroupTransaction
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitGroupTransactionReference(this)
   }
}
export class CheckedMaybe extends Expression {
  constructor(props: Props<CheckedMaybe>) {
    super(props)
    this.expr = props.expr
    this.comment = props.comment
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  readonly expr: Expression
  readonly comment: string
  readonly wtype: wtypes.WType
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCheckedMaybe(this)
   }
}
export class TupleExpression extends Expression {
  constructor(props: Props<TupleExpression>) {
    super(props)
    this.items = props.items
    this.wtype = props.wtype
  }
  readonly items: Array<Expression>
  readonly wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitTupleExpression(this)
   }
}
export class TupleItemExpression extends Expression {
  constructor(props: Props<TupleItemExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly index: bigint
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitTupleItemExpression(this)
   }
}
export class VarExpression extends Expression {
  constructor(props: Props<VarExpression>) {
    super(props)
    this.name = props.name
  }
  readonly name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitVarExpression(this)
   }
}
export class InnerTransactionField extends Expression {
  constructor(props: Props<InnerTransactionField>) {
    super(props)
    this.itxn = props.itxn
    this.field = props.field
    this.arrayIndex = props.arrayIndex
  }
  readonly itxn: Expression
  readonly field: TxnField
  readonly arrayIndex: Expression | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitInnerTransactionField(this)
   }
}
export class SetInnerTransactionFields extends Expression {
  constructor(props: Props<SetInnerTransactionFields>) {
    super(props)
    this.itxns = props.itxns
    this.startWithBegin = props.startWithBegin
    this.wtype = props.wtype
  }
  readonly itxns: Array<Expression>
  readonly startWithBegin: boolean
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSetInnerTransactionFields(this)
   }
}
export class SubmitInnerTransaction extends Expression {
  constructor(props: Props<SubmitInnerTransaction>) {
    super(props)
    this.itxns = props.itxns
    this.wtype = props.wtype
  }
  readonly itxns: Array<Expression>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSubmitInnerTransaction(this)
   }
}
export class FieldExpression extends Expression {
  constructor(props: Props<FieldExpression>) {
    super(props)
    this.base = props.base
    this.name = props.name
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly name: string
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitFieldExpression(this)
   }
}
export class IndexExpression extends Expression {
  constructor(props: Props<IndexExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly index: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitIndexExpression(this)
   }
}
export class SliceExpression extends Expression {
  constructor(props: Props<SliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly beginIndex: Expression | null
  readonly endIndex: Expression | null
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSliceExpression(this)
   }
}
export class IntersectionSliceExpression extends Expression {
  constructor(props: Props<IntersectionSliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly beginIndex: Expression | bigint | null
  readonly endIndex: Expression | bigint | null
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitIntersectionSliceExpression(this)
   }
}
export enum AppStorageKind {
  appGlobal = 1,
  accountLocal = 2,
  box = 3,
}
export class AppStateExpression extends Expression {
  constructor(props: Props<AppStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitAppStateExpression(this)
   }
}
export class AppAccountStateExpression extends Expression {
  constructor(props: Props<AppAccountStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
    this.account = props.account
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  readonly account: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitAppAccountStateExpression(this)
   }
}
export class BoxPrefixedKeyExpression extends Expression {
  constructor(props: Props<BoxPrefixedKeyExpression>) {
    super(props)
    this.prefix = props.prefix
    this.key = props.key
    this.wtype = props.wtype
  }
  readonly prefix: Expression
  readonly key: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBoxPrefixedKeyExpression(this)
   }
}
export class BoxValueExpression extends Expression {
  constructor(props: Props<BoxValueExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBoxValueExpression(this)
   }
}
export class SingleEvaluation extends Expression {
  constructor(props: Props<SingleEvaluation>) {
    super(props)
    this.source = props.source
    this.id = props.id
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  readonly source: Expression
  readonly id: symbol
  readonly wtype: wtypes.WType
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSingleEvaluation(this)
   }
}
export class ReinterpretCast extends Expression {
  constructor(props: Props<ReinterpretCast>) {
    super(props)
    this.expr = props.expr
  }
  readonly expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitReinterpretCast(this)
   }
}
export class NewArray extends Expression {
  constructor(props: Props<NewArray>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  readonly wtype: wtypes.ARC4DynamicArray | wtypes.ARC4StaticArray | wtypes.ReferenceArray | wtypes.StackArray
  readonly values: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitNewArray(this)
   }
}
export class ArrayLength extends Expression {
  constructor(props: Props<ArrayLength>) {
    super(props)
    this.array = props.array
    this.wtype = props.wtype
  }
  readonly array: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitArrayLength(this)
   }
}
export class ConditionalExpression extends Expression {
  constructor(props: Props<ConditionalExpression>) {
    super(props)
    this.condition = props.condition
    this.trueExpr = props.trueExpr
    this.falseExpr = props.falseExpr
    this.wtype = props.wtype
  }
  readonly condition: Expression
  readonly trueExpr: Expression
  readonly falseExpr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitConditionalExpression(this)
   }
}
export class AssignmentStatement extends Statement {
  constructor(props: Props<AssignmentStatement>) {
    super(props)
    this.target = props.target
    this.value = props.value
  }
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitAssignmentStatement(this)
   }
}
export class AssignmentExpression extends Expression {
  constructor(props: Props<AssignmentExpression>) {
    super(props)
    this.target = props.target
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitAssignmentExpression(this)
   }
}
export class CommaExpression extends Expression {
  constructor(props: Props<CommaExpression>) {
    super(props)
    this.expressions = props.expressions
    this.wtype = props.wtype
  }
  readonly expressions: Array<Expression>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCommaExpression(this)
   }
}
export enum EqualityComparison {
  eq = "==",
  ne = "!=",
}
export enum NumericComparison {
  eq = "==",
  ne = "!=",
  lt = "<",
  lte = "<=",
  gt = ">",
  gte = ">=",
}
export class NumericComparisonExpression extends Expression {
  constructor(props: Props<NumericComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  readonly wtype: wtypes.WType
  readonly lhs: Expression
  readonly operator: NumericComparison
  readonly rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitNumericComparisonExpression(this)
   }
}
export class BytesComparisonExpression extends Expression {
  constructor(props: Props<BytesComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  readonly wtype: wtypes.WType
  readonly lhs: Expression
  readonly operator: EqualityComparison
  readonly rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBytesComparisonExpression(this)
   }
}
export class SubroutineID{
  constructor(props: Props<SubroutineID>) {
    this.target = props.target
  }
  readonly target: string
}
export class InstanceMethodTarget{
  constructor(props: Props<InstanceMethodTarget>) {
    this.memberName = props.memberName
  }
  readonly memberName: string
}
export class InstanceSuperMethodTarget{
  constructor(props: Props<InstanceSuperMethodTarget>) {
    this.memberName = props.memberName
  }
  readonly memberName: string
}
export class ContractMethodTarget{
  constructor(props: Props<ContractMethodTarget>) {
    this.cref = props.cref
    this.memberName = props.memberName
  }
  readonly cref: ContractReference
  readonly memberName: string
}
export class CallArg{
  constructor(props: Props<CallArg>) {
    this.name = props.name
    this.value = props.value
  }
  readonly name: string | null
  readonly value: Expression
}
export class SubroutineCallExpression extends Expression {
  constructor(props: Props<SubroutineCallExpression>) {
    super(props)
    this.target = props.target
    this.args = props.args
  }
  readonly target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget
  readonly args: Array<CallArg>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitSubroutineCallExpression(this)
   }
}
export class PuyaLibData{
  constructor(props: Props<PuyaLibData>) {
    this.id = props.id
    this.params = props.params
    this.wtype = props.wtype
  }
  readonly id: string
  readonly params: Map<string, wtypes.WType>
  readonly wtype: wtypes.WType
}
export enum PuyaLibFunction {
  ensureBudget = "ensure_budget",
  isSubstring = "is_substring",
}
export class PuyaLibCall extends Expression {
  constructor(props: Props<PuyaLibCall>) {
    super(props)
    this.func = props.func
    this.args = props.args
    this.wtype = props.wtype
  }
  readonly func: PuyaLibFunction
  readonly args: Array<CallArg>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitPuyaLibCall(this)
   }
}
export enum UInt64BinaryOperator {
  add = "+",
  sub = "-",
  mult = "*",
  floorDiv = "//",
  mod = "%",
  pow = "**",
  lshift = "<<",
  rshift = ">>",
  bitOr = "|",
  bitXor = "^",
  bitAnd = "&",
}
export enum BigUIntBinaryOperator {
  add = "+",
  sub = "-",
  mult = "*",
  floorDiv = "//",
  mod = "%",
  bitOr = "|",
  bitXor = "^",
  bitAnd = "&",
}
export enum BytesBinaryOperator {
  add = "+",
  bitOr = "|",
  bitXor = "^",
  bitAnd = "&",
}
export enum BytesUnaryOperator {
  bitInvert = "~",
}
export enum UInt64UnaryOperator {
  bitInvert = "~",
}
export enum UInt64PostfixUnaryOperator {
  increment = "++",
  decrement = "--",
}
export class UInt64UnaryOperation extends Expression {
  constructor(props: Props<UInt64UnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly op: UInt64UnaryOperator
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitUInt64UnaryOperation(this)
   }
}
export class UInt64PostfixUnaryOperation extends Expression {
  constructor(props: Props<UInt64PostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  readonly op: UInt64PostfixUnaryOperator
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitUInt64PostfixUnaryOperation(this)
   }
}
export enum BigUIntPostfixUnaryOperator {
  increment = "++",
  decrement = "--",
}
export class BigUIntPostfixUnaryOperation extends Expression {
  constructor(props: Props<BigUIntPostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  readonly op: BigUIntPostfixUnaryOperator
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBigUIntPostfixUnaryOperation(this)
   }
}
export class BytesUnaryOperation extends Expression {
  constructor(props: Props<BytesUnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly op: BytesUnaryOperator
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBytesUnaryOperation(this)
   }
}
export class UInt64BinaryOperation extends Expression {
  constructor(props: Props<UInt64BinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: UInt64BinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitUInt64BinaryOperation(this)
   }
}
export class BigUIntBinaryOperation extends Expression {
  constructor(props: Props<BigUIntBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BigUIntBinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBigUIntBinaryOperation(this)
   }
}
export class BytesBinaryOperation extends Expression {
  constructor(props: Props<BytesBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BytesBinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBytesBinaryOperation(this)
   }
}
export enum BinaryBooleanOperator {
  and = "and",
  or = "or",
}
export class BooleanBinaryOperation extends Expression {
  constructor(props: Props<BooleanBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BinaryBooleanOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitBooleanBinaryOperation(this)
   }
}
export class Not extends Expression {
  constructor(props: Props<Not>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitNot(this)
   }
}
export class UInt64AugmentedAssignment extends Statement {
  constructor(props: Props<UInt64AugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly op: UInt64BinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitUInt64AugmentedAssignment(this)
   }
}
export class BigUIntAugmentedAssignment extends Statement {
  constructor(props: Props<BigUIntAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly op: BigUIntBinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitBigUIntAugmentedAssignment(this)
   }
}
export class BytesAugmentedAssignment extends Statement {
  constructor(props: Props<BytesAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly op: BytesBinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitBytesAugmentedAssignment(this)
   }
}
export class Emit extends Expression {
  constructor(props: Props<Emit>) {
    super(props)
    this.signature = props.signature
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly signature: string
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitEmit(this)
   }
}
export class Range extends Expression {
  constructor(props: Props<Range>) {
    super(props)
    this.wtype = props.wtype
    this.start = props.start
    this.stop = props.stop
    this.step = props.step
  }
  readonly wtype: wtypes.WType
  readonly start: Expression
  readonly stop: Expression
  readonly step: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitRange(this)
   }
}
export class Enumeration extends Expression {
  constructor(props: Props<Enumeration>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WEnumeration
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitEnumeration(this)
   }
}
export class Reversed extends Expression {
  constructor(props: Props<Reversed>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitReversed(this)
   }
}
export class ForInLoop extends Statement {
  constructor(props: Props<ForInLoop>) {
    super(props)
    this.sequence = props.sequence
    this.items = props.items
    this.loopBody = props.loopBody
  }
  readonly sequence: Expression
  readonly items: VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
     return visitor.visitForInLoop(this)
   }
}
export class StateGet extends Expression {
  constructor(props: Props<StateGet>) {
    super(props)
    this.field = props.field
    this.default = props.default
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly default: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitStateGet(this)
   }
}
export class StateGetEx extends Expression {
  constructor(props: Props<StateGetEx>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitStateGetEx(this)
   }
}
export class StateExists extends Expression {
  constructor(props: Props<StateExists>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitStateExists(this)
   }
}
export class StateDelete extends Expression {
  constructor(props: Props<StateDelete>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitStateDelete(this)
   }
}
export class NewStruct extends Expression {
  constructor(props: Props<NewStruct>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  readonly wtype: wtypes.WStructType | wtypes.ARC4Struct
  readonly values: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitNewStruct(this)
   }
}
export abstract class RootNode extends Node {
  constructor(props: Props<RootNode>) {
    super(props)
  }
  abstract accept<T>(visitor: RootNodeVisitor<T>): T
}
export class SubroutineArgument{
  constructor(props: Props<SubroutineArgument>) {
    this.name = props.name
    this.sourceLocation = props.sourceLocation
    this.wtype = props.wtype
  }
  readonly name: string
  readonly sourceLocation: SourceLocation
  readonly wtype: wtypes.WType
}
export class MethodDocumentation{
  constructor(props: Props<MethodDocumentation>) {
    this.description = props.description
    this.args = props.args
    this.returns = props.returns
  }
  readonly description: string | null
  readonly args: Map<string, string>
  readonly returns: string | null
}
export abstract class _Function extends Node {
  constructor(props: Props<_Function>) {
    super(props)
    this.args = props.args
    this.returnType = props.returnType
    this.body = props.body
    this.documentation = props.documentation
    this.inline = props.inline
  }
  readonly args: Array<SubroutineArgument>
  readonly returnType: wtypes.WType
  readonly body: Block
  readonly documentation: MethodDocumentation
  readonly inline: boolean | null
}
export class Subroutine extends classes(_Function,RootNode) {
  constructor(props: Props<Subroutine>) {
    super(
[props], [props]
)
    this.id = props.id
    this.name = props.name
  }
  readonly id: string
  readonly name: string
  accept<T>(visitor: RootNodeVisitor<T>): T {
     return visitor.visitSubroutine(this)
   }
}
export abstract class ContractMemberNode extends Node {
  constructor(props: Props<ContractMemberNode>) {
    super(props)
  }
  abstract accept<T>(visitor: ContractMemberNodeVisitor<T>): T
}
export class ContractMethod extends classes(_Function,ContractMemberNode) {
  constructor(props: Props<ContractMethod>) {
    super(
[props], [props]
)
    this.cref = props.cref
    this.memberName = props.memberName
    this.arc4MethodConfig = props.arc4MethodConfig
  }
  readonly cref: ContractReference
  readonly memberName: string
  readonly arc4MethodConfig: ARC4BareMethodConfig | ARC4ABIMethodConfig | null
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
     return visitor.visitContractMethod(this)
   }
}
export class AppStorageDefinition extends ContractMemberNode {
  constructor(props: Props<AppStorageDefinition>) {
    super(props)
    this.memberName = props.memberName
    this.kind = props.kind
    this.storageWtype = props.storageWtype
    this.keyWtype = props.keyWtype
    this.key = props.key
    this.description = props.description
  }
  readonly memberName: string
  readonly kind: AppStorageKind
  readonly storageWtype: wtypes.WType
  readonly keyWtype: wtypes.WType | null
  readonly key: BytesConstant
  readonly description: string | null
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
     return visitor.visitAppStorageDefinition(this)
   }
}
export class LogicSignature extends RootNode {
  constructor(props: Props<LogicSignature>) {
    super(props)
    this.id = props.id
    this.shortName = props.shortName
    this.program = props.program
    this.docstring = props.docstring
    this.reservedScratchSpace = props.reservedScratchSpace
    this.avmVersion = props.avmVersion
  }
  readonly id: LogicSigReference
  readonly shortName: string
  readonly program: Subroutine
  readonly docstring: string | null
  readonly reservedScratchSpace: Set<bigint>
  readonly avmVersion: bigint | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
     return visitor.visitLogicSignature(this)
   }
}
export class CompiledContract extends Expression {
  constructor(props: Props<CompiledContract>) {
    super(props)
    this.contract = props.contract
    this.allocationOverrides = props.allocationOverrides
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  readonly contract: ContractReference
  readonly allocationOverrides: Map<TxnField, Expression>
  readonly prefix: string | null
  readonly templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCompiledContract(this)
   }
}
export class CompiledLogicSig extends Expression {
  constructor(props: Props<CompiledLogicSig>) {
    super(props)
    this.logicSig = props.logicSig
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  readonly logicSig: LogicSigReference
  readonly prefix: string | null
  readonly templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitCompiledLogicSig(this)
   }
}
export class StateTotals{
  constructor(props: Props<StateTotals>) {
    this.globalUints = props.globalUints
    this.localUints = props.localUints
    this.globalBytes = props.globalBytes
    this.localBytes = props.localBytes
  }
  readonly globalUints: bigint | null
  readonly localUints: bigint | null
  readonly globalBytes: bigint | null
  readonly localBytes: bigint | null
}
export class ARC4Router extends Expression {
  constructor(props: Props<ARC4Router>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
     return visitor.visitARC4Router(this)
   }
}
export class Contract extends RootNode {
  constructor(props: Props<Contract>) {
    super(props)
    this.id = props.id
    this.name = props.name
    this.description = props.description
    this.methodResolutionOrder = props.methodResolutionOrder
    this.approvalProgram = props.approvalProgram
    this.clearProgram = props.clearProgram
    this.methods = props.methods
    this.appState = props.appState
    this.stateTotals = props.stateTotals
    this.reservedScratchSpace = props.reservedScratchSpace
    this.avmVersion = props.avmVersion
  }
  readonly id: ContractReference
  readonly name: string
  readonly description: string | null
  readonly methodResolutionOrder: Array<ContractReference>
  readonly approvalProgram: ContractMethod
  readonly clearProgram: ContractMethod
  readonly methods: Array<ContractMethod>
  readonly appState: Array<AppStorageDefinition>
  readonly stateTotals: StateTotals | null
  readonly reservedScratchSpace: Set<bigint>
  readonly avmVersion: bigint | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
     return visitor.visitContract(this)
   }
}
export enum ARC4CreateOption {
  allow = 1,
  require = 2,
  disallow = 3,
}
export class ARC4BareMethodConfig{
  constructor(props: Props<ARC4BareMethodConfig>) {
    this.sourceLocation = props.sourceLocation
    this.allowedCompletionTypes = props.allowedCompletionTypes
    this.create = props.create
  }
  readonly sourceLocation: SourceLocation
  readonly allowedCompletionTypes: Array<OnCompletionAction>
  readonly create: ARC4CreateOption
}
export class ABIMethodArgConstantDefault{
  constructor(props: Props<ABIMethodArgConstantDefault>) {
    this.value = props.value
  }
  readonly value: Expression
}
export class ABIMethodArgMemberDefault{
  constructor(props: Props<ABIMethodArgMemberDefault>) {
    this.name = props.name
  }
  readonly name: string
}
export class ARC4ABIMethodConfig{
  constructor(props: Props<ARC4ABIMethodConfig>) {
    this.sourceLocation = props.sourceLocation
    this.allowedCompletionTypes = props.allowedCompletionTypes
    this.create = props.create
    this.name = props.name
    this.readonly = props.readonly
    this.defaultArgs = props.defaultArgs
  }
  readonly sourceLocation: SourceLocation
  readonly allowedCompletionTypes: Array<OnCompletionAction>
  readonly create: ARC4CreateOption
  readonly name: string
  readonly readonly: boolean
  readonly defaultArgs: Map<string, ABIMethodArgMemberDefault | ABIMethodArgConstantDefault>
}
export type Constant = 
    | IntegerConstant
    | DecimalConstant
    | BoolConstant
    | BytesConstant
    | AddressConstant
    | MethodConstant
export type LValue = 
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
export type ARC4MethodConfig = ARC4BareMethodConfig | ARC4ABIMethodConfig
export type AWST = 
    | Subroutine
    | LogicSignature
    | Contract
export const concreteNodes = {
  expressionStatement: ExpressionStatement,
  block: Block,
  goto: Goto,
  ifElse: IfElse,
  switch: Switch,
  whileLoop: WhileLoop,
  loopExit: LoopExit,
  loopContinue: LoopContinue,
  returnStatement: ReturnStatement,
  assertExpression: AssertExpression,
  integerConstant: IntegerConstant,
  decimalConstant: DecimalConstant,
  boolConstant: BoolConstant,
  bytesConstant: BytesConstant,
  stringConstant: StringConstant,
  voidConstant: VoidConstant,
  templateVar: TemplateVar,
  methodConstant: MethodConstant,
  addressConstant: AddressConstant,
  aRC4Encode: ARC4Encode,
  aRC4Decode: ARC4Decode,
  copy: Copy,
  arrayConcat: ArrayConcat,
  arrayExtend: ArrayExtend,
  arrayPop: ArrayPop,
  arrayReplace: ArrayReplace,
  sizeOf: SizeOf,
  intrinsicCall: IntrinsicCall,
  createInnerTransaction: CreateInnerTransaction,
  updateInnerTransaction: UpdateInnerTransaction,
  groupTransactionReference: GroupTransactionReference,
  checkedMaybe: CheckedMaybe,
  tupleExpression: TupleExpression,
  tupleItemExpression: TupleItemExpression,
  varExpression: VarExpression,
  innerTransactionField: InnerTransactionField,
  setInnerTransactionFields: SetInnerTransactionFields,
  submitInnerTransaction: SubmitInnerTransaction,
  fieldExpression: FieldExpression,
  indexExpression: IndexExpression,
  sliceExpression: SliceExpression,
  intersectionSliceExpression: IntersectionSliceExpression,
  appStateExpression: AppStateExpression,
  appAccountStateExpression: AppAccountStateExpression,
  boxPrefixedKeyExpression: BoxPrefixedKeyExpression,
  boxValueExpression: BoxValueExpression,
  singleEvaluation: SingleEvaluation,
  reinterpretCast: ReinterpretCast,
  newArray: NewArray,
  arrayLength: ArrayLength,
  conditionalExpression: ConditionalExpression,
  assignmentStatement: AssignmentStatement,
  assignmentExpression: AssignmentExpression,
  commaExpression: CommaExpression,
  numericComparisonExpression: NumericComparisonExpression,
  bytesComparisonExpression: BytesComparisonExpression,
  subroutineID: SubroutineID,
  instanceMethodTarget: InstanceMethodTarget,
  instanceSuperMethodTarget: InstanceSuperMethodTarget,
  contractMethodTarget: ContractMethodTarget,
  callArg: CallArg,
  subroutineCallExpression: SubroutineCallExpression,
  puyaLibData: PuyaLibData,
  puyaLibCall: PuyaLibCall,
  uInt64UnaryOperation: UInt64UnaryOperation,
  uInt64PostfixUnaryOperation: UInt64PostfixUnaryOperation,
  bigUIntPostfixUnaryOperation: BigUIntPostfixUnaryOperation,
  bytesUnaryOperation: BytesUnaryOperation,
  uInt64BinaryOperation: UInt64BinaryOperation,
  bigUIntBinaryOperation: BigUIntBinaryOperation,
  bytesBinaryOperation: BytesBinaryOperation,
  booleanBinaryOperation: BooleanBinaryOperation,
  not: Not,
  uInt64AugmentedAssignment: UInt64AugmentedAssignment,
  bigUIntAugmentedAssignment: BigUIntAugmentedAssignment,
  bytesAugmentedAssignment: BytesAugmentedAssignment,
  emit: Emit,
  range: Range,
  enumeration: Enumeration,
  reversed: Reversed,
  forInLoop: ForInLoop,
  stateGet: StateGet,
  stateGetEx: StateGetEx,
  stateExists: StateExists,
  stateDelete: StateDelete,
  newStruct: NewStruct,
  subroutineArgument: SubroutineArgument,
  methodDocumentation: MethodDocumentation,
  subroutine: Subroutine,
  contractMethod: ContractMethod,
  appStorageDefinition: AppStorageDefinition,
  logicSignature: LogicSignature,
  compiledContract: CompiledContract,
  compiledLogicSig: CompiledLogicSig,
  stateTotals: StateTotals,
  aRC4Router: ARC4Router,
  contract: Contract,
  aRC4BareMethodConfig: ARC4BareMethodConfig,
  aBIMethodArgConstantDefault: ABIMethodArgConstantDefault,
  aBIMethodArgMemberDefault: ABIMethodArgMemberDefault,
  aRC4ABIMethodConfig: ARC4ABIMethodConfig,
  uInt64Constant: IntegerConstant,
  bigUIntConstant: IntegerConstant,
} as const
export interface StatementVisitor<T> {
  visitExpressionStatement(statement: ExpressionStatement): T
  visitBlock(statement: Block): T
  visitGoto(statement: Goto): T
  visitIfElse(statement: IfElse): T
  visitSwitch(statement: Switch): T
  visitWhileLoop(statement: WhileLoop): T
  visitLoopExit(statement: LoopExit): T
  visitLoopContinue(statement: LoopContinue): T
  visitReturnStatement(statement: ReturnStatement): T
  visitAssignmentStatement(statement: AssignmentStatement): T
  visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): T
  visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): T
  visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): T
  visitForInLoop(statement: ForInLoop): T
}
export interface ExpressionVisitor<T> {
  visitAssertExpression(expression: AssertExpression): T
  visitIntegerConstant(expression: IntegerConstant): T
  visitDecimalConstant(expression: DecimalConstant): T
  visitBoolConstant(expression: BoolConstant): T
  visitBytesConstant(expression: BytesConstant): T
  visitStringConstant(expression: StringConstant): T
  visitVoidConstant(expression: VoidConstant): T
  visitTemplateVar(expression: TemplateVar): T
  visitMethodConstant(expression: MethodConstant): T
  visitAddressConstant(expression: AddressConstant): T
  visitARC4Encode(expression: ARC4Encode): T
  visitARC4Decode(expression: ARC4Decode): T
  visitCopy(expression: Copy): T
  visitArrayConcat(expression: ArrayConcat): T
  visitArrayExtend(expression: ArrayExtend): T
  visitArrayPop(expression: ArrayPop): T
  visitArrayReplace(expression: ArrayReplace): T
  visitSizeOf(expression: SizeOf): T
  visitIntrinsicCall(expression: IntrinsicCall): T
  visitCreateInnerTransaction(expression: CreateInnerTransaction): T
  visitUpdateInnerTransaction(expression: UpdateInnerTransaction): T
  visitGroupTransactionReference(expression: GroupTransactionReference): T
  visitCheckedMaybe(expression: CheckedMaybe): T
  visitTupleExpression(expression: TupleExpression): T
  visitTupleItemExpression(expression: TupleItemExpression): T
  visitVarExpression(expression: VarExpression): T
  visitInnerTransactionField(expression: InnerTransactionField): T
  visitSetInnerTransactionFields(expression: SetInnerTransactionFields): T
  visitSubmitInnerTransaction(expression: SubmitInnerTransaction): T
  visitFieldExpression(expression: FieldExpression): T
  visitIndexExpression(expression: IndexExpression): T
  visitSliceExpression(expression: SliceExpression): T
  visitIntersectionSliceExpression(expression: IntersectionSliceExpression): T
  visitAppStateExpression(expression: AppStateExpression): T
  visitAppAccountStateExpression(expression: AppAccountStateExpression): T
  visitBoxPrefixedKeyExpression(expression: BoxPrefixedKeyExpression): T
  visitBoxValueExpression(expression: BoxValueExpression): T
  visitSingleEvaluation(expression: SingleEvaluation): T
  visitReinterpretCast(expression: ReinterpretCast): T
  visitNewArray(expression: NewArray): T
  visitArrayLength(expression: ArrayLength): T
  visitConditionalExpression(expression: ConditionalExpression): T
  visitAssignmentExpression(expression: AssignmentExpression): T
  visitCommaExpression(expression: CommaExpression): T
  visitNumericComparisonExpression(expression: NumericComparisonExpression): T
  visitBytesComparisonExpression(expression: BytesComparisonExpression): T
  visitSubroutineCallExpression(expression: SubroutineCallExpression): T
  visitPuyaLibCall(expression: PuyaLibCall): T
  visitUInt64UnaryOperation(expression: UInt64UnaryOperation): T
  visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): T
  visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): T
  visitBytesUnaryOperation(expression: BytesUnaryOperation): T
  visitUInt64BinaryOperation(expression: UInt64BinaryOperation): T
  visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): T
  visitBytesBinaryOperation(expression: BytesBinaryOperation): T
  visitBooleanBinaryOperation(expression: BooleanBinaryOperation): T
  visitNot(expression: Not): T
  visitEmit(expression: Emit): T
  visitRange(expression: Range): T
  visitEnumeration(expression: Enumeration): T
  visitReversed(expression: Reversed): T
  visitStateGet(expression: StateGet): T
  visitStateGetEx(expression: StateGetEx): T
  visitStateExists(expression: StateExists): T
  visitStateDelete(expression: StateDelete): T
  visitNewStruct(expression: NewStruct): T
  visitCompiledContract(expression: CompiledContract): T
  visitCompiledLogicSig(expression: CompiledLogicSig): T
  visitARC4Router(expression: ARC4Router): T
}
export interface RootNodeVisitor<T> {
  visitSubroutine(rootNode: Subroutine): T
  visitLogicSignature(rootNode: LogicSignature): T
  visitContract(rootNode: Contract): T
}
export interface ContractMemberNodeVisitor<T> {
  visitContractMethod(contractMemberNode: ContractMethod): T
  visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): T
}