contract examples.arc4_types.string.Arc4StringTypesContract:
    program approval:
        subroutine examples.arc4_types.string.Arc4StringTypesContract.approval_program() -> uint64:
            block@0: // L8
                let some_bytes#0: bytes = "Hello World!"
                let length%0#0: uint64 = (len some_bytes#0)
                let value_as_bytes%1#0: bytes = (itob length%0#0)
                let value_as_uint16%2#0: bytes = ((extract 6 2) value_as_bytes%1#0)
                let some_bytes_as_string#0: bytes = (concat value_as_uint16%2#0 some_bytes#0)
                let some_bytes_as_bytes_again#0: bytes = ((extract 2 0) some_bytes_as_string#0)
                let tmp%3#0: uint64 = (!= some_bytes#0 some_bytes_as_string#0)
                (assert tmp%3#0) // Original bytes should not match encoded bytes
                let awst_tmp%4#0: uint64 = (len some_bytes_as_string#0)
                let tmp%5#0: uint64 = (< 2u awst_tmp%4#0)
                goto tmp%5#0 ? block@1 : block@2
            block@1: // ternary_true_L20
                let ternary_result%6#0: uint64 = 2u
                goto block@3
            block@2: // ternary_false_L20
                let ternary_result%6#1: uint64 = awst_tmp%4#0
                goto block@3
            block@3: // ternary_merge_L20
                let ternary_result%6#2: uint64 = φ(ternary_result%6#0 <- block@1, ternary_result%6#1 <- block@2)
                let base_length%7#0: uint64 = (len some_bytes_as_string#0)
                let tmp%8#0: bytes = (substring3 some_bytes_as_string#0 ternary_result%6#2 base_length%7#0)
                let tmp%9#0: uint64 = (== some_bytes#0 tmp%8#0)
                (assert tmp%9#0) // Original bytes should match encoded if we strip the length header
                let tmp%10#0: uint64 = (== some_bytes#0 some_bytes_as_bytes_again#0)
                (assert tmp%10#0)
                let hello#0: bytes = "\x00\x05Hello"
                let space#0: bytes = "\x00\x01 "
                let world#0: bytes = "\x00\x06World!"
                let array_length%11#0: uint64 = (extract_uint16 space#0 0u)
                let data%12#0: bytes = ((extract 2 0) space#0)
                let concat_result%13#0: bytes = puya_util_arc4.dynamic_array_concat_fixed_size(hello#0, data%12#0, array_length%11#0)
                let array_length%14#0: uint64 = (extract_uint16 world#0 0u)
                let data%15#0: bytes = ((extract 2 0) world#0)
                let concat_result%16#0: bytes = puya_util_arc4.dynamic_array_concat_fixed_size(concat_result%13#0, data%15#0, array_length%14#0)
                let tmp%17#0: uint64 = (== "\x00\x0cHello World!" concat_result%16#0)
                (assert tmp%17#0)
                let thing#0: bytes = "\x00\x02hi"
                let array_length%18#0: uint64 = (extract_uint16 thing#0 0u)
                let data%19#0: bytes = ((extract 2 0) thing#0)
                let concat_result%20#0: bytes = puya_util_arc4.dynamic_array_concat_fixed_size(thing#0, data%19#0, array_length%18#0)
                let thing#1: bytes = concat_result%20#0
                let tmp%21#0: uint64 = (== thing#1 "\x00\x04hihi")
                (assert tmp%21#0)
                return 1u
        
        subroutine puya_util_arc4.dynamic_array_concat_bits(source: bytes, new_items_bytes: bytes, new_items_count: uint64, is_packed: uint64) -> bytes:
            block@0: // L18
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%1#0: bytes = (itob tmp%0#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let source#1: bytes = (replace3 source#0 0u tmp%2#0)
                let tmp%3#0: uint64 = (+ array_length#0 7u)
                let current_bytes#0: uint64 = (/ tmp%3#0 8u)
                let tmp%4#0: uint64 = (+ array_length#0 7u)
                let tmp%5#0: uint64 = (+ tmp%4#0 new_items_count#0)
                let required_bytes#0: uint64 = (/ tmp%5#0 8u)
                let tmp%6#0: uint64 = (< current_bytes#0 required_bytes#0)
                goto tmp%6#0 ? block@1 : block@2
            block@1: // if_body_L25
                let tmp%7#0: uint64 = (- required_bytes#0 current_bytes#0)
                let tmp%8#0: bytes = (bzero tmp%7#0)
                let source#2: bytes = (concat source#1 tmp%8#0)
                goto block@2
            block@2: // after_if_else_L25
                let source#6: bytes = φ(source#1 <- block@0, source#2 <- block@1)
                let write_offset#0: uint64 = (+ array_length#0 16u)
                goto is_packed#0 ? block@3 : block@4
            block@3: // ternary_true_L29
                let ternary_result%9#0: uint64 = 1u
                goto block@5
            block@4: // ternary_false_L29
                let ternary_result%9#1: uint64 = 8u
                goto block@5
            block@5: // ternary_merge_L29
                let ternary_result%9#2: uint64 = φ(ternary_result%9#0 <- block@3, ternary_result%9#1 <- block@4)
                let range_item%10#0: uint64 = 0u
                goto block@6
            block@6: // for_header_L29
                let range_item%10#1: uint64 = φ(range_item%10#0 <- block@5, range_item%10#2 <- block@8)
                let source#3: bytes = φ(source#6 <- block@5, source#4 <- block@8)
                let write_offset#1: uint64 = φ(write_offset#0 <- block@5, write_offset#2 <- block@8)
                let continue_looping%11#0: uint64 = (< range_item%10#1 new_items_count#0)
                goto continue_looping%11#0 ? block@7 : block@9
            block@7: // for_body_L29
                let i#0: uint64 = range_item%10#1
                let tmp%12#0: uint64 = (getbit new_items_bytes#0 i#0)
                let source#4: any = (setbit source#3 write_offset#1 tmp%12#0)
                let write_offset#2: uint64 = (+ write_offset#1 1u)
                goto block@8
            block@8: // for_footer_L29
                let range_item%10#2: uint64 = (+ range_item%10#1 ternary_result%9#2)
                goto block@6
            block@9: // after_for_L29
                return source#3
        
        subroutine puya_util_arc4.dynamic_array_concat_variable_size(source: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
            block@0: // L65
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let new_length#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%0#0: uint64 = (* array_length#0 2u)
                let header_end#0: uint64 = (+ tmp%0#0 2u)
                let tmp%1#0: bytes = (itob new_length#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let tmp%3#0: bytes = (substring3 source#0 2u header_end#0)
                let tmp%4#0: uint64 = (* new_items_count#0 2u)
                let tmp%5#0: bytes = (bzero tmp%4#0)
                let tmp%6#0: bytes = (concat tmp%3#0 tmp%5#0)
                let tmp%7#0: uint64 = (len source#0)
                let tmp%8#0: bytes = (substring3 source#0 header_end#0 tmp%7#0)
                let tmp%9#0: bytes = (concat tmp%6#0 tmp%8#0)
                let tmp%10#0: bytes = (concat tmp%9#0 new_items_bytes#0)
                let tmp%11#0: bytes = puya_util_arc4.recalculate_array_offsets_static(tmp%10#0, new_length#0, 0u)
                let tmp%12#0: bytes = (concat tmp%2#0 tmp%11#0)
                return tmp%12#0
        
        subroutine puya_util_arc4.recalculate_array_offsets_static(array_data: bytes, length: uint64, start_at_index: uint64) -> bytes:
            block@0: // L103
                let header_cursor#0: uint64 = (* start_at_index#0 2u)
                let tmp%0#0: uint64 = (== start_at_index#0 0u)
                goto tmp%0#0 ? block@1 : block@2
            block@1: // if_body_L107
                let tail_cursor#0: uint64 = (* length#0 2u)
                goto block@3
            block@2: // else_body_L107
                let tail_cursor#1: uint64 = (extract_uint16 array_data#0 header_cursor#0)
                goto block@3
            block@3: // after_if_else_L107
                let tail_cursor#4: uint64 = φ(tail_cursor#0 <- block@1, tail_cursor#1 <- block@2)
                let range_item%1#0: uint64 = start_at_index#0
                goto block@4
            block@4: // for_header_L112
                let range_item%1#1: uint64 = φ(range_item%1#0 <- block@3, range_item%1#2 <- block@6)
                let tail_cursor#2: uint64 = φ(tail_cursor#4 <- block@3, tail_cursor#3 <- block@6)
                let array_data#1: bytes = φ(array_data#0 <- block@3, array_data#2 <- block@6)
                let header_cursor#1: uint64 = φ(header_cursor#0 <- block@3, header_cursor#2 <- block@6)
                let continue_looping%2#0: uint64 = (< range_item%1#1 length#0)
                goto continue_looping%2#0 ? block@5 : block@7
            block@5: // for_body_L112
                let i#0: uint64 = range_item%1#1
                let tmp%3#0: bytes = (itob tail_cursor#2)
                let tail_cursor_bytes#0: bytes = (substring3 tmp%3#0 6u 8u)
                let array_data#2: bytes = (replace3 array_data#1 header_cursor#1 tail_cursor_bytes#0)
                let tmp%4#0: uint64 = (extract_uint16 array_data#2 tail_cursor#2)
                let tmp%5#0: uint64 = (+ tmp%4#0 2u)
                let tail_cursor#3: uint64 = (+ tail_cursor#2 tmp%5#0)
                let header_cursor#2: uint64 = (+ header_cursor#1 2u)
                goto block@6
            block@6: // for_footer_L112
                let range_item%1#2: uint64 = (+ range_item%1#1 1u)
                goto block@4
            block@7: // after_for_L112
                return array_data#1
        
        subroutine puya_util_arc4.dynamic_array_concat_fixed_size(source: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
            block@0: // L84
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%1#0: bytes = (itob tmp%0#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let source#1: bytes = (replace3 source#0 0u tmp%2#0)
                let source#2: bytes = (concat source#1 new_items_bytes#0)
                return source#2
        
        subroutine puya_util_arc4.dynamic_array_replace_variable_size(source: bytes, new_item: bytes, index: uint64) -> bytes:
            block@0: // L37
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: bytes = (substring3 source#0 0u 2u)
                let tmp%1#0: uint64 = (len source#0)
                let tmp%2#0: bytes = (substring3 source#0 2u tmp%1#0)
                let tmp%3#0: bytes = puya_util_arc4.static_array_replace_variable_size(tmp%2#0, new_item#0, index#0, array_length#0)
                let tmp%4#0: bytes = (concat tmp%0#0 tmp%3#0)
                return tmp%4#0
        
        subroutine puya_util_arc4.static_array_replace_variable_size(source: bytes, new_item: bytes, index: uint64, array_length: uint64) -> bytes:
            block@0: // L48
                let tmp%0#0: uint64 = (< index#0 array_length#0)
                (assert tmp%0#0) // Index out of bounds
                let tmp%1#0: uint64 = (* index#0 2u)
                let offset_for_index#0: uint64 = (extract_uint16 source#0 tmp%1#0)
                let old_item_length#0: uint64 = (extract_uint16 source#0 offset_for_index#0)
                let tmp%2#0: uint64 = (+ offset_for_index#0 old_item_length#0)
                let old_item_end#0: uint64 = (+ tmp%2#0 2u)
                let tmp%3#0: bytes = (substring3 source#0 0u offset_for_index#0)
                let tmp%4#0: bytes = (concat tmp%3#0 new_item#0)
                let tmp%5#0: uint64 = (len source#0)
                let tmp%6#0: bytes = (substring3 source#0 old_item_end#0 tmp%5#0)
                let tmp%7#0: bytes = (concat tmp%4#0 tmp%6#0)
                let tmp%8#0: bytes = puya_util_arc4.recalculate_array_offsets_static(tmp%7#0, array_length#0, index#0)
                return tmp%8#0
    
    program clear-state:
        subroutine examples.arc4_types.string.Arc4StringTypesContract.clear_state_program() -> uint64:
            block@0: // L36
                return 1u
        
        subroutine puya_util_arc4.dynamic_array_concat_bits(source: bytes, new_items_bytes: bytes, new_items_count: uint64, is_packed: uint64) -> bytes:
            block@0: // L18
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%1#0: bytes = (itob tmp%0#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let source#1: bytes = (replace3 source#0 0u tmp%2#0)
                let tmp%3#0: uint64 = (+ array_length#0 7u)
                let current_bytes#0: uint64 = (/ tmp%3#0 8u)
                let tmp%4#0: uint64 = (+ array_length#0 7u)
                let tmp%5#0: uint64 = (+ tmp%4#0 new_items_count#0)
                let required_bytes#0: uint64 = (/ tmp%5#0 8u)
                let tmp%6#0: uint64 = (< current_bytes#0 required_bytes#0)
                goto tmp%6#0 ? block@1 : block@2
            block@1: // if_body_L25
                let tmp%7#0: uint64 = (- required_bytes#0 current_bytes#0)
                let tmp%8#0: bytes = (bzero tmp%7#0)
                let source#2: bytes = (concat source#1 tmp%8#0)
                goto block@2
            block@2: // after_if_else_L25
                let source#6: bytes = φ(source#1 <- block@0, source#2 <- block@1)
                let write_offset#0: uint64 = (+ array_length#0 16u)
                goto is_packed#0 ? block@3 : block@4
            block@3: // ternary_true_L29
                let ternary_result%9#0: uint64 = 1u
                goto block@5
            block@4: // ternary_false_L29
                let ternary_result%9#1: uint64 = 8u
                goto block@5
            block@5: // ternary_merge_L29
                let ternary_result%9#2: uint64 = φ(ternary_result%9#0 <- block@3, ternary_result%9#1 <- block@4)
                let range_item%10#0: uint64 = 0u
                goto block@6
            block@6: // for_header_L29
                let range_item%10#1: uint64 = φ(range_item%10#0 <- block@5, range_item%10#2 <- block@8)
                let source#3: bytes = φ(source#6 <- block@5, source#4 <- block@8)
                let write_offset#1: uint64 = φ(write_offset#0 <- block@5, write_offset#2 <- block@8)
                let continue_looping%11#0: uint64 = (< range_item%10#1 new_items_count#0)
                goto continue_looping%11#0 ? block@7 : block@9
            block@7: // for_body_L29
                let i#0: uint64 = range_item%10#1
                let tmp%12#0: uint64 = (getbit new_items_bytes#0 i#0)
                let source#4: any = (setbit source#3 write_offset#1 tmp%12#0)
                let write_offset#2: uint64 = (+ write_offset#1 1u)
                goto block@8
            block@8: // for_footer_L29
                let range_item%10#2: uint64 = (+ range_item%10#1 ternary_result%9#2)
                goto block@6
            block@9: // after_for_L29
                return source#3
        
        subroutine puya_util_arc4.dynamic_array_concat_variable_size(source: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
            block@0: // L65
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let new_length#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%0#0: uint64 = (* array_length#0 2u)
                let header_end#0: uint64 = (+ tmp%0#0 2u)
                let tmp%1#0: bytes = (itob new_length#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let tmp%3#0: bytes = (substring3 source#0 2u header_end#0)
                let tmp%4#0: uint64 = (* new_items_count#0 2u)
                let tmp%5#0: bytes = (bzero tmp%4#0)
                let tmp%6#0: bytes = (concat tmp%3#0 tmp%5#0)
                let tmp%7#0: uint64 = (len source#0)
                let tmp%8#0: bytes = (substring3 source#0 header_end#0 tmp%7#0)
                let tmp%9#0: bytes = (concat tmp%6#0 tmp%8#0)
                let tmp%10#0: bytes = (concat tmp%9#0 new_items_bytes#0)
                let tmp%11#0: bytes = puya_util_arc4.recalculate_array_offsets_static(tmp%10#0, new_length#0, 0u)
                let tmp%12#0: bytes = (concat tmp%2#0 tmp%11#0)
                return tmp%12#0
        
        subroutine puya_util_arc4.recalculate_array_offsets_static(array_data: bytes, length: uint64, start_at_index: uint64) -> bytes:
            block@0: // L103
                let header_cursor#0: uint64 = (* start_at_index#0 2u)
                let tmp%0#0: uint64 = (== start_at_index#0 0u)
                goto tmp%0#0 ? block@1 : block@2
            block@1: // if_body_L107
                let tail_cursor#0: uint64 = (* length#0 2u)
                goto block@3
            block@2: // else_body_L107
                let tail_cursor#1: uint64 = (extract_uint16 array_data#0 header_cursor#0)
                goto block@3
            block@3: // after_if_else_L107
                let tail_cursor#4: uint64 = φ(tail_cursor#0 <- block@1, tail_cursor#1 <- block@2)
                let range_item%1#0: uint64 = start_at_index#0
                goto block@4
            block@4: // for_header_L112
                let range_item%1#1: uint64 = φ(range_item%1#0 <- block@3, range_item%1#2 <- block@6)
                let tail_cursor#2: uint64 = φ(tail_cursor#4 <- block@3, tail_cursor#3 <- block@6)
                let array_data#1: bytes = φ(array_data#0 <- block@3, array_data#2 <- block@6)
                let header_cursor#1: uint64 = φ(header_cursor#0 <- block@3, header_cursor#2 <- block@6)
                let continue_looping%2#0: uint64 = (< range_item%1#1 length#0)
                goto continue_looping%2#0 ? block@5 : block@7
            block@5: // for_body_L112
                let i#0: uint64 = range_item%1#1
                let tmp%3#0: bytes = (itob tail_cursor#2)
                let tail_cursor_bytes#0: bytes = (substring3 tmp%3#0 6u 8u)
                let array_data#2: bytes = (replace3 array_data#1 header_cursor#1 tail_cursor_bytes#0)
                let tmp%4#0: uint64 = (extract_uint16 array_data#2 tail_cursor#2)
                let tmp%5#0: uint64 = (+ tmp%4#0 2u)
                let tail_cursor#3: uint64 = (+ tail_cursor#2 tmp%5#0)
                let header_cursor#2: uint64 = (+ header_cursor#1 2u)
                goto block@6
            block@6: // for_footer_L112
                let range_item%1#2: uint64 = (+ range_item%1#1 1u)
                goto block@4
            block@7: // after_for_L112
                return array_data#1
        
        subroutine puya_util_arc4.dynamic_array_concat_fixed_size(source: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
            block@0: // L84
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: uint64 = (+ array_length#0 new_items_count#0)
                let tmp%1#0: bytes = (itob tmp%0#0)
                let tmp%2#0: bytes = (substring3 tmp%1#0 6u 8u)
                let source#1: bytes = (replace3 source#0 0u tmp%2#0)
                let source#2: bytes = (concat source#1 new_items_bytes#0)
                return source#2
        
        subroutine puya_util_arc4.dynamic_array_replace_variable_size(source: bytes, new_item: bytes, index: uint64) -> bytes:
            block@0: // L37
                let array_length#0: uint64 = (extract_uint16 source#0 0u)
                let tmp%0#0: bytes = (substring3 source#0 0u 2u)
                let tmp%1#0: uint64 = (len source#0)
                let tmp%2#0: bytes = (substring3 source#0 2u tmp%1#0)
                let tmp%3#0: bytes = puya_util_arc4.static_array_replace_variable_size(tmp%2#0, new_item#0, index#0, array_length#0)
                let tmp%4#0: bytes = (concat tmp%0#0 tmp%3#0)
                return tmp%4#0
        
        subroutine puya_util_arc4.static_array_replace_variable_size(source: bytes, new_item: bytes, index: uint64, array_length: uint64) -> bytes:
            block@0: // L48
                let tmp%0#0: uint64 = (< index#0 array_length#0)
                (assert tmp%0#0) // Index out of bounds
                let tmp%1#0: uint64 = (* index#0 2u)
                let offset_for_index#0: uint64 = (extract_uint16 source#0 tmp%1#0)
                let old_item_length#0: uint64 = (extract_uint16 source#0 offset_for_index#0)
                let tmp%2#0: uint64 = (+ offset_for_index#0 old_item_length#0)
                let old_item_end#0: uint64 = (+ tmp%2#0 2u)
                let tmp%3#0: bytes = (substring3 source#0 0u offset_for_index#0)
                let tmp%4#0: bytes = (concat tmp%3#0 new_item#0)
                let tmp%5#0: uint64 = (len source#0)
                let tmp%6#0: bytes = (substring3 source#0 old_item_end#0 tmp%5#0)
                let tmp%7#0: bytes = (concat tmp%4#0 tmp%6#0)
                let tmp%8#0: bytes = puya_util_arc4.recalculate_array_offsets_static(tmp%7#0, array_length#0, index#0)
                return tmp%8#0