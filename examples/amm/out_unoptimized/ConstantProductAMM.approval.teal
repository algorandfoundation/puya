#pragma version 10

examples.amm.contract.ConstantProductAMM.approval_program:
    txn ApplicationID
    bnz main_entrypoint@2
    callsub __init__

main_entrypoint@2:
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@11
    txna ApplicationArgs 0
    method "set_governor(account)void"
    method "bootstrap(pay,asset,asset)uint64"
    method "mint(axfer,axfer,asset,asset,asset)void"
    method "burn(axfer,asset,asset,asset)void"
    method "swap(axfer,asset,asset)void"
    uncover 5
    match main_set_governor_route@4 main_bootstrap_route@5 main_mint_route@6 main_burn_route@7 main_swap_route@8
    b main_switch_case_default@9

main_set_governor_route@4:
    // amm/contract.py:43
    // @arc4.abimethod()
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // amm/contract.py:43
    // @arc4.abimethod()
    callsub set_governor
    int 1
    return

main_bootstrap_route@5:
    // amm/contract.py:49
    // @arc4.abimethod()
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // amm/contract.py:49
    // @arc4.abimethod()
    uncover 2
    uncover 2
    uncover 2
    callsub bootstrap
    itob
    byte 0x151f7c75
    uncover 1
    concat
    log
    int 1
    return

main_mint_route@6:
    // amm/contract.py:81-87
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn GroupIndex
    int 2
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txnas Assets
    // amm/contract.py:81-87
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub mint
    int 1
    return

main_burn_route@7:
    // amm/contract.py:147-153
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txnas Assets
    // amm/contract.py:147-153
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    callsub burn
    int 1
    return

main_swap_route@8:
    // amm/contract.py:204-209
    // @arc4.abimethod(
    //     default_args={
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    txn OnCompletion
    int NoOp
    ==
    assert // OnCompletion is NoOp
    txn ApplicationID
    assert // is not creating
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn GroupIndex
    int 1
    -
    dup
    gtxns TypeEnum
    int axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // amm/contract.py:204-209
    // @arc4.abimethod(
    //     default_args={
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    uncover 2
    uncover 2
    uncover 2
    callsub swap
    int 1
    return

main_switch_case_default@9:
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    err // reject transaction

main_bare_routing@11:
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn OnCompletion
    int 0
    uncover 1
    match main_create@12
    b main_reject_bare_on_completion@13

main_create@12:
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    txn ApplicationID
    !
    assert // is creating
    int 1
    return

main_reject_bare_on_completion@13:
    // amm/contract.py:27
    // class ConstantProductAMM(ARC4Contract):
    err // reject transaction


// examples.amm.contract.ConstantProductAMM.set_governor(new_governor: bytes) -> void:
set_governor:
    // amm/contract.py:43-44
    // @arc4.abimethod()
    // def set_governor(self, new_governor: Account) -> None:
    proto 1 0
    // amm/contract.py:46
    // self._check_is_governor()
    callsub _check_is_governor
    // amm/contract.py:47
    // self.governor = new_governor
    byte "governor"
    frame_dig -1
    app_global_put
    retsub


// examples.amm.contract.ConstantProductAMM._check_is_governor() -> void:
_check_is_governor:
    // amm/contract.py:262-263
    // @subroutine
    // def _check_is_governor(self) -> None:
    proto 0 0
    // amm/contract.py:265
    // Txn.sender == self.governor
    txn Sender
    int 0
    byte "governor"
    app_global_get_ex
    assert // check governor exists
    ==
    // amm/contract.py:264-266
    // assert (
    //     Txn.sender == self.governor
    // ), "Only the account set in global_state.governor may call this method"
    assert // Only the account set in global_state.governor may call this method
    retsub


// examples.amm.contract.ConstantProductAMM.bootstrap(seed: uint64, a_asset: uint64, b_asset: uint64) -> uint64:
bootstrap:
    // amm/contract.py:49-50
    // @arc4.abimethod()
    // def bootstrap(self, seed: gtxn.PaymentTransaction, a_asset: Asset, b_asset: Asset) -> UInt64:
    proto 3 1
    // amm/contract.py:66
    // assert not self.pool_token, "application has already been bootstrapped"
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    !
    assert // application has already been bootstrapped
    // amm/contract.py:67
    // self._check_is_governor()
    callsub _check_is_governor
    // amm/contract.py:68
    // assert Global.group_size == 2, "group size not 2"
    global GroupSize
    int 2
    ==
    assert // group size not 2
    // amm/contract.py:69
    // assert seed.receiver == Global.current_application_address, "receiver not app address"
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // receiver not app address
    // amm/contract.py:71
    // assert seed.amount >= 300_000, "amount minimum not met"  # 0.3 Algos
    frame_dig -3
    gtxns Amount
    int 300000
    >=
    assert // amount minimum not met
    // amm/contract.py:72
    // assert a_asset.id < b_asset.id, "asset a must be less than asset b"
    frame_dig -2
    frame_dig -1
    <
    assert // asset a must be less than asset b
    // amm/contract.py:73
    // self.asset_a = a_asset
    byte "asset_a"
    frame_dig -2
    app_global_put
    // amm/contract.py:74
    // self.asset_b = b_asset
    byte "asset_b"
    frame_dig -1
    app_global_put
    // amm/contract.py:75
    // self.pool_token = self._create_pool_token()
    callsub _create_pool_token
    byte "pool_token"
    uncover 1
    app_global_put
    // amm/contract.py:77
    // self._do_opt_in(self.asset_a)
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    callsub _do_opt_in
    // amm/contract.py:78
    // self._do_opt_in(self.asset_b)
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    callsub _do_opt_in
    // amm/contract.py:79
    // return self.pool_token.id
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    retsub


// examples.amm.contract.ConstantProductAMM._create_pool_token() -> uint64:
_create_pool_token:
    // amm/contract.py:268-269
    // @subroutine
    // def _create_pool_token(self) -> Asset:
    proto 0 1
    // amm/contract.py:271-279
    // itxn.AssetConfig(
    //     asset_name=b"DPT-" + self.asset_a.unit_name + b"-" + self.asset_b.unit_name,
    //     unit_name=b"dbt",
    //     total=TOTAL_SUPPLY,
    //     decimals=3,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    // )
    // .submit()
    itxn_begin
    // amm/contract.py:272
    // asset_name=b"DPT-" + self.asset_a.unit_name + b"-" + self.asset_b.unit_name,
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    asset_params_get AssetUnitName
    assert // asset exists
    byte "DPT-"
    uncover 1
    concat
    byte "-"
    concat
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    asset_params_get AssetUnitName
    assert // asset exists
    concat
    // amm/contract.py:276
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // amm/contract.py:277
    // reserve=Global.current_application_address,
    global CurrentApplicationAddress
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // amm/contract.py:275
    // decimals=3,
    int 3
    itxn_field ConfigAssetDecimals
    // amm/contract.py:274
    // total=TOTAL_SUPPLY,
    int 10000000000
    itxn_field ConfigAssetTotal
    // amm/contract.py:273
    // unit_name=b"dbt",
    byte "dbt"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // amm/contract.py:271
    // itxn.AssetConfig(
    int acfg
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    // amm/contract.py:271-279
    // itxn.AssetConfig(
    //     asset_name=b"DPT-" + self.asset_a.unit_name + b"-" + self.asset_b.unit_name,
    //     unit_name=b"dbt",
    //     total=TOTAL_SUPPLY,
    //     decimals=3,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    // )
    // .submit()
    itxn_submit
    // amm/contract.py:271-280
    // itxn.AssetConfig(
    //     asset_name=b"DPT-" + self.asset_a.unit_name + b"-" + self.asset_b.unit_name,
    //     unit_name=b"dbt",
    //     total=TOTAL_SUPPLY,
    //     decimals=3,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    // )
    // .submit()
    // .created_asset
    itxn CreatedAssetID
    // amm/contract.py:270-281
    // return (
    //     itxn.AssetConfig(
    //         asset_name=b"DPT-" + self.asset_a.unit_name + b"-" + self.asset_b.unit_name,
    //         unit_name=b"dbt",
    //         total=TOTAL_SUPPLY,
    //         decimals=3,
    //         manager=Global.current_application_address,
    //         reserve=Global.current_application_address,
    //     )
    //     .submit()
    //     .created_asset
    // )
    retsub


// examples.amm.contract.ConstantProductAMM._do_opt_in(asset: uint64) -> void:
_do_opt_in:
    // amm/contract.py:283-284
    // @subroutine
    // def _do_opt_in(self, asset: Asset) -> None:
    proto 1 0
    // amm/contract.py:286
    // receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // amm/contract.py:285-289
    // do_asset_transfer(
    //     receiver=Global.current_application_address,
    //     asset=asset,
    //     amount=UInt64(0),
    // )
    frame_dig -1
    // amm/contract.py:288
    // amount=UInt64(0),
    int 0
    // amm/contract.py:285-289
    // do_asset_transfer(
    //     receiver=Global.current_application_address,
    //     asset=asset,
    //     amount=UInt64(0),
    // )
    callsub do_asset_transfer
    retsub


// examples.amm.contract.do_asset_transfer(receiver: bytes, asset: uint64, amount: uint64) -> void:
do_asset_transfer:
    // amm/contract.py:356-357
    // @subroutine
    // def do_asset_transfer(*, receiver: Account, asset: Asset, amount: UInt64) -> None:
    proto 3 0
    // amm/contract.py:358-362
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_amount=amount,
    //     asset_receiver=receiver,
    // ).submit()
    itxn_begin
    // amm/contract.py:357
    // def do_asset_transfer(*, receiver: Account, asset: Asset, amount: UInt64) -> None:
    frame_dig -2
    frame_dig -1
    frame_dig -3
    itxn_field AssetReceiver
    itxn_field AssetAmount
    itxn_field XferAsset
    // amm/contract.py:358
    // itxn.AssetTransfer(
    int axfer
    itxn_field TypeEnum
    int 0
    itxn_field Fee
    // amm/contract.py:358-362
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_amount=amount,
    //     asset_receiver=receiver,
    // ).submit()
    itxn_submit
    retsub


// examples.amm.contract.ConstantProductAMM.mint(a_xfer: uint64, b_xfer: uint64, pool_asset: uint64, a_asset: uint64, b_asset: uint64) -> void:
mint:
    // amm/contract.py:81-95
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    // def mint(
    //     self,
    //     a_xfer: gtxn.AssetTransferTransaction,
    //     b_xfer: gtxn.AssetTransferTransaction,
    //     pool_asset: Asset,
    //     a_asset: Asset,
    //     b_asset: Asset,
    // ) -> None:
    proto 5 0
    // amm/contract.py:111
    // self._check_bootstrapped()
    callsub _check_bootstrapped
    // amm/contract.py:113-114
    // # well-formed mint
    // assert pool_asset == self.pool_token, "asset pool incorrect"
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    frame_dig -3
    uncover 1
    ==
    assert // asset pool incorrect
    // amm/contract.py:115
    // assert a_asset == self.asset_a, "asset a incorrect"
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    frame_dig -2
    uncover 1
    ==
    assert // asset a incorrect
    // amm/contract.py:116
    // assert b_asset == self.asset_b, "asset b incorrect"
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    frame_dig -1
    uncover 1
    ==
    assert // asset b incorrect
    // amm/contract.py:117
    // assert a_xfer.sender == Txn.sender, "sender invalid"
    frame_dig -5
    gtxns Sender
    txn Sender
    ==
    assert // sender invalid
    // amm/contract.py:118
    // assert b_xfer.sender == Txn.sender, "sender invalid"
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert // sender invalid
    // amm/contract.py:122
    // a_xfer.asset_receiver == Global.current_application_address
    frame_dig -5
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // amm/contract.py:120-123
    // # valid asset a xfer
    // assert (
    //     a_xfer.asset_receiver == Global.current_application_address
    // ), "receiver not app address"
    assert // receiver not app address
    // amm/contract.py:124
    // assert a_xfer.xfer_asset == self.asset_a, "asset a incorrect"
    frame_dig -5
    gtxns XferAsset
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    ==
    assert // asset a incorrect
    // amm/contract.py:125
    // assert a_xfer.asset_amount > 0, "amount minimum not met"
    frame_dig -5
    gtxns AssetAmount
    int 0
    >
    assert // amount minimum not met
    // amm/contract.py:129
    // b_xfer.asset_receiver == Global.current_application_address
    frame_dig -4
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // amm/contract.py:127-130
    // # valid asset b xfer
    // assert (
    //     b_xfer.asset_receiver == Global.current_application_address
    // ), "receiver not app address"
    assert // receiver not app address
    // amm/contract.py:131
    // assert b_xfer.xfer_asset == self.asset_b, "asset b incorrect"
    frame_dig -4
    gtxns XferAsset
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    ==
    assert // asset b incorrect
    // amm/contract.py:132
    // assert b_xfer.asset_amount > 0, "amount minimum not met"
    frame_dig -4
    gtxns AssetAmount
    int 0
    >
    assert // amount minimum not met
    // amm/contract.py:135
    // pool_balance=self._current_pool_balance(),
    callsub _current_pool_balance
    // amm/contract.py:136
    // a_balance=self._current_a_balance(),
    callsub _current_a_balance
    // amm/contract.py:137
    // b_balance=self._current_b_balance(),
    callsub _current_b_balance
    // amm/contract.py:138
    // a_amount=a_xfer.asset_amount,
    frame_dig -5
    gtxns AssetAmount
    // amm/contract.py:139
    // b_amount=b_xfer.asset_amount,
    frame_dig -4
    gtxns AssetAmount
    // amm/contract.py:134-140
    // to_mint = tokens_to_mint(
    //     pool_balance=self._current_pool_balance(),
    //     a_balance=self._current_a_balance(),
    //     b_balance=self._current_b_balance(),
    //     a_amount=a_xfer.asset_amount,
    //     b_amount=b_xfer.asset_amount,
    // )
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    uncover 4
    callsub tokens_to_mint
    // amm/contract.py:141
    // assert to_mint > 0, "send amount too low"
    dup
    int 0
    >
    assert // send amount too low
    // amm/contract.py:143-144
    // # mint tokens
    // do_asset_transfer(receiver=Txn.sender, asset=self.pool_token, amount=to_mint)
    txn Sender
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    uncover 2
    callsub do_asset_transfer
    // amm/contract.py:145
    // self._update_ratio()
    callsub _update_ratio
    retsub


// examples.amm.contract.ConstantProductAMM._check_bootstrapped() -> void:
_check_bootstrapped:
    // amm/contract.py:251-252
    // @subroutine
    // def _check_bootstrapped(self) -> None:
    proto 0 0
    // amm/contract.py:253
    // assert self.pool_token, "bootstrap method needs to be called first"
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    assert // bootstrap method needs to be called first
    retsub


// examples.amm.contract.ConstantProductAMM._current_pool_balance() -> uint64:
_current_pool_balance:
    // amm/contract.py:291-292
    // @subroutine
    // def _current_pool_balance(self) -> UInt64:
    proto 0 1
    // amm/contract.py:293
    // return self.pool_token.balance(Global.current_application_address)
    global CurrentApplicationAddress
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    asset_holding_get AssetBalance
    assert // account opted into asset
    retsub


// examples.amm.contract.ConstantProductAMM._current_a_balance() -> uint64:
_current_a_balance:
    // amm/contract.py:295-296
    // @subroutine
    // def _current_a_balance(self) -> UInt64:
    proto 0 1
    // amm/contract.py:297
    // return self.asset_a.balance(Global.current_application_address)
    global CurrentApplicationAddress
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    asset_holding_get AssetBalance
    assert // account opted into asset
    retsub


// examples.amm.contract.ConstantProductAMM._current_b_balance() -> uint64:
_current_b_balance:
    // amm/contract.py:299-300
    // @subroutine
    // def _current_b_balance(self) -> UInt64:
    proto 0 1
    // amm/contract.py:301
    // return self.asset_b.balance(Global.current_application_address)
    global CurrentApplicationAddress
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    asset_holding_get AssetBalance
    assert // account opted into asset
    retsub


// examples.amm.contract.tokens_to_mint(pool_balance: uint64, a_balance: uint64, b_balance: uint64, a_amount: uint64, b_amount: uint64) -> uint64:
tokens_to_mint:
    // amm/contract.py:322-330
    // @subroutine
    // def tokens_to_mint(
    //     *,
    //     pool_balance: UInt64,
    //     a_balance: UInt64,
    //     b_balance: UInt64,
    //     a_amount: UInt64,
    //     b_amount: UInt64,
    // ) -> UInt64:
    proto 5 1
    byte ""
    dup
    // amm/contract.py:331
    // is_initial_mint = a_balance == a_amount and b_balance == b_amount
    frame_dig -4
    frame_dig -2
    ==
    bz tokens_to_mint_bool_false@3
    frame_dig -3
    frame_dig -1
    ==
    bz tokens_to_mint_bool_false@3
    int 1
    b tokens_to_mint_bool_merge@4

tokens_to_mint_bool_false@3:
    int 0

tokens_to_mint_bool_merge@4:
    // amm/contract.py:332
    // if is_initial_mint:
    bz tokens_to_mint_after_if_else@6
    // amm/contract.py:333
    // return op.sqrt(a_amount * b_amount) - SCALE
    frame_dig -2
    frame_dig -1
    *
    sqrt
    int 1000
    -
    frame_bury 0
    retsub

tokens_to_mint_after_if_else@6:
    // amm/contract.py:334
    // issued = TOTAL_SUPPLY - pool_balance
    int 10000000000
    frame_dig -5
    -
    // amm/contract.py:335
    // a_ratio = SCALE * a_amount // (a_balance - a_amount)
    int 1000
    frame_dig -2
    *
    frame_dig -4
    frame_dig -2
    -
    /
    dup
    frame_bury 0
    // amm/contract.py:336
    // b_ratio = SCALE * b_amount // (b_balance - b_amount)
    int 1000
    frame_dig -1
    *
    frame_dig -3
    frame_dig -1
    -
    /
    dup
    frame_bury 1
    // amm/contract.py:337
    // if a_ratio < b_ratio:
    <
    bz tokens_to_mint_else_body@8
    // amm/contract.py:338
    // return a_ratio * issued // SCALE
    frame_dig 0
    uncover 1
    *
    int 1000
    /
    frame_bury 0
    retsub

tokens_to_mint_else_body@8:
    // amm/contract.py:340
    // return b_ratio * issued // SCALE
    frame_dig 1
    uncover 1
    *
    int 1000
    /
    frame_bury 0
    retsub


// examples.amm.contract.ConstantProductAMM._update_ratio() -> void:
_update_ratio:
    // amm/contract.py:255-256
    // @subroutine
    // def _update_ratio(self) -> None:
    proto 0 0
    // amm/contract.py:257
    // a_balance = self._current_a_balance()
    callsub _current_a_balance
    // amm/contract.py:258
    // b_balance = self._current_b_balance()
    callsub _current_b_balance
    cover 1
    // amm/contract.py:260
    // self.ratio = a_balance * SCALE // b_balance
    int 1000
    *
    uncover 1
    /
    byte "ratio"
    uncover 1
    app_global_put
    retsub


// examples.amm.contract.ConstantProductAMM.burn(pool_xfer: uint64, pool_asset: uint64, a_asset: uint64, b_asset: uint64) -> void:
burn:
    // amm/contract.py:147-160
    // @arc4.abimethod(
    //     default_args={
    //         "pool_asset": "pool_token",
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    // def burn(
    //     self,
    //     pool_xfer: gtxn.AssetTransferTransaction,
    //     pool_asset: Asset,
    //     a_asset: Asset,
    //     b_asset: Asset,
    // ) -> None:
    proto 4 0
    // amm/contract.py:170
    // self._check_bootstrapped()
    callsub _check_bootstrapped
    // amm/contract.py:172
    // assert pool_asset == self.pool_token, "asset pool incorrect"
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    frame_dig -3
    uncover 1
    ==
    assert // asset pool incorrect
    // amm/contract.py:173
    // assert a_asset == self.asset_a, "asset a incorrect"
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    frame_dig -2
    uncover 1
    ==
    assert // asset a incorrect
    // amm/contract.py:174
    // assert b_asset == self.asset_b, "asset b incorrect"
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    frame_dig -1
    uncover 1
    ==
    assert // asset b incorrect
    // amm/contract.py:177
    // pool_xfer.asset_receiver == Global.current_application_address
    frame_dig -4
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // amm/contract.py:176-178
    // assert (
    //     pool_xfer.asset_receiver == Global.current_application_address
    // ), "receiver not app address"
    assert // receiver not app address
    // amm/contract.py:179
    // assert pool_xfer.asset_amount > 0, "amount minimum not met"
    frame_dig -4
    gtxns AssetAmount
    int 0
    >
    assert // amount minimum not met
    // amm/contract.py:180
    // assert pool_xfer.xfer_asset == self.pool_token, "asset pool incorrect"
    frame_dig -4
    gtxns XferAsset
    int 0
    byte "pool_token"
    app_global_get_ex
    assert // check pool_token exists
    ==
    assert // asset pool incorrect
    // amm/contract.py:181
    // assert pool_xfer.sender == Txn.sender, "sender invalid"
    frame_dig -4
    gtxns Sender
    txn Sender
    ==
    assert // sender invalid
    // amm/contract.py:183-185
    // # Get the total number of tokens issued
    // # !important: this happens prior to receiving the current axfer of pool tokens
    // pool_balance = self._current_pool_balance()
    callsub _current_pool_balance
    // amm/contract.py:188
    // supply=self._current_a_balance(),
    callsub _current_a_balance
    // amm/contract.py:189
    // amount=pool_xfer.asset_amount,
    frame_dig -4
    gtxns AssetAmount
    // amm/contract.py:186-190
    // a_amt = tokens_to_burn(
    //     pool_balance=pool_balance,
    //     supply=self._current_a_balance(),
    //     amount=pool_xfer.asset_amount,
    // )
    dig 2
    uncover 2
    uncover 2
    callsub tokens_to_burn
    cover 1
    // amm/contract.py:193
    // supply=self._current_b_balance(),
    callsub _current_b_balance
    // amm/contract.py:194
    // amount=pool_xfer.asset_amount,
    frame_dig -4
    gtxns AssetAmount
    // amm/contract.py:191-195
    // b_amt = tokens_to_burn(
    //     pool_balance=pool_balance,
    //     supply=self._current_b_balance(),
    //     amount=pool_xfer.asset_amount,
    // )
    uncover 2
    uncover 2
    uncover 2
    callsub tokens_to_burn
    cover 1
    // amm/contract.py:197-198
    // # Send back commensurate amt of a
    // do_asset_transfer(receiver=Txn.sender, asset=self.asset_a, amount=a_amt)
    txn Sender
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    uncover 2
    callsub do_asset_transfer
    // amm/contract.py:200-201
    // # Send back commensurate amt of b
    // do_asset_transfer(receiver=Txn.sender, asset=self.asset_b, amount=b_amt)
    txn Sender
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    uncover 2
    callsub do_asset_transfer
    // amm/contract.py:202
    // self._update_ratio()
    callsub _update_ratio
    retsub


// examples.amm.contract.tokens_to_burn(pool_balance: uint64, supply: uint64, amount: uint64) -> uint64:
tokens_to_burn:
    // amm/contract.py:343-344
    // @subroutine
    // def tokens_to_burn(*, pool_balance: UInt64, supply: UInt64, amount: UInt64) -> UInt64:
    proto 3 1
    // amm/contract.py:345
    // issued = TOTAL_SUPPLY - pool_balance - amount
    int 10000000000
    frame_dig -3
    -
    frame_dig -1
    -
    // amm/contract.py:346
    // return supply * amount // issued
    frame_dig -2
    frame_dig -1
    *
    uncover 1
    /
    retsub


// examples.amm.contract.ConstantProductAMM.swap(swap_xfer: uint64, a_asset: uint64, b_asset: uint64) -> void:
swap:
    // amm/contract.py:204-215
    // @arc4.abimethod(
    //     default_args={
    //         "a_asset": "asset_a",
    //         "b_asset": "asset_b",
    //     },
    // )
    // def swap(
    //     self,
    //     swap_xfer: gtxn.AssetTransferTransaction,
    //     a_asset: Asset,
    //     b_asset: Asset,
    // ) -> None:
    proto 3 0
    byte ""
    dup
    // amm/contract.py:223
    // self._check_bootstrapped()
    callsub _check_bootstrapped
    // amm/contract.py:225
    // assert a_asset == self.asset_a, "asset a incorrect"
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    frame_dig -2
    uncover 1
    ==
    assert // asset a incorrect
    // amm/contract.py:226
    // assert b_asset == self.asset_b, "asset b incorrect"
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    frame_dig -1
    uncover 1
    ==
    assert // asset b incorrect
    // amm/contract.py:228
    // assert swap_xfer.asset_amount > 0, "amount minimum not met"
    frame_dig -3
    gtxns AssetAmount
    int 0
    >
    assert // amount minimum not met
    // amm/contract.py:229
    // assert swap_xfer.sender == Txn.sender, "sender invalid"
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // sender invalid
    // amm/contract.py:232
    // case self.asset_a:
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    // amm/contract.py:236
    // case self.asset_b:
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    // amm/contract.py:231
    // match swap_xfer.xfer_asset:
    frame_dig -3
    gtxns XferAsset
    // amm/contract.py:231-241
    // match swap_xfer.xfer_asset:
    //     case self.asset_a:
    //         in_supply = self._current_b_balance()
    //         out_supply = self._current_a_balance()
    //         out_asset = self.asset_a
    //     case self.asset_b:
    //         in_supply = self._current_a_balance()
    //         out_supply = self._current_b_balance()
    //         out_asset = self.asset_b
    //     case _:
    //         assert False, "asset id incorrect"
    uncover 2
    uncover 2
    uncover 2
    match swap_switch_case_0@1 swap_switch_case_1@2
    // amm/contract.py:241
    // assert False, "asset id incorrect"
    b swap_switch_case_default@3

swap_switch_case_0@1:
    // amm/contract.py:233
    // in_supply = self._current_b_balance()
    callsub _current_b_balance
    frame_bury 0
    // amm/contract.py:234
    // out_supply = self._current_a_balance()
    callsub _current_a_balance
    // amm/contract.py:235
    // out_asset = self.asset_a
    int 0
    byte "asset_a"
    app_global_get_ex
    assert // check asset_a exists
    frame_bury 1
    b swap_switch_case_next@4

swap_switch_case_1@2:
    // amm/contract.py:237
    // in_supply = self._current_a_balance()
    callsub _current_a_balance
    frame_bury 0
    // amm/contract.py:238
    // out_supply = self._current_b_balance()
    callsub _current_b_balance
    // amm/contract.py:239
    // out_asset = self.asset_b
    int 0
    byte "asset_b"
    app_global_get_ex
    assert // check asset_b exists
    frame_bury 1
    b swap_switch_case_next@4

swap_switch_case_default@3:
    // amm/contract.py:241
    // assert False, "asset id incorrect"
    err // asset id incorrect

swap_switch_case_next@4:
    // amm/contract.py:244
    // in_amount=swap_xfer.asset_amount, in_supply=in_supply, out_supply=out_supply
    frame_dig -3
    gtxns AssetAmount
    // amm/contract.py:243-245
    // to_swap = tokens_to_swap(
    //     in_amount=swap_xfer.asset_amount, in_supply=in_supply, out_supply=out_supply
    // )
    frame_dig 0
    uncover 2
    callsub tokens_to_swap
    // amm/contract.py:246
    // assert to_swap > 0, "send amount too low"
    dup
    int 0
    >
    assert // send amount too low
    // amm/contract.py:248
    // do_asset_transfer(receiver=Txn.sender, asset=out_asset, amount=to_swap)
    txn Sender
    frame_dig 1
    uncover 2
    callsub do_asset_transfer
    // amm/contract.py:249
    // self._update_ratio()
    callsub _update_ratio
    retsub


// examples.amm.contract.tokens_to_swap(in_amount: uint64, in_supply: uint64, out_supply: uint64) -> uint64:
tokens_to_swap:
    // amm/contract.py:349-350
    // @subroutine
    // def tokens_to_swap(*, in_amount: UInt64, in_supply: UInt64, out_supply: UInt64) -> UInt64:
    proto 3 1
    // amm/contract.py:351
    // in_total = SCALE * (in_supply - in_amount) + (in_amount * FACTOR)
    frame_dig -2
    frame_dig -3
    -
    int 1000
    uncover 1
    *
    frame_dig -3
    int 995
    *
    +
    // amm/contract.py:352
    // out_total = in_amount * FACTOR * out_supply
    frame_dig -3
    int 995
    *
    frame_dig -1
    *
    // amm/contract.py:353
    // return out_total // in_total
    uncover 1
    /
    retsub


// examples.amm.contract.ConstantProductAMM.__init__() -> void:
__init__:
    // amm/contract.py:28
    // def __init__(self) -> None:
    proto 0 0
    // amm/contract.py:32-33
    // # The asset id of asset A
    // self.asset_a = Asset()
    byte "asset_a"
    int 0
    app_global_put
    // amm/contract.py:34-35
    // # The asset id of asset B
    // self.asset_b = Asset()
    byte "asset_b"
    int 0
    app_global_put
    // amm/contract.py:36-37
    // # The current governor of this contract, allowed to do admin type actions
    // self.governor = Txn.sender
    txn Sender
    byte "governor"
    uncover 1
    app_global_put
    // amm/contract.py:38-39
    // # The asset id of the Pool Token, used to track share of pool the holder may recover
    // self.pool_token = Asset()
    byte "pool_token"
    int 0
    app_global_put
    // amm/contract.py:40-41
    // # The ratio between assets (A*Scale/B)
    // self.ratio = UInt64(0)
    byte "ratio"
    int 0
    app_global_put
    retsub
