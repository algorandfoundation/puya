contract examples.voting.voting.VotingRoundApp:
    program approval:
        subroutine examples.voting.voting.VotingRoundApp.approval_program() -> uint64:
            block@0: // L45
                let app_id%0#0: uint64 = (txn ApplicationID)
                goto app_id%0#0 ? block@2 : block@1
            block@1: // on_create_L46
                examples.voting.voting.VotingRoundApp.__init__()
                goto block@2
            block@2: // entrypoint_L46
                let tmp%1#0: bytes = (txna ApplicationArgs 0)
                switch tmp%1#0 {method "create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void" => block@3, method "bootstrap(pay)void" => block@4, method "close()void" => block@5, method "get_preconditions(byte[])(uint64,uint64,uint64,uint64)" => block@6, method "vote(pay,byte[],uint8[])void" => block@7, * => block@8}
            block@3: // create_route_L52
                let tmp%2#0: uint64 = (txn OnCompletion)
                let tmp%3#0: uint64 = (== tmp%2#0 NoOp)
                (assert tmp%3#0) // OnCompletion is NoOp
                let tmp%4#0: uint64 = (txn ApplicationID)
                let tmp%5#0: uint64 = (! tmp%4#0)
                (assert tmp%5#0) // is creating
                let tmp%6#0: bytes = (txna ApplicationArgs 1)
                let tmp%7#0: bytes = (txna ApplicationArgs 2)
                let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
                let tmp%9#0: bytes = (txna ApplicationArgs 3)
                let tmp%10#0: bytes = (txna ApplicationArgs 4)
                let tmp%11#0: uint64 = (btoi tmp%10#0)
                let tmp%12#0: bytes = (txna ApplicationArgs 5)
                let tmp%13#0: uint64 = (btoi tmp%12#0)
                let tmp%14#0: bytes = (txna ApplicationArgs 6)
                let tmp%15#0: bytes = (txna ApplicationArgs 7)
                let tmp%16#0: uint64 = (btoi tmp%15#0)
                let tmp%17#0: bytes = (txna ApplicationArgs 8)
                examples.voting.voting.VotingRoundApp.create(tmp%6#0, tmp%8#0, tmp%9#0, tmp%11#0, tmp%13#0, tmp%14#0, tmp%16#0, tmp%17#0)
                return 1u
            block@4: // bootstrap_route_L76
                let tmp%18#0: uint64 = (txn OnCompletion)
                let tmp%19#0: uint64 = (== tmp%18#0 NoOp)
                (assert tmp%19#0) // OnCompletion is NoOp
                let tmp%20#0: uint64 = (txn ApplicationID)
                (assert tmp%20#0) // is not creating
                let tmp%23#0: uint64 = (txn GroupIndex)
                let awst_tmp%24#0: uint64 = (- tmp%23#0 1u)
                let tmp%25#0: uint64 = ((gtxns TypeEnum) awst_tmp%24#0)
                let tmp%26#0: uint64 = (== tmp%25#0 pay)
                let maybe_value_did_exist%22#0: uint64 = tmp%26#0
                let maybe_value%21#0: uint64 = awst_tmp%24#0
                (assert maybe_value_did_exist%22#0) // transaction type is pay
                examples.voting.voting.VotingRoundApp.bootstrap(maybe_value%21#0)
                return 1u
            block@5: // close_route_L104
                let tmp%27#0: uint64 = (txn OnCompletion)
                let tmp%28#0: uint64 = (== tmp%27#0 NoOp)
                (assert tmp%28#0) // OnCompletion is NoOp
                let tmp%29#0: uint64 = (txn ApplicationID)
                (assert tmp%29#0) // is not creating
                examples.voting.voting.VotingRoundApp.close()
                return 1u
            block@6: // get_preconditions_route_L152
                let tmp%30#0: uint64 = (txn OnCompletion)
                let tmp%31#0: uint64 = (== tmp%30#0 NoOp)
                (assert tmp%31#0) // OnCompletion is NoOp
                let tmp%32#0: uint64 = (txn ApplicationID)
                (assert tmp%32#0) // is not creating
                let tmp%33#0: bytes = (txna ApplicationArgs 1)
                let tmp%34#0: bytes = examples.voting.voting.VotingRoundApp.get_preconditions(tmp%33#0)
                let tmp%35#0: bytes = (concat 0x151f7c75 tmp%34#0)
                (log tmp%35#0)
                return 1u
            block@7: // vote_route_L161
                let tmp%36#0: uint64 = (txn OnCompletion)
                let tmp%37#0: uint64 = (== tmp%36#0 NoOp)
                (assert tmp%37#0) // OnCompletion is NoOp
                let tmp%38#0: uint64 = (txn ApplicationID)
                (assert tmp%38#0) // is not creating
                let tmp%41#0: uint64 = (txn GroupIndex)
                let awst_tmp%24#0: uint64 = (- tmp%41#0 1u)
                let tmp%42#0: uint64 = ((gtxns TypeEnum) awst_tmp%24#0)
                let tmp%43#0: uint64 = (== tmp%42#0 pay)
                let maybe_value_did_exist%40#0: uint64 = tmp%43#0
                let maybe_value%39#0: uint64 = awst_tmp%24#0
                (assert maybe_value_did_exist%40#0) // transaction type is pay
                let tmp%44#0: bytes = (txna ApplicationArgs 1)
                let tmp%45#0: bytes = ((extract 2 0) tmp%44#0)
                let tmp%46#0: bytes = (txna ApplicationArgs 2)
                examples.voting.voting.VotingRoundApp.vote(maybe_value%39#0, tmp%45#0, tmp%46#0)
                return 1u
            block@8: // switch_case_default_L45
                goto block@9
            block@9: // switch_case_next_L45
                fail // reject transaction
        
        subroutine examples.voting.voting.VotingRoundApp.create(vote_id: bytes, snapshot_public_key: bytes, metadata_ipfs_cid: bytes, start_time: uint64, end_time: uint64, option_counts: bytes, quorum: uint64, nft_image_url: bytes) -> void:
            block@0: // L52
                let tmp%0#0: uint64 = (< start_time#0 end_time#0)
                (assert tmp%0#0) // End time should be after start time
                let tmp%1#0: uint64 = (global LatestTimestamp)
                let tmp%2#0: uint64 = (>= end_time#0 tmp%1#0)
                (assert tmp%2#0) // End time should be in the future
                let new_state_value%3#0: bytes = ((extract 2 0) vote_id#0)
                (app_global_put "vote_id" new_state_value%3#0)
                (app_global_put "snapshot_public_key" snapshot_public_key#0)
                let new_state_value%4#0: bytes = ((extract 2 0) metadata_ipfs_cid#0)
                (app_global_put "metadata_ipfs_cid" new_state_value%4#0)
                (app_global_put "start_time" start_time#0)
                (app_global_put "end_time" end_time#0)
                (app_global_put "quorum" quorum#0)
                let new_state_value%5#0: bytes = ((extract 2 0) nft_image_url#0)
                (app_global_put "nft_image_url" new_state_value%5#0)
                examples.voting.voting.VotingRoundApp.store_option_counts(option_counts#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.store_option_counts(option_counts: bytes) -> void:
            block@0: // L207
                let tmp%0#0: uint64 = (extract_uint16 option_counts#0 0u)
                (assert tmp%0#0) // option_counts should be non-empty
                let tmp%1#0: uint64 = (extract_uint16 option_counts#0 0u)
                let tmp%2#0: uint64 = (<= tmp%1#0 112u)
                (assert tmp%2#0) // Can't have more than 112 questions
                let total_options#0: uint64 = 0u
                let array_length%3#0: uint64 = (extract_uint16 option_counts#0 0u)
                let array_value%4#0: bytes = ((extract 2 0) option_counts#0)
                let item_index_internal%5#0: uint64 = 0u
                let reverse_index_internal%6#0: uint64 = array_length%3#0
                goto block@1
            block@1: // for_header_L213
                let continue_looping%7#0: uint64 = (< item_index_internal%5#0 array_length%3#0)
                goto continue_looping%7#0 ? block@2 : block@4
            block@2: // for_body_L213
                let item_index%8#0: uint64 = (* item_index_internal%5#0 1u)
                let item#0: bytes = (extract3 array_value%4#0 item_index%8#0 1u)
                let tmp%9#0: uint64 = (btoi item#0)
                let total_options#0: uint64 = (+ total_options#0 tmp%9#0)
                goto block@3
            block@3: // for_footer_L213
                let item_index_internal%5#0: uint64 = (+ item_index_internal%5#0 1u)
                goto block@1
            block@4: // after_for_L213
                let tmp%10#0: uint64 = (<= total_options#0 128u)
                (assert tmp%10#0) // Can't have more than 128 vote options
                (app_global_put "option_counts" option_counts#0)
                (app_global_put "total_options" total_options#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.bootstrap(fund_min_bal_req: uint64) -> void:
            block@0: // L76
                let (app_global_get_ex_value%0#0: uint64, app_global_get_ex_did_exist%1#0: uint64) = (app_global_get_ex 0u "is_bootstrapped")
                (assert app_global_get_ex_did_exist%1#0) // check value exists
                let tmp%2#0: uint64 = (! app_global_get_ex_value%0#0)
                (assert tmp%2#0) // Must not be already bootstrapped
                (app_global_put "is_bootstrapped" 1u)
                let tmp%3#0: bytes = ((gtxns Receiver) fund_min_bal_req#0)
                let tmp%4#0: bytes = (global CurrentApplicationAddress)
                let tmp%5#0: uint64 = (== tmp%3#0 tmp%4#0)
                (assert tmp%5#0) // Payment must be to app address
                let (app_global_get_ex_value%6#0: uint64, app_global_get_ex_did_exist%7#0: uint64) = (app_global_get_ex 0u "total_options")
                (assert app_global_get_ex_did_exist%7#0) // check value exists
                let tally_box_size#0: uint64 = (* app_global_get_ex_value%6#0 8u)
                let tmp%8#0: uint64 = (* tally_box_size#0 400u)
                let min_balance_req#0: uint64 = (+ 203900u tmp%8#0)
                let tmp%9#0: bytes = (itob min_balance_req#0)
                (log tmp%9#0)
                let tmp%10#0: uint64 = ((gtxns Amount) fund_min_bal_req#0)
                let tmp%11#0: uint64 = (== tmp%10#0 min_balance_req#0)
                (assert tmp%11#0) // Payment must be for the exact min balance requirement
                let tmp%12#0: uint64 = (box_create "V" tally_box_size#0)
                (assert tmp%12#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.close() -> void:
            block@0: // L104
                puyapy.ensure_budget(20000u, 0u)
                let (tmp%0#0: any, tmp%1#0: uint64) = (app_global_get_ex 0u "close_time")
                let tmp%2#0: uint64 = (! tmp%1#0)
                (assert tmp%2#0) // Already closed
                let new_state_value%3#0: uint64 = (global LatestTimestamp)
                (app_global_put "close_time" new_state_value%3#0)
                let (app_global_get_ex_value%4#0: bytes, app_global_get_ex_did_exist%5#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert app_global_get_ex_did_exist%5#0) // check value exists
                let tmp%6#0: bytes = (concat "{\"standard\":\"arc69\",\"description\":\"This is a voting result NFT for voting round with ID " app_global_get_ex_value%4#0)
                let tmp%7#0: bytes = (concat tmp%6#0 ".\",\"properties\":{\"metadata\":\"ipfs://")
                let (app_global_get_ex_value%8#0: bytes, app_global_get_ex_did_exist%9#0: uint64) = (app_global_get_ex 0u "metadata_ipfs_cid")
                (assert app_global_get_ex_did_exist%9#0) // check value exists
                let tmp%10#0: bytes = (concat tmp%7#0 app_global_get_ex_value%8#0)
                let tmp%11#0: bytes = (concat tmp%10#0 "\",\"id\":\"")
                let (app_global_get_ex_value%12#0: bytes, app_global_get_ex_did_exist%13#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert app_global_get_ex_did_exist%13#0) // check value exists
                let tmp%14#0: bytes = (concat tmp%11#0 app_global_get_ex_value%12#0)
                let tmp%15#0: bytes = (concat tmp%14#0 "\",\"quorum\":")
                let (app_global_get_ex_value%16#0: uint64, app_global_get_ex_did_exist%17#0: uint64) = (app_global_get_ex 0u "quorum")
                (assert app_global_get_ex_did_exist%17#0) // check value exists
                let tmp%18#0: bytes = examples.voting.voting.itoa(app_global_get_ex_value%16#0)
                let tmp%19#0: bytes = (concat tmp%15#0 tmp%18#0)
                let tmp%20#0: bytes = (concat tmp%19#0 ",\"voterCount\":")
                let (app_global_get_ex_value%21#0: uint64, app_global_get_ex_did_exist%22#0: uint64) = (app_global_get_ex 0u "voter_count")
                (assert app_global_get_ex_did_exist%22#0) // check value exists
                let tmp%23#0: bytes = examples.voting.voting.itoa(app_global_get_ex_value%21#0)
                let tmp%24#0: bytes = (concat tmp%20#0 tmp%23#0)
                let note#0: bytes = (concat tmp%24#0 ",\"tallies\":[")
                let current_index#0: uint64 = 0u
                let (app_global_get_ex_value%25#0: bytes, app_global_get_ex_did_exist%26#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert app_global_get_ex_did_exist%26#0) // check value exists
                let array_length%27#0: uint64 = (extract_uint16 app_global_get_ex_value%25#0 0u)
                let array_value%28#0: bytes = ((extract 2 0) app_global_get_ex_value%25#0)
                let item_index_internal%29#0: uint64 = 0u
                let reverse_index_internal%30#0: uint64 = array_length%27#0
                goto block@1
            block@1: // for_header_L126
                let continue_looping%31#0: uint64 = (< item_index_internal%29#0 array_length%27#0)
                goto continue_looping%31#0 ? block@2 : block@15
            block@2: // for_body_L126
                let item_index%32#0: uint64 = (* item_index_internal%29#0 1u)
                let question_options_arc#0: bytes = (extract3 array_value%28#0 item_index%32#0 1u)
                let question_index#0: uint64 = item_index_internal%29#0
                let tmp%33#0: uint64 = (> question_index#0 0u)
                let note#18: bytes = note#0
                goto tmp%33#0 ? block@3 : block@4
            block@3: // if_body_L127
                let note#0: bytes = (concat note#0 ",")
                let note#18: bytes = note#0
                goto block@4
            block@4: // after_if_else_L127
                let note#0: bytes = note#18
                let question_options#0: uint64 = (btoi question_options_arc#0)
                let tmp%34#0: uint64 = (> question_options#0 0u)
                let current_index#16: uint64 = current_index#0
                let note#18: bytes = note#0
                goto tmp%34#0 ? block@5 : block@13
            block@5: // if_body_L130
                let note#0: bytes = (concat note#0 "[")
                (assert 1u) // Step cannot be zero
                let range_item%35#0: uint64 = 0u
                goto block@6
            block@6: // for_header_L132
                let continue_looping%36#0: uint64 = (< range_item%35#0 question_options#0)
                goto continue_looping%36#0 ? block@7 : block@12
            block@7: // for_body_L132
                let option_index#0: uint64 = range_item%35#0
                let tmp%37#0: uint64 = (> option_index#0 0u)
                let note#18: bytes = note#0
                goto tmp%37#0 ? block@8 : block@9
            block@8: // if_body_L133
                let note#0: bytes = (concat note#0 ",")
                let note#18: bytes = note#0
                goto block@9
            block@9: // after_if_else_L133
                let note#0: bytes = note#18
                let votes_for_option#0: uint64 = examples.voting.voting.get_vote_from_box(current_index#0)
                let tmp%38#0: bytes = examples.voting.voting.itoa(votes_for_option#0)
                let note#0: bytes = (concat note#0 tmp%38#0)
                let current_index#0: uint64 = (+ current_index#0 1u)
                goto block@10
            block@10: // for_footer_L132
                goto block@11
            block@11: // for_increment_L132
                let range_item%35#0: uint64 = (+ range_item%35#0 1u)
                goto block@6
            block@12: // after_for_L132
                let note#0: bytes = (concat note#0 "]")
                let current_index#16: uint64 = current_index#0
                let note#18: bytes = note#0
                goto block@13
            block@13: // after_if_else_L130
                let current_index#0: uint64 = current_index#16
                let note#0: bytes = note#18
                goto block@14
            block@14: // for_footer_L126
                let item_index_internal%29#0: uint64 = (+ item_index_internal%29#0 1u)
                goto block@1
            block@15: // after_for_L126
                let note#0: bytes = (concat note#0 "]}}")
                itxn_begin
                ((itxn_field TypeEnum) acfg)
                ((itxn_field ConfigAssetTotal) 1u)
                ((itxn_field ConfigAssetDecimals) 0u)
                ((itxn_field ConfigAssetDefaultFrozen) 0u)
                let (app_global_get_ex_value%39#0: bytes, app_global_get_ex_did_exist%40#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert app_global_get_ex_did_exist%40#0) // check value exists
                let tmp%41#0: bytes = (concat "[VOTE RESULT] " app_global_get_ex_value%39#0)
                ((itxn_field ConfigAssetName) tmp%41#0)
                ((itxn_field ConfigAssetUnitName) "VOTERSLT")
                let (app_global_get_ex_value%42#0: bytes, app_global_get_ex_did_exist%43#0: uint64) = (app_global_get_ex 0u "nft_image_url")
                (assert app_global_get_ex_did_exist%43#0) // check value exists
                ((itxn_field ConfigAssetURL) app_global_get_ex_value%42#0)
                ((itxn_field Note) note#0)
                itxn_submit
                let new_state_value%44#0: uint64 = (itxn CreatedAssetID)
                (app_global_put "nft_asset_id" new_state_value%44#0)
                return 
        
        subroutine puyapy.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
            block@0: // L11
                let required_budget_with_buffer#0: uint64 = (+ required_budget#0 10u)
                goto block@1
            block@1: // while_top_L19
                let tmp%0#0: uint64 = (global OpcodeBudget)
                let tmp%1#0: uint64 = (> required_budget_with_buffer#0 tmp%0#0)
                goto tmp%1#0 ? block@2 : block@7
            block@2: // while_body_L19
                itxn_begin
                ((itxn_field TypeEnum) appl)
                ((itxn_field OnCompletion) DeleteApplication)
                ((itxn_field ApprovalProgram) 0x068101)
                ((itxn_field ClearStateProgram) 0x068101)
                switch fee_source#0 {0u => block@3, 1u => block@4, * => block@5}
            block@3: // switch_case_0_L27
                ((itxn_field Fee) 0u)
                goto block@6
            block@4: // switch_case_1_L29
                let tmp%2#0: uint64 = (global MinTxnFee)
                ((itxn_field Fee) tmp%2#0)
                goto block@6
            block@5: // switch_case_default_L25
                goto block@6
            block@6: // switch_case_next_L25
                itxn_submit
                goto block@1
            block@7: // after_while_L19
                return 
        
        subroutine examples.voting.voting.itoa(i: uint64) -> bytes:
            block@0: // L245
                let digits#0: bytes = "0123456789"
                let radix#0: uint64 = (len digits#0)
                let tmp%0#0: uint64 = (< i#0 radix#0)
                goto tmp%0#0 ? block@1 : block@2
            block@1: // if_body_L249
                let index_plus_1%1#0: uint64 = (+ i#0 1u)
                let tmp%2#0: bytes = (substring3 digits#0 i#0 index_plus_1%1#0)
                return tmp%2#0
            block@2: // after_if_else_L249
                let tmp%3#0: uint64 = (/ i#0 radix#0)
                let tmp%4#0: bytes = examples.voting.voting.itoa(tmp%3#0)
                let tmp%5#0: uint64 = (% i#0 radix#0)
                let index_plus_1%6#0: uint64 = (+ tmp%5#0 1u)
                let tmp%7#0: bytes = (substring3 digits#0 tmp%5#0 index_plus_1%6#0)
                let tmp%8#0: bytes = (concat tmp%4#0 tmp%7#0)
                return tmp%8#0
        
        subroutine examples.voting.voting.get_vote_from_box(index: uint64) -> uint64:
            block@0: // L230
                let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: uint64) = (box_get "V")
                let box_data#0: bytes = tuple_assignment%0#0
                let exists#0: uint64 = tuple_assignment%1#0
                (assert exists#0) // Box not created
                let tmp%2#0: bytes = (extract3 box_data#0 index#0 8u)
                let tmp%3#0: uint64 = (btoi tmp%2#0)
                return tmp%3#0
        
        subroutine examples.voting.voting.VotingRoundApp.get_preconditions(signature: bytes) -> bytes:
            block@0: // L152
                let tmp%0#0: uint64 = examples.voting.voting.VotingRoundApp.voting_open()
                let val_as_bytes%1#0: bytes = (itob tmp%0#0)
                let awst_tmp%2#0: uint64 = (len signature#0)
                let tmp%3#0: uint64 = (< 2u awst_tmp%2#0)
                goto tmp%3#0 ? block@1 : block@2
            block@1: // ternary_true_L156
                let ternary_result%4#0: uint64 = 2u
                goto block@3
            block@2: // ternary_false_L156
                let ternary_result%4#0: uint64 = awst_tmp%2#0
                goto block@3
            block@3: // ternary_merge_L156
                let base_length%5#0: uint64 = (len signature#0)
                let tmp%6#0: bytes = (substring3 signature#0 ternary_result%4#0 base_length%5#0)
                let tmp%7#0: uint64 = examples.voting.voting.VotingRoundApp.allowed_to_vote(tmp%6#0)
                let val_as_bytes%8#0: bytes = (itob tmp%7#0)
                let tmp%9#0: uint64 = examples.voting.voting.VotingRoundApp.already_voted()
                let val_as_bytes%10#0: bytes = (itob tmp%9#0)
                let tmp%11#0: uint64 = (global LatestTimestamp)
                let val_as_bytes%12#0: bytes = (itob tmp%11#0)
                let current_tail_offset%13#0: uint64 = 32u
                let encoded_tuple_buffer%14#0: bytes = 0x
                let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%1#0)
                let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%8#0)
                let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%10#0)
                let encoded_tuple_buffer%14#0: bytes = (concat encoded_tuple_buffer%14#0 val_as_bytes%12#0)
                return encoded_tuple_buffer%14#0
        
        subroutine examples.voting.voting.VotingRoundApp.voting_open() -> uint64:
            block@0: // L194
                let (app_global_get_ex_value%0#0: uint64, app_global_get_ex_did_exist%1#0: uint64) = (app_global_get_ex 0u "is_bootstrapped")
                (assert app_global_get_ex_did_exist%1#0) // check value exists
                goto app_global_get_ex_value%0#0 ? block@1 : block@5
            block@1: // and_contd_L197
                let (tmp%2#0: any, tmp%3#0: uint64) = (app_global_get_ex 0u "close_time")
                goto tmp%3#0 ? block@5 : block@2
            block@2: // and_contd_L197
                let (app_global_get_ex_value%4#0: uint64, app_global_get_ex_did_exist%5#0: uint64) = (app_global_get_ex 0u "start_time")
                (assert app_global_get_ex_did_exist%5#0) // check value exists
                let awst_tmp%6#0: uint64 = (global LatestTimestamp)
                let tmp%7#0: uint64 = (<= app_global_get_ex_value%4#0 awst_tmp%6#0)
                goto tmp%7#0 ? block@3 : block@5
            block@3: // and_contd_L199
                let (app_global_get_ex_value%8#0: uint64, app_global_get_ex_did_exist%9#0: uint64) = (app_global_get_ex 0u "end_time")
                (assert app_global_get_ex_did_exist%9#0) // check value exists
                let tmp%10#0: uint64 = (<= awst_tmp%6#0 app_global_get_ex_value%8#0)
                goto tmp%10#0 ? block@4 : block@5
            block@4: // bool_true_L197
                let and_result%11#0: uint64 = 1u
                goto block@6
            block@5: // bool_false_L197
                let and_result%11#0: uint64 = 0u
                goto block@6
            block@6: // bool_merge_L197
                return and_result%11#0
        
        subroutine examples.voting.voting.VotingRoundApp.allowed_to_vote(signature: bytes) -> uint64:
            block@0: // L220
                puyapy.ensure_budget(2000u, 2u)
                let tmp%0#0: bytes = (txn Sender)
                let (app_global_get_ex_value%1#0: bytes, app_global_get_ex_did_exist%2#0: uint64) = (app_global_get_ex 0u "snapshot_public_key")
                (assert app_global_get_ex_did_exist%2#0) // check value exists
                let tmp%3#0: uint64 = (ed25519verify_bare tmp%0#0 signature#0 app_global_get_ex_value%1#0)
                return tmp%3#0
        
        subroutine examples.voting.voting.VotingRoundApp.already_voted() -> uint64:
            block@0: // L202
                let tmp%0#0: bytes = (txn Sender)
                let (tuple_assignment%1#0: bytes, tuple_assignment%2#0: uint64) = (box_get tmp%0#0)
                let votes#0: bytes = tuple_assignment%1#0
                let exists#0: uint64 = tuple_assignment%2#0
                return exists#0
        
        subroutine examples.voting.voting.VotingRoundApp.vote(fund_min_bal_req: uint64, signature: bytes, answer_ids: bytes) -> void:
            block@0: // L161
                puyapy.ensure_budget(7700u, 0u)
                let tmp%0#0: uint64 = examples.voting.voting.VotingRoundApp.allowed_to_vote(signature#0)
                (assert tmp%0#0) // Not allowed to vote
                let tmp%1#0: uint64 = examples.voting.voting.VotingRoundApp.voting_open()
                (assert tmp%1#0) // Voting not open
                let tmp%2#0: uint64 = examples.voting.voting.VotingRoundApp.already_voted()
                let tmp%3#0: uint64 = (! tmp%2#0)
                (assert tmp%3#0) // Already voted
                let (app_global_get_ex_value%4#0: bytes, app_global_get_ex_did_exist%5#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert app_global_get_ex_did_exist%5#0) // check value exists
                let questions_count#0: uint64 = (extract_uint16 app_global_get_ex_value%4#0 0u)
                let tmp%6#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let tmp%7#0: uint64 = (== tmp%6#0 questions_count#0)
                (assert tmp%7#0) // Number of answers incorrect
                let tmp%8#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let tmp%9#0: uint64 = (* 1u tmp%8#0)
                let tmp%10#0: uint64 = (+ 34u tmp%9#0)
                let tmp%11#0: uint64 = (* tmp%10#0 400u)
                let min_bal_req#0: uint64 = (+ 2500u tmp%11#0)
                let tmp%12#0: bytes = ((gtxns Receiver) fund_min_bal_req#0)
                let tmp%13#0: bytes = (global CurrentApplicationAddress)
                let tmp%14#0: uint64 = (== tmp%12#0 tmp%13#0)
                (assert tmp%14#0) // Payment must be to app address
                let tmp%15#0: bytes = (itob min_bal_req#0)
                (log tmp%15#0)
                let tmp%16#0: uint64 = ((gtxns Amount) fund_min_bal_req#0)
                let tmp%17#0: uint64 = (== tmp%16#0 min_bal_req#0)
                (assert tmp%17#0) // Payment must be the exact min balance
                let cumulative_offset#0: uint64 = 0u
                (assert 1u) // Step cannot be zero
                let range_item%18#0: uint64 = 0u
                goto block@1
            block@1: // for_header_L184
                let continue_looping%19#0: uint64 = (< range_item%18#0 questions_count#0)
                goto continue_looping%19#0 ? block@2 : block@5
            block@2: // for_body_L184
                let question_index#0: uint64 = range_item%18#0
                let array_length%20#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let index_is_in_bounds%21#0: uint64 = (< question_index#0 array_length%20#0)
                (assert index_is_in_bounds%21#0) // Index access is out of bounds
                let array_data_sans_header%22#0: bytes = ((extract 2 0) answer_ids#0)
                let item_index%23#0: uint64 = (* question_index#0 1u)
                let tmp%24#0: bytes = (extract3 array_data_sans_header%22#0 item_index%23#0 1u)
                let answer_option_index#0: uint64 = (btoi tmp%24#0)
                let (app_global_get_ex_value%25#0: bytes, app_global_get_ex_did_exist%26#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert app_global_get_ex_did_exist%26#0) // check value exists
                let array_length%27#0: uint64 = (extract_uint16 app_global_get_ex_value%25#0 0u)
                let index_is_in_bounds%28#0: uint64 = (< question_index#0 array_length%27#0)
                (assert index_is_in_bounds%28#0) // Index access is out of bounds
                let array_data_sans_header%29#0: bytes = ((extract 2 0) app_global_get_ex_value%25#0)
                let item_index%30#0: uint64 = (* question_index#0 1u)
                let tmp%31#0: bytes = (extract3 array_data_sans_header%29#0 item_index%30#0 1u)
                let options_count#0: uint64 = (btoi tmp%31#0)
                let tmp%32#0: uint64 = (< answer_option_index#0 options_count#0)
                (assert tmp%32#0) // Answer option index invalid
                let tmp%33#0: uint64 = (+ cumulative_offset#0 answer_option_index#0)
                examples.voting.voting.increment_vote_in_box(tmp%33#0)
                let cumulative_offset#0: uint64 = (+ cumulative_offset#0 options_count#0)
                let tmp%34#0: bytes = (txn Sender)
                (box_put tmp%34#0 answer_ids#0)
                let (app_global_get_ex_value%35#0: uint64, app_global_get_ex_did_exist%36#0: uint64) = (app_global_get_ex 0u "voter_count")
                (assert app_global_get_ex_did_exist%36#0) // check value exists
                let new_state_value%37#0: uint64 = (+ app_global_get_ex_value%35#0 1u)
                (app_global_put "voter_count" new_state_value%37#0)
                goto block@3
            block@3: // for_footer_L184
                goto block@4
            block@4: // for_increment_L184
                let range_item%18#0: uint64 = (+ range_item%18#0 1u)
                goto block@1
            block@5: // after_for_L184
                return 
        
        subroutine examples.voting.voting.increment_vote_in_box(index: uint64) -> void:
            block@0: // L237
                let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: uint64) = (box_get "V")
                let box_data#0: bytes = tuple_assignment%0#0
                let exists#0: uint64 = tuple_assignment%1#0
                (assert exists#0) // Box not created
                let tmp%2#0: bytes = (extract3 box_data#0 index#0 8u)
                let current_vote#0: uint64 = (btoi tmp%2#0)
                let tmp%3#0: uint64 = (+ current_vote#0 1u)
                let tmp%4#0: bytes = (itob tmp%3#0)
                (box_replace "V" index#0 tmp%4#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.__init__() -> void:
            block@0: // L46
                (app_global_put "is_bootstrapped" 0u)
                (app_global_put "voter_count" 0u)
                return 
    
    program clear-state:
        subroutine examples.voting.voting.VotingRoundApp.clear_state_program() -> uint64:
            block@0: // L45
                return 1u