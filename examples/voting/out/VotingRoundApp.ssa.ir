contract examples.voting.voting.VotingRoundApp:
    program approval:
        subroutine examples.voting.voting.VotingRoundApp.approval_program() -> uint64:
            block@0: // L48
                let app_id%0#0: uint64 = (txn ApplicationID)
                goto app_id%0#0 ? block@2 : block@1
            block@1: // on_create_L49
                examples.voting.voting.VotingRoundApp.__init__()
                goto block@2
            block@2: // entrypoint_L49
                let tmp%1#0: bytes = (txna ApplicationArgs 0)
                switch tmp%1#0 {method "create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void" => block@3, method "bootstrap(pay)void" => block@4, method "close()void" => block@5, method "get_preconditions(byte[])(uint64,uint64,uint64,uint64)" => block@6, method "vote(pay,byte[],uint8[])void" => block@7, * => block@8}
            block@3: // create_route_L55
                let tmp%2#0: uint64 = (txn OnCompletion)
                let tmp%3#0: uint64 = (== tmp%2#0 NoOp)
                (assert tmp%3#0) // OnCompletion is NoOp
                let tmp%4#0: uint64 = (txn ApplicationID)
                let tmp%5#0: uint64 = (! tmp%4#0)
                (assert tmp%5#0) // is creating
                let tmp%6#0: bytes = (txna ApplicationArgs 1)
                let tmp%7#0: bytes = (txna ApplicationArgs 2)
                let tmp%8#0: bytes = ((extract 2 0) tmp%7#0)
                let tmp%9#0: bytes = (txna ApplicationArgs 3)
                let tmp%10#0: bytes = (txna ApplicationArgs 4)
                let tmp%11#0: uint64 = (btoi tmp%10#0)
                let tmp%12#0: bytes = (txna ApplicationArgs 5)
                let tmp%13#0: uint64 = (btoi tmp%12#0)
                let tmp%14#0: bytes = (txna ApplicationArgs 6)
                let tmp%15#0: bytes = (txna ApplicationArgs 7)
                let tmp%16#0: uint64 = (btoi tmp%15#0)
                let tmp%17#0: bytes = (txna ApplicationArgs 8)
                examples.voting.voting.VotingRoundApp.create(tmp%6#0, tmp%8#0, tmp%9#0, tmp%11#0, tmp%13#0, tmp%14#0, tmp%16#0, tmp%17#0)
                return 1u
            block@4: // bootstrap_route_L79
                let tmp%18#0: uint64 = (txn OnCompletion)
                let tmp%19#0: uint64 = (== tmp%18#0 NoOp)
                (assert tmp%19#0) // OnCompletion is NoOp
                let tmp%20#0: uint64 = (txn ApplicationID)
                (assert tmp%20#0) // is not creating
                let tmp%21#0: uint64 = (txn GroupIndex)
                let awst_tmp%22#0: uint64 = (- tmp%21#0 1u)
                let tmp%23#0: uint64 = ((gtxns TypeEnum) awst_tmp%22#0)
                let tmp%24#0: uint64 = (== tmp%23#0 pay)
                let (value%25#0: uint64, check%26#0: uint64) = (awst_tmp%22#0, tmp%24#0)
                (assert check%26#0) // transaction type is pay
                examples.voting.voting.VotingRoundApp.bootstrap(value%25#0)
                return 1u
            block@5: // close_route_L107
                let tmp%27#0: uint64 = (txn OnCompletion)
                let tmp%28#0: uint64 = (== tmp%27#0 NoOp)
                (assert tmp%28#0) // OnCompletion is NoOp
                let tmp%29#0: uint64 = (txn ApplicationID)
                (assert tmp%29#0) // is not creating
                examples.voting.voting.VotingRoundApp.close()
                return 1u
            block@6: // get_preconditions_route_L157
                let tmp%30#0: uint64 = (txn OnCompletion)
                let tmp%31#0: uint64 = (== tmp%30#0 NoOp)
                (assert tmp%31#0) // OnCompletion is NoOp
                let tmp%32#0: uint64 = (txn ApplicationID)
                (assert tmp%32#0) // is not creating
                let tmp%33#0: bytes = (txna ApplicationArgs 1)
                let tmp%34#0: bytes = examples.voting.voting.VotingRoundApp.get_preconditions(tmp%33#0)
                let tmp%35#0: bytes = (concat 0x151f7c75 tmp%34#0)
                (log tmp%35#0)
                return 1u
            block@7: // vote_route_L166
                let tmp%36#0: uint64 = (txn OnCompletion)
                let tmp%37#0: uint64 = (== tmp%36#0 NoOp)
                (assert tmp%37#0) // OnCompletion is NoOp
                let tmp%38#0: uint64 = (txn ApplicationID)
                (assert tmp%38#0) // is not creating
                let tmp%39#0: uint64 = (txn GroupIndex)
                let awst_tmp%40#0: uint64 = (- tmp%39#0 1u)
                let tmp%41#0: uint64 = ((gtxns TypeEnum) awst_tmp%40#0)
                let tmp%42#0: uint64 = (== tmp%41#0 pay)
                let (value%43#0: uint64, check%44#0: uint64) = (awst_tmp%40#0, tmp%42#0)
                (assert check%44#0) // transaction type is pay
                let tmp%45#0: bytes = (txna ApplicationArgs 1)
                let tmp%46#0: bytes = ((extract 2 0) tmp%45#0)
                let tmp%47#0: bytes = (txna ApplicationArgs 2)
                examples.voting.voting.VotingRoundApp.vote(value%43#0, tmp%46#0, tmp%47#0)
                return 1u
            block@8: // switch_case_default_L48
                goto block@9
            block@9: // switch_case_next_L48
                fail // reject transaction
        
        subroutine examples.voting.voting.VotingRoundApp.create(vote_id: bytes, snapshot_public_key: bytes, metadata_ipfs_cid: bytes, start_time: uint64, end_time: uint64, option_counts: bytes, quorum: uint64, nft_image_url: bytes) -> void:
            block@0: // L55
                let tmp%0#0: uint64 = (< start_time#0 end_time#0)
                (assert tmp%0#0) // End time should be after start time
                let tmp%1#0: uint64 = (global LatestTimestamp)
                let tmp%2#0: uint64 = (>= end_time#0 tmp%1#0)
                (assert tmp%2#0) // End time should be in the future
                let new_state_value%3#0: bytes = ((extract 2 0) vote_id#0)
                (app_global_put "vote_id" new_state_value%3#0)
                (app_global_put "snapshot_public_key" snapshot_public_key#0)
                let new_state_value%4#0: bytes = ((extract 2 0) metadata_ipfs_cid#0)
                (app_global_put "metadata_ipfs_cid" new_state_value%4#0)
                (app_global_put "start_time" start_time#0)
                (app_global_put "end_time" end_time#0)
                (app_global_put "quorum" quorum#0)
                let new_state_value%5#0: bytes = ((extract 2 0) nft_image_url#0)
                (app_global_put "nft_image_url" new_state_value%5#0)
                let copy%6#0: bytes = option_counts#0
                let store_option_counts%7#0: bytes = examples.voting.voting.VotingRoundApp.store_option_counts(copy%6#0)
                let copy%6#1: bytes = store_option_counts%7#0
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.store_option_counts(option_counts: bytes) -> bytes:
            block@0: // L215
                let tmp%0#0: uint64 = (extract_uint16 option_counts#0 0u)
                (assert tmp%0#0) // option_counts should be non-empty
                let tmp%1#0: uint64 = (extract_uint16 option_counts#0 0u)
                let tmp%2#0: uint64 = (<= tmp%1#0 112u)
                (assert tmp%2#0) // Can't have more than 112 questions
                let total_options#0: uint64 = 0u
                let array_length%3#0: uint64 = (extract_uint16 option_counts#0 0u)
                let array_value%4#0: bytes = ((extract 2 0) option_counts#0)
                let item_index_internal%5#0: uint64 = 0u
                let reverse_index_internal%6#0: uint64 = array_length%3#0
                goto block@1
            block@1: // for_header_L221
                let item_index_internal%5#1: uint64 = φ(item_index_internal%5#0 <- block@0, item_index_internal%5#2 <- block@3)
                let total_options#1: uint64 = φ(total_options#0 <- block@0, total_options#2 <- block@3)
                let continue_looping%7#0: uint64 = (< item_index_internal%5#1 array_length%3#0)
                goto continue_looping%7#0 ? block@2 : block@4
            block@2: // for_body_L221
                let item_index%8#0: uint64 = (* item_index_internal%5#1 1u)
                let item#0: bytes = (extract3 array_value%4#0 item_index%8#0 1u)
                let tmp%9#0: uint64 = (btoi item#0)
                let total_options#2: uint64 = (+ total_options#1 tmp%9#0)
                goto block@3
            block@3: // for_footer_L221
                let item_index_internal%5#2: uint64 = (+ item_index_internal%5#1 1u)
                goto block@1
            block@4: // after_for_L221
                let tmp%10#0: uint64 = (<= total_options#1 128u)
                (assert tmp%10#0) // Can't have more than 128 vote options
                let copy%11#0: bytes = option_counts#0
                (app_global_put "option_counts" copy%11#0)
                (app_global_put "total_options" total_options#1)
                return option_counts#0
        
        subroutine examples.voting.voting.VotingRoundApp.bootstrap(fund_min_bal_req: uint64) -> void:
            block@0: // L79
                let (is_bootstrapped_value%0#0: uint64, is_bootstrapped_exists%1#0: uint64) = (app_global_get_ex 0u "is_bootstrapped")
                (assert is_bootstrapped_exists%1#0) // check is_bootstrapped exists
                let tmp%2#0: uint64 = (! is_bootstrapped_value%0#0)
                (assert tmp%2#0) // Must not be already bootstrapped
                (app_global_put "is_bootstrapped" 1u)
                let tmp%3#0: bytes = ((gtxns Receiver) fund_min_bal_req#0)
                let tmp%4#0: bytes = (global CurrentApplicationAddress)
                let tmp%5#0: uint64 = (== tmp%3#0 tmp%4#0)
                (assert tmp%5#0) // Payment must be to app address
                let (total_options_value%6#0: uint64, total_options_exists%7#0: uint64) = (app_global_get_ex 0u "total_options")
                (assert total_options_exists%7#0) // check total_options exists
                let tally_box_size#0: uint64 = (* total_options_value%6#0 8u)
                let tmp%8#0: uint64 = (* tally_box_size#0 400u)
                let min_balance_req#0: uint64 = (+ 203900u tmp%8#0)
                let tmp%9#0: bytes = (itob min_balance_req#0)
                (log tmp%9#0)
                let tmp%10#0: uint64 = ((gtxns Amount) fund_min_bal_req#0)
                let tmp%11#0: uint64 = (== tmp%10#0 min_balance_req#0)
                (assert tmp%11#0) // Payment must be for the exact min balance requirement
                let tmp%12#0: uint64 = (box_create "V" tally_box_size#0)
                (assert tmp%12#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.close() -> void:
            block@0: // L107
                puyapy.ensure_budget(20000u, 0u)
                let (close_time_exists%0#0: any, close_time_exists%1#0: uint64) = (app_global_get_ex 0u "close_time")
                let tmp%2#0: uint64 = (! close_time_exists%1#0)
                (assert tmp%2#0) // Already closed
                let new_state_value%3#0: uint64 = (global LatestTimestamp)
                (app_global_put "close_time" new_state_value%3#0)
                let (vote_id_value%4#0: bytes, vote_id_exists%5#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert vote_id_exists%5#0) // check vote_id exists
                let tmp%6#0: bytes = (concat "{\"standard\":\"arc69\",\"description\":\"This is a voting result NFT for voting round with ID " vote_id_value%4#0)
                let tmp%7#0: bytes = (concat tmp%6#0 ".\",\"properties\":{\"metadata\":\"ipfs://")
                let (metadata_ipfs_cid_value%8#0: bytes, metadata_ipfs_cid_exists%9#0: uint64) = (app_global_get_ex 0u "metadata_ipfs_cid")
                (assert metadata_ipfs_cid_exists%9#0) // check metadata_ipfs_cid exists
                let tmp%10#0: bytes = (concat tmp%7#0 metadata_ipfs_cid_value%8#0)
                let tmp%11#0: bytes = (concat tmp%10#0 "\",\"id\":\"")
                let (vote_id_value%12#0: bytes, vote_id_exists%13#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert vote_id_exists%13#0) // check vote_id exists
                let tmp%14#0: bytes = (concat tmp%11#0 vote_id_value%12#0)
                let tmp%15#0: bytes = (concat tmp%14#0 "\",\"quorum\":")
                let (quorum_value%16#0: uint64, quorum_exists%17#0: uint64) = (app_global_get_ex 0u "quorum")
                (assert quorum_exists%17#0) // check quorum exists
                let tmp%18#0: bytes = examples.voting.voting.itoa(quorum_value%16#0)
                let tmp%19#0: bytes = (concat tmp%15#0 tmp%18#0)
                let tmp%20#0: bytes = (concat tmp%19#0 ",\"voterCount\":")
                let (voter_count_value%21#0: uint64, voter_count_exists%22#0: uint64) = (app_global_get_ex 0u "voter_count")
                (assert voter_count_exists%22#0) // check voter_count exists
                let tmp%23#0: bytes = examples.voting.voting.itoa(voter_count_value%21#0)
                let tmp%24#0: bytes = (concat tmp%20#0 tmp%23#0)
                let note#0: bytes = (concat tmp%24#0 ",\"tallies\":[")
                let current_index#0: uint64 = 0u
                let (option_counts_value%25#0: bytes, option_counts_exists%26#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert option_counts_exists%26#0) // check option_counts exists
                let array_length%27#0: uint64 = (extract_uint16 option_counts_value%25#0 0u)
                let array_value%28#0: bytes = ((extract 2 0) option_counts_value%25#0)
                let item_index_internal%29#0: uint64 = 0u
                let reverse_index_internal%30#0: uint64 = array_length%27#0
                goto block@1
            block@1: // for_header_L129
                let item_index_internal%29#1: uint64 = φ(item_index_internal%29#0 <- block@0, item_index_internal%29#6 <- block@14)
                let note#1: bytes = φ(note#0 <- block@0, note#11 <- block@14)
                let current_index#6: uint64 = φ(current_index#0 <- block@0, current_index#7 <- block@14)
                let continue_looping%31#0: uint64 = (< item_index_internal%29#1 array_length%27#0)
                goto continue_looping%31#0 ? block@2 : block@15
            block@2: // for_body_L129
                let item_index%32#0: uint64 = (* item_index_internal%29#1 1u)
                let question_options_arc#0: bytes = (extract3 array_value%28#0 item_index%32#0 1u)
                let question_index#0: uint64 = item_index_internal%29#1
                let tmp%33#0: uint64 = (> question_index#0 0u)
                goto tmp%33#0 ? block@3 : block@4
            block@3: // if_body_L130
                let note#2: bytes = (concat note#1 ",")
                goto block@4
            block@4: // after_if_else_L130
                let note#3: bytes = φ(note#1 <- block@2, note#2 <- block@3)
                let question_options#0: uint64 = (btoi question_options_arc#0)
                let tmp%34#0: uint64 = (> question_options#0 0u)
                goto tmp%34#0 ? block@5 : block@13
            block@5: // if_body_L133
                let note#4: bytes = (concat note#3 "[")
                (assert 1u) // Step cannot be zero
                let range_item%35#0: uint64 = 0u
                goto block@6
            block@6: // for_header_L135
                let range_item%35#1: uint64 = φ(range_item%35#0 <- block@5, range_item%35#4 <- block@11)
                let note#9: bytes = φ(note#4 <- block@5, note#8 <- block@11)
                let current_index#4: uint64 = φ(current_index#6 <- block@5, current_index#3 <- block@11)
                let continue_looping%36#0: uint64 = (< range_item%35#1 question_options#0)
                goto continue_looping%36#0 ? block@7 : block@12
            block@7: // for_body_L135
                let option_index#0: uint64 = range_item%35#1
                let tmp%37#0: uint64 = (> option_index#0 0u)
                goto tmp%37#0 ? block@8 : block@9
            block@8: // if_body_L136
                let note#6: bytes = (concat note#9 ",")
                goto block@9
            block@9: // after_if_else_L136
                let note#7: bytes = φ(note#9 <- block@7, note#6 <- block@8)
                let votes_for_option#0: uint64 = examples.voting.voting.get_vote_from_box(current_index#4)
                let tmp%38#0: bytes = examples.voting.voting.itoa(votes_for_option#0)
                let note#8: bytes = (concat note#7 tmp%38#0)
                let current_index#3: uint64 = (+ current_index#4 1u)
                goto block@10
            block@10: // for_footer_L135
                goto block@11
            block@11: // for_increment_L135
                let range_item%35#4: uint64 = (+ range_item%35#1 1u)
                goto block@6
            block@12: // after_for_L135
                let note#10: bytes = (concat note#9 "]")
                goto block@13
            block@13: // after_if_else_L133
                let note#11: bytes = φ(note#3 <- block@4, note#10 <- block@12)
                let current_index#7: uint64 = φ(current_index#6 <- block@4, current_index#4 <- block@12)
                goto block@14
            block@14: // for_footer_L129
                let item_index_internal%29#6: uint64 = (+ item_index_internal%29#1 1u)
                goto block@1
            block@15: // after_for_L129
                let note#12: bytes = (concat note#1 "]}}")
                itxn_begin
                let inner_txn_params%40%%param_TypeEnum_idx_0#0: uint64 = acfg
                let inner_txn_params%40%%TypeEnum_length#0: uint64 = 1u
                let inner_txn_params%40%%param_ConfigAssetTotal_idx_0#0: uint64 = 1u
                let inner_txn_params%40%%ConfigAssetTotal_length#0: uint64 = 1u
                let inner_txn_params%40%%param_ConfigAssetDecimals_idx_0#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetDecimals_length#0: uint64 = 1u
                let inner_txn_params%40%%param_ConfigAssetDefaultFrozen_idx_0#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetDefaultFrozen_length#0: uint64 = 1u
                let (vote_id_value%41#0: bytes, vote_id_exists%42#0: uint64) = (app_global_get_ex 0u "vote_id")
                (assert vote_id_exists%42#0) // check vote_id exists
                let inner_txn_params%40%%param_ConfigAssetName_idx_0#0: bytes = (concat "[VOTE RESULT] " vote_id_value%41#0)
                let inner_txn_params%40%%ConfigAssetName_length#0: uint64 = 1u
                let inner_txn_params%40%%param_ConfigAssetUnitName_idx_0#0: bytes = "VOTERSLT"
                let inner_txn_params%40%%ConfigAssetUnitName_length#0: uint64 = 1u
                let (nft_image_url_value%43#0: bytes, nft_image_url_exists%44#0: uint64) = (app_global_get_ex 0u "nft_image_url")
                (assert nft_image_url_exists%44#0) // check nft_image_url exists
                let inner_txn_params%40%%param_ConfigAssetURL_idx_0#0: bytes = nft_image_url_value%43#0
                let inner_txn_params%40%%ConfigAssetURL_length#0: uint64 = 1u
                let inner_txn_params%40%%param_Note_idx_0#0: bytes = note#12
                let inner_txn_params%40%%Note_length#0: uint64 = 1u
                let inner_txn_params%40%%Sender_length#0: uint64 = 0u
                let inner_txn_params%40%%Fee_length#0: uint64 = 0u
                let inner_txn_params%40%%Receiver_length#0: uint64 = 0u
                let inner_txn_params%40%%Amount_length#0: uint64 = 0u
                let inner_txn_params%40%%CloseRemainderTo_length#0: uint64 = 0u
                let inner_txn_params%40%%VotePK_length#0: uint64 = 0u
                let inner_txn_params%40%%SelectionPK_length#0: uint64 = 0u
                let inner_txn_params%40%%VoteFirst_length#0: uint64 = 0u
                let inner_txn_params%40%%VoteLast_length#0: uint64 = 0u
                let inner_txn_params%40%%VoteKeyDilution_length#0: uint64 = 0u
                let inner_txn_params%40%%Type_length#0: uint64 = 0u
                let inner_txn_params%40%%XferAsset_length#0: uint64 = 0u
                let inner_txn_params%40%%AssetAmount_length#0: uint64 = 0u
                let inner_txn_params%40%%AssetSender_length#0: uint64 = 0u
                let inner_txn_params%40%%AssetReceiver_length#0: uint64 = 0u
                let inner_txn_params%40%%AssetCloseTo_length#0: uint64 = 0u
                let inner_txn_params%40%%ApplicationID_length#0: uint64 = 0u
                let inner_txn_params%40%%OnCompletion_length#0: uint64 = 0u
                let inner_txn_params%40%%ApprovalProgram_length#0: uint64 = 0u
                let inner_txn_params%40%%ClearStateProgram_length#0: uint64 = 0u
                let inner_txn_params%40%%RekeyTo_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAsset_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetMetadataHash_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetManager_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetReserve_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetFreeze_length#0: uint64 = 0u
                let inner_txn_params%40%%ConfigAssetClawback_length#0: uint64 = 0u
                let inner_txn_params%40%%FreezeAsset_length#0: uint64 = 0u
                let inner_txn_params%40%%FreezeAssetAccount_length#0: uint64 = 0u
                let inner_txn_params%40%%FreezeAssetFrozen_length#0: uint64 = 0u
                let inner_txn_params%40%%GlobalNumUint_length#0: uint64 = 0u
                let inner_txn_params%40%%GlobalNumByteSlice_length#0: uint64 = 0u
                let inner_txn_params%40%%LocalNumUint_length#0: uint64 = 0u
                let inner_txn_params%40%%LocalNumByteSlice_length#0: uint64 = 0u
                let inner_txn_params%40%%ExtraProgramPages_length#0: uint64 = 0u
                let inner_txn_params%40%%Nonparticipation_length#0: uint64 = 0u
                let inner_txn_params%40%%StateProofPK_length#0: uint64 = 0u
                let inner_txn_params%40%%ApplicationArgs_length#0: uint64 = 0u
                let inner_txn_params%40%%Accounts_length#0: uint64 = 0u
                let inner_txn_params%40%%Assets_length#0: uint64 = 0u
                let inner_txn_params%40%%Applications_length#0: uint64 = 0u
                let inner_txn_params%40%%ApprovalProgramPages_length#0: uint64 = 0u
                let inner_txn_params%40%%ClearStateProgramPages_length#0: uint64 = 0u
                ((itxn_field Note) inner_txn_params%40%%param_Note_idx_0#0)
                ((itxn_field ConfigAssetURL) inner_txn_params%40%%param_ConfigAssetURL_idx_0#0)
                ((itxn_field ConfigAssetUnitName) inner_txn_params%40%%param_ConfigAssetUnitName_idx_0#0)
                ((itxn_field ConfigAssetName) inner_txn_params%40%%param_ConfigAssetName_idx_0#0)
                ((itxn_field ConfigAssetDefaultFrozen) inner_txn_params%40%%param_ConfigAssetDefaultFrozen_idx_0#0)
                ((itxn_field ConfigAssetDecimals) inner_txn_params%40%%param_ConfigAssetDecimals_idx_0#0)
                ((itxn_field ConfigAssetTotal) inner_txn_params%40%%param_ConfigAssetTotal_idx_0#0)
                ((itxn_field TypeEnum) inner_txn_params%40%%param_TypeEnum_idx_0#0)
                goto block@16
            block@16: // next_txn_L144
                itxn_submit
                let %%inner_txn_submit_id#0: uint64 = 1u
                let submit_result_0%39%%Sender#0: bytes = (itxn Sender)
                let submit_result_0%39%%Fee#0: uint64 = (itxn Fee)
                let submit_result_0%39%%FirstValid#0: uint64 = (itxn FirstValid)
                let submit_result_0%39%%FirstValidTime#0: uint64 = (itxn FirstValidTime)
                let submit_result_0%39%%LastValid#0: uint64 = (itxn LastValid)
                let submit_result_0%39%%Note#0: bytes = (itxn Note)
                let submit_result_0%39%%Lease#0: bytes = (itxn Lease)
                let submit_result_0%39%%Receiver#0: bytes = (itxn Receiver)
                let submit_result_0%39%%Amount#0: uint64 = (itxn Amount)
                let submit_result_0%39%%CloseRemainderTo#0: bytes = (itxn CloseRemainderTo)
                let submit_result_0%39%%VotePK#0: bytes = (itxn VotePK)
                let submit_result_0%39%%SelectionPK#0: bytes = (itxn SelectionPK)
                let submit_result_0%39%%VoteFirst#0: uint64 = (itxn VoteFirst)
                let submit_result_0%39%%VoteLast#0: uint64 = (itxn VoteLast)
                let submit_result_0%39%%VoteKeyDilution#0: uint64 = (itxn VoteKeyDilution)
                let submit_result_0%39%%Type#0: bytes = (itxn Type)
                let submit_result_0%39%%TypeEnum#0: uint64 = (itxn TypeEnum)
                let submit_result_0%39%%XferAsset#0: uint64 = (itxn XferAsset)
                let submit_result_0%39%%AssetAmount#0: uint64 = (itxn AssetAmount)
                let submit_result_0%39%%AssetSender#0: bytes = (itxn AssetSender)
                let submit_result_0%39%%AssetReceiver#0: bytes = (itxn AssetReceiver)
                let submit_result_0%39%%AssetCloseTo#0: bytes = (itxn AssetCloseTo)
                let submit_result_0%39%%GroupIndex#0: uint64 = (itxn GroupIndex)
                let submit_result_0%39%%TxID#0: bytes = (itxn TxID)
                let submit_result_0%39%%ApplicationID#0: uint64 = (itxn ApplicationID)
                let submit_result_0%39%%OnCompletion#0: uint64 = (itxn OnCompletion)
                let submit_result_0%39%%NumAppArgs#0: uint64 = (itxn NumAppArgs)
                let submit_result_0%39%%NumAccounts#0: uint64 = (itxn NumAccounts)
                let submit_result_0%39%%ApprovalProgram#0: bytes = (itxn ApprovalProgram)
                let submit_result_0%39%%ClearStateProgram#0: bytes = (itxn ClearStateProgram)
                let submit_result_0%39%%RekeyTo#0: bytes = (itxn RekeyTo)
                let submit_result_0%39%%ConfigAsset#0: uint64 = (itxn ConfigAsset)
                let submit_result_0%39%%ConfigAssetTotal#0: uint64 = (itxn ConfigAssetTotal)
                let submit_result_0%39%%ConfigAssetDecimals#0: uint64 = (itxn ConfigAssetDecimals)
                let submit_result_0%39%%ConfigAssetDefaultFrozen#0: uint64 = (itxn ConfigAssetDefaultFrozen)
                let submit_result_0%39%%ConfigAssetUnitName#0: bytes = (itxn ConfigAssetUnitName)
                let submit_result_0%39%%ConfigAssetName#0: bytes = (itxn ConfigAssetName)
                let submit_result_0%39%%ConfigAssetURL#0: bytes = (itxn ConfigAssetURL)
                let submit_result_0%39%%ConfigAssetMetadataHash#0: bytes = (itxn ConfigAssetMetadataHash)
                let submit_result_0%39%%ConfigAssetManager#0: bytes = (itxn ConfigAssetManager)
                let submit_result_0%39%%ConfigAssetReserve#0: bytes = (itxn ConfigAssetReserve)
                let submit_result_0%39%%ConfigAssetFreeze#0: bytes = (itxn ConfigAssetFreeze)
                let submit_result_0%39%%ConfigAssetClawback#0: bytes = (itxn ConfigAssetClawback)
                let submit_result_0%39%%FreezeAsset#0: uint64 = (itxn FreezeAsset)
                let submit_result_0%39%%FreezeAssetAccount#0: bytes = (itxn FreezeAssetAccount)
                let submit_result_0%39%%FreezeAssetFrozen#0: uint64 = (itxn FreezeAssetFrozen)
                let submit_result_0%39%%NumAssets#0: uint64 = (itxn NumAssets)
                let submit_result_0%39%%NumApplications#0: uint64 = (itxn NumApplications)
                let submit_result_0%39%%GlobalNumUint#0: uint64 = (itxn GlobalNumUint)
                let submit_result_0%39%%GlobalNumByteSlice#0: uint64 = (itxn GlobalNumByteSlice)
                let submit_result_0%39%%LocalNumUint#0: uint64 = (itxn LocalNumUint)
                let submit_result_0%39%%LocalNumByteSlice#0: uint64 = (itxn LocalNumByteSlice)
                let submit_result_0%39%%ExtraProgramPages#0: uint64 = (itxn ExtraProgramPages)
                let submit_result_0%39%%Nonparticipation#0: uint64 = (itxn Nonparticipation)
                let submit_result_0%39%%NumLogs#0: uint64 = (itxn NumLogs)
                let submit_result_0%39%%CreatedAssetID#0: uint64 = (itxn CreatedAssetID)
                let submit_result_0%39%%CreatedApplicationID#0: uint64 = (itxn CreatedApplicationID)
                let submit_result_0%39%%LastLog#0: bytes = (itxn LastLog)
                let submit_result_0%39%%StateProofPK#0: bytes = (itxn StateProofPK)
                let submit_result_0%39%%NumApprovalProgramPages#0: uint64 = (itxn NumApprovalProgramPages)
                let submit_result_0%39%%NumClearStateProgramPages#0: uint64 = (itxn NumClearStateProgramPages)
                (app_global_put "nft_asset_id" submit_result_0%39%%CreatedAssetID#0)
                return 
        
        subroutine puyapy.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
            block@0: // L11
                let required_budget_with_buffer#0: uint64 = (+ required_budget#0 10u)
                goto block@1
            block@1: // while_top_L19
                let tmp%0#0: uint64 = (global OpcodeBudget)
                let tmp%1#0: uint64 = (> required_budget_with_buffer#0 tmp%0#0)
                goto tmp%1#0 ? block@2 : block@7
            block@2: // while_body_L19
                itxn_begin
                ((itxn_field TypeEnum) appl)
                ((itxn_field OnCompletion) DeleteApplication)
                ((itxn_field ApprovalProgram) 0x068101)
                ((itxn_field ClearStateProgram) 0x068101)
                switch fee_source#0 {0u => block@3, 1u => block@4, * => block@5}
            block@3: // switch_case_0_L27
                ((itxn_field Fee) 0u)
                goto block@6
            block@4: // switch_case_1_L29
                let tmp%2#0: uint64 = (global MinTxnFee)
                ((itxn_field Fee) tmp%2#0)
                goto block@6
            block@5: // switch_case_default_L25
                goto block@6
            block@6: // switch_case_next_L25
                itxn_submit
                goto block@1
            block@7: // after_while_L19
                return 
        
        subroutine examples.voting.voting.itoa(i: uint64) -> bytes:
            block@0: // L253
                let digits#0: bytes = "0123456789"
                let radix#0: uint64 = (len digits#0)
                let tmp%0#0: uint64 = (< i#0 radix#0)
                goto tmp%0#0 ? block@1 : block@2
            block@1: // if_body_L257
                let index_plus_1%1#0: uint64 = (+ i#0 1u)
                let tmp%2#0: bytes = (substring3 digits#0 i#0 index_plus_1%1#0)
                return tmp%2#0
            block@2: // after_if_else_L257
                let tmp%3#0: uint64 = (/ i#0 radix#0)
                let tmp%4#0: bytes = examples.voting.voting.itoa(tmp%3#0)
                let tmp%5#0: uint64 = (% i#0 radix#0)
                let index_plus_1%6#0: uint64 = (+ tmp%5#0 1u)
                let tmp%7#0: bytes = (substring3 digits#0 tmp%5#0 index_plus_1%6#0)
                let tmp%8#0: bytes = (concat tmp%4#0 tmp%7#0)
                return tmp%8#0
        
        subroutine examples.voting.voting.get_vote_from_box(index: uint64) -> uint64:
            block@0: // L238
                let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: uint64) = (box_get "V")
                let box_data#0: bytes = tuple_assignment%0#0
                let exists#0: uint64 = tuple_assignment%1#0
                (assert exists#0) // Box not created
                let tmp%2#0: bytes = (extract3 box_data#0 index#0 8u)
                let tmp%3#0: uint64 = (btoi tmp%2#0)
                return tmp%3#0
        
        subroutine examples.voting.voting.VotingRoundApp.get_preconditions(signature: bytes) -> bytes:
            block@0: // L157
                let tmp%0#0: uint64 = examples.voting.voting.VotingRoundApp.voting_open()
                let val_as_bytes%1#0: bytes = (itob tmp%0#0)
                let awst_tmp%2#0: bytes = signature#0
                let tmp%3#0: uint64 = (len awst_tmp%2#0)
                let tmp%4#0: uint64 = (len awst_tmp%2#0)
                let tmp%5#0: uint64 = (< 2u tmp%4#0)
                let tmp%6#0: uint64 = (select tmp%3#0 2u tmp%5#0)
                let base_length%7#0: uint64 = (len awst_tmp%2#0)
                let tmp%8#0: bytes = (substring3 awst_tmp%2#0 tmp%6#0 base_length%7#0)
                let tmp%9#0: uint64 = examples.voting.voting.VotingRoundApp.allowed_to_vote(tmp%8#0)
                let val_as_bytes%10#0: bytes = (itob tmp%9#0)
                let tmp%11#0: uint64 = examples.voting.voting.VotingRoundApp.already_voted()
                let val_as_bytes%12#0: bytes = (itob tmp%11#0)
                let tmp%13#0: uint64 = (global LatestTimestamp)
                let val_as_bytes%14#0: bytes = (itob tmp%13#0)
                let current_tail_offset%15#0: uint64 = 32u
                let encoded_tuple_buffer%16#0: bytes = 0x
                let encoded_tuple_buffer%16#1: bytes = (concat encoded_tuple_buffer%16#0 val_as_bytes%1#0)
                let encoded_tuple_buffer%16#2: bytes = (concat encoded_tuple_buffer%16#1 val_as_bytes%10#0)
                let encoded_tuple_buffer%16#3: bytes = (concat encoded_tuple_buffer%16#2 val_as_bytes%12#0)
                let encoded_tuple_buffer%16#4: bytes = (concat encoded_tuple_buffer%16#3 val_as_bytes%14#0)
                return encoded_tuple_buffer%16#4
        
        subroutine examples.voting.voting.VotingRoundApp.voting_open() -> uint64:
            block@0: // L202
                let (is_bootstrapped_value%0#0: uint64, is_bootstrapped_exists%1#0: uint64) = (app_global_get_ex 0u "is_bootstrapped")
                (assert is_bootstrapped_exists%1#0) // check is_bootstrapped exists
                goto is_bootstrapped_value%0#0 ? block@1 : block@5
            block@1: // and_contd_L205
                let (close_time_exists%2#0: any, close_time_exists%3#0: uint64) = (app_global_get_ex 0u "close_time")
                goto close_time_exists%3#0 ? block@5 : block@2
            block@2: // and_contd_L205
                let (start_time_value%4#0: uint64, start_time_exists%5#0: uint64) = (app_global_get_ex 0u "start_time")
                (assert start_time_exists%5#0) // check start_time exists
                let awst_tmp%6#0: uint64 = (global LatestTimestamp)
                let tmp%7#0: uint64 = (<= start_time_value%4#0 awst_tmp%6#0)
                goto tmp%7#0 ? block@3 : block@5
            block@3: // and_contd_L207
                let (end_time_value%8#0: uint64, end_time_exists%9#0: uint64) = (app_global_get_ex 0u "end_time")
                (assert end_time_exists%9#0) // check end_time exists
                let tmp%10#0: uint64 = (<= awst_tmp%6#0 end_time_value%8#0)
                goto tmp%10#0 ? block@4 : block@5
            block@4: // bool_true_L205
                let and_result%11#0: uint64 = 1u
                goto block@6
            block@5: // bool_false_L205
                let and_result%11#1: uint64 = 0u
                goto block@6
            block@6: // bool_merge_L205
                let and_result%11#2: uint64 = φ(and_result%11#0 <- block@4, and_result%11#1 <- block@5)
                return and_result%11#2
        
        subroutine examples.voting.voting.VotingRoundApp.allowed_to_vote(signature: bytes) -> uint64:
            block@0: // L228
                puyapy.ensure_budget(2000u, 2u)
                let tmp%0#0: bytes = (txn Sender)
                let (snapshot_public_key_value%1#0: bytes, snapshot_public_key_exists%2#0: uint64) = (app_global_get_ex 0u "snapshot_public_key")
                (assert snapshot_public_key_exists%2#0) // check snapshot_public_key exists
                let tmp%3#0: uint64 = (ed25519verify_bare tmp%0#0 signature#0 snapshot_public_key_value%1#0)
                return tmp%3#0
        
        subroutine examples.voting.voting.VotingRoundApp.already_voted() -> uint64:
            block@0: // L210
                let tmp%0#0: bytes = (txn Sender)
                let (tuple_assignment%1#0: bytes, tuple_assignment%2#0: uint64) = (box_get tmp%0#0)
                let votes#0: bytes = tuple_assignment%1#0
                let exists#0: uint64 = tuple_assignment%2#0
                return exists#0
        
        subroutine examples.voting.voting.VotingRoundApp.vote(fund_min_bal_req: uint64, signature: bytes, answer_ids: bytes) -> void:
            block@0: // L166
                puyapy.ensure_budget(7700u, 0u)
                let tmp%0#0: uint64 = examples.voting.voting.VotingRoundApp.allowed_to_vote(signature#0)
                (assert tmp%0#0) // Not allowed to vote
                let tmp%1#0: uint64 = examples.voting.voting.VotingRoundApp.voting_open()
                (assert tmp%1#0) // Voting not open
                let tmp%2#0: uint64 = examples.voting.voting.VotingRoundApp.already_voted()
                let tmp%3#0: uint64 = (! tmp%2#0)
                (assert tmp%3#0) // Already voted
                let (option_counts_value%4#0: bytes, option_counts_exists%5#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert option_counts_exists%5#0) // check option_counts exists
                let questions_count#0: uint64 = (extract_uint16 option_counts_value%4#0 0u)
                let tmp%6#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let tmp%7#0: uint64 = (== tmp%6#0 questions_count#0)
                (assert tmp%7#0) // Number of answers incorrect
                let tmp%8#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let tmp%9#0: uint64 = (* 1u tmp%8#0)
                let tmp%10#0: uint64 = (+ 34u tmp%9#0)
                let tmp%11#0: uint64 = (* tmp%10#0 400u)
                let min_bal_req#0: uint64 = (+ 2500u tmp%11#0)
                let tmp%12#0: bytes = ((gtxns Receiver) fund_min_bal_req#0)
                let tmp%13#0: bytes = (global CurrentApplicationAddress)
                let tmp%14#0: uint64 = (== tmp%12#0 tmp%13#0)
                (assert tmp%14#0) // Payment must be to app address
                let tmp%15#0: bytes = (itob min_bal_req#0)
                (log tmp%15#0)
                let tmp%16#0: uint64 = ((gtxns Amount) fund_min_bal_req#0)
                let tmp%17#0: uint64 = (== tmp%16#0 min_bal_req#0)
                (assert tmp%17#0) // Payment must be the exact min balance
                let cumulative_offset#0: uint64 = 0u
                (assert 1u) // Step cannot be zero
                let range_item%18#0: uint64 = 0u
                goto block@1
            block@1: // for_header_L192
                let range_item%18#1: uint64 = φ(range_item%18#0 <- block@0, range_item%18#3 <- block@4)
                let cumulative_offset#3: uint64 = φ(cumulative_offset#0 <- block@0, cumulative_offset#2 <- block@4)
                let continue_looping%19#0: uint64 = (< range_item%18#1 questions_count#0)
                goto continue_looping%19#0 ? block@2 : block@5
            block@2: // for_body_L192
                let question_index#0: uint64 = range_item%18#1
                let array_length%20#0: uint64 = (extract_uint16 answer_ids#0 0u)
                let index_is_in_bounds%21#0: uint64 = (< question_index#0 array_length%20#0)
                (assert index_is_in_bounds%21#0) // Index access is out of bounds
                let array_data_sans_header%22#0: bytes = ((extract 2 0) answer_ids#0)
                let item_index%23#0: uint64 = (* question_index#0 1u)
                let tmp%24#0: bytes = (extract3 array_data_sans_header%22#0 item_index%23#0 1u)
                let answer_option_index#0: uint64 = (btoi tmp%24#0)
                let (option_counts_value%25#0: bytes, option_counts_exists%26#0: uint64) = (app_global_get_ex 0u "option_counts")
                (assert option_counts_exists%26#0) // check option_counts exists
                let array_length%27#0: uint64 = (extract_uint16 option_counts_value%25#0 0u)
                let index_is_in_bounds%28#0: uint64 = (< question_index#0 array_length%27#0)
                (assert index_is_in_bounds%28#0) // Index access is out of bounds
                let array_data_sans_header%29#0: bytes = ((extract 2 0) option_counts_value%25#0)
                let item_index%30#0: uint64 = (* question_index#0 1u)
                let tmp%31#0: bytes = (extract3 array_data_sans_header%29#0 item_index%30#0 1u)
                let options_count#0: uint64 = (btoi tmp%31#0)
                let tmp%32#0: uint64 = (< answer_option_index#0 options_count#0)
                (assert tmp%32#0) // Answer option index invalid
                let tmp%33#0: uint64 = (+ cumulative_offset#3 answer_option_index#0)
                examples.voting.voting.increment_vote_in_box(tmp%33#0)
                let cumulative_offset#2: uint64 = (+ cumulative_offset#3 options_count#0)
                let tmp%34#0: bytes = (txn Sender)
                (box_put tmp%34#0 answer_ids#0)
                let (voter_count_value%35#0: uint64, voter_count_exists%36#0: uint64) = (app_global_get_ex 0u "voter_count")
                (assert voter_count_exists%36#0) // check voter_count exists
                let new_state_value%37#0: uint64 = (+ voter_count_value%35#0 1u)
                (app_global_put "voter_count" new_state_value%37#0)
                goto block@3
            block@3: // for_footer_L192
                goto block@4
            block@4: // for_increment_L192
                let range_item%18#3: uint64 = (+ range_item%18#1 1u)
                goto block@1
            block@5: // after_for_L192
                return 
        
        subroutine examples.voting.voting.increment_vote_in_box(index: uint64) -> void:
            block@0: // L245
                let (tuple_assignment%0#0: bytes, tuple_assignment%1#0: uint64) = (box_get "V")
                let box_data#0: bytes = tuple_assignment%0#0
                let exists#0: uint64 = tuple_assignment%1#0
                (assert exists#0) // Box not created
                let tmp%2#0: bytes = (extract3 box_data#0 index#0 8u)
                let current_vote#0: uint64 = (btoi tmp%2#0)
                let tmp%3#0: uint64 = (+ current_vote#0 1u)
                let tmp%4#0: bytes = (itob tmp%3#0)
                (box_replace "V" index#0 tmp%4#0)
                return 
        
        subroutine examples.voting.voting.VotingRoundApp.__init__() -> void:
            block@0: // L49
                (app_global_put "is_bootstrapped" 0u)
                (app_global_put "voter_count" 0u)
                return 
    
    program clear-state:
        subroutine examples.voting.voting.VotingRoundApp.clear_state_program() -> uint64:
            block@0: // L48
                return 1u