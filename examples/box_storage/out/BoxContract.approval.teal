#pragma version 10
#pragma typetrack false

// examples.box_storage.contract.BoxContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 2 0 8 4096
    bytecblock "dynamic_arr_struct" 0x424f585f43 0x626c6f62 "dynamic_box" "box_d" 0x151f7c75 "b" "box_large" "box_a" "many_ints" "0" 0x00023432 0x68656c6c6f 0x0014 0x068101 "box_ref" "default"
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@32
    pushbytess 0x7d37296e 0x33325d3d 0x0199408d 0x772059ca 0x01263df6 0xd566c632 0xfabcb885 0xa6174812 0xf13dd937 0x5ab60f2e 0xf07a0064 0x78f9af3f 0x5cbb9dcc 0x0d22b441 0x41427cd1 0x2a141f6c 0x7e843744 0x25600b57 0x29ea595d 0x04ef4971 0x23ecb32c 0xeef75816 0xb532913a 0xc29f1669 0x9c888c09 0xe6f68506 0x8ee2c364 // method "set_boxes(uint64,byte[],string)void", method "check_keys()void", method "create_many_ints()void", method "set_many_ints(uint64,uint64)void", method "sum_many_ints()uint64", method "delete_boxes()void", method "indirect_extract_and_replace()void", method "read_boxes()(uint64,byte[],string,uint64)", method "boxes_exist()(bool,bool,bool,bool)", method "create_dynamic_arr_struct()void", method "delete_dynamic_arr_struct()void", method "append_dynamic_arr_struct(uint64)uint64", method "pop_dynamic_arr_struct(uint64)uint64", method "sum_dynamic_arr_struct()uint64", method "create_dynamic_box()void", method "delete_dynamic_box()void", method "append_dynamic_box(uint64)uint64", method "pop_dynamic_box(uint64)uint64", method "sum_dynamic_box()uint64", method "slice_box()void", method "arc4_box()void", method "test_box_ref()void", method "box_map_test()void", method "box_map_set(uint64,string)void", method "box_map_get(uint64)string", method "box_map_del(uint64)void", method "box_map_exists(uint64)bool"
    txna ApplicationArgs 0
    match main_set_boxes_route@5 main_check_keys_route@6 main_create_many_ints_route@7 main_set_many_ints_route@8 main_sum_many_ints_route@9 main_delete_boxes_route@10 main_indirect_extract_and_replace_route@11 main_read_boxes_route@12 main_boxes_exist_route@13 main_create_dynamic_arr_struct_route@14 main_delete_dynamic_arr_struct_route@15 main_append_dynamic_arr_struct_route@16 main_pop_dynamic_arr_struct_route@17 main_sum_dynamic_arr_struct_route@18 main_create_dynamic_box_route@19 main_delete_dynamic_box_route@20 main_append_dynamic_box_route@21 main_pop_dynamic_box_route@22 main_sum_dynamic_box_route@23 main_slice_box_route@24 main_arc4_box_route@25 main_test_box_ref_route@26 main_box_map_test_route@27 main_box_map_set_route@28 main_box_map_get_route@29 main_box_map_del_route@30 main_box_map_exists_route@31

main_after_if_else@34:
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    intc_2 // 0
    return

main_box_map_exists_route@31:
    // box_storage/contract.py:384
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:384
    // @arc4.abimethod
    callsub box_map_exists
    pushbytes 0x00
    intc_2 // 0
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_del_route@30:
    // box_storage/contract.py:380
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:380
    // @arc4.abimethod
    callsub box_map_del
    intc_0 // 1
    return

main_box_map_get_route@29:
    // box_storage/contract.py:376
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:376
    // @arc4.abimethod
    callsub box_map_get
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_set_route@28:
    // box_storage/contract.py:372
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // box_storage/contract.py:372
    // @arc4.abimethod
    callsub box_map_set
    intc_0 // 1
    return

main_box_map_test_route@27:
    // box_storage/contract.py:348
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub box_map_test
    intc_0 // 1
    return

main_test_box_ref_route@26:
    // box_storage/contract.py:300
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub test_box_ref
    intc_0 // 1
    return

main_arc4_box_route@25:
    // box_storage/contract.py:290
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc4_box
    intc_0 // 1
    return

main_slice_box_route@24:
    // box_storage/contract.py:281
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub slice_box
    intc_0 // 1
    return

main_sum_dynamic_box_route@23:
    // box_storage/contract.py:274
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub sum_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_pop_dynamic_box_route@22:
    // box_storage/contract.py:263
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:263
    // @arc4.abimethod
    callsub pop_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_append_dynamic_box_route@21:
    // box_storage/contract.py:248
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:248
    // @arc4.abimethod
    callsub append_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_dynamic_box_route@20:
    // box_storage/contract.py:244
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_dynamic_box
    intc_0 // 1
    return

main_create_dynamic_box_route@19:
    // box_storage/contract.py:240
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub create_dynamic_box
    intc_0 // 1
    return

main_sum_dynamic_arr_struct_route@18:
    // box_storage/contract.py:229
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub sum_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_pop_dynamic_arr_struct_route@17:
    // box_storage/contract.py:208
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:208
    // @arc4.abimethod
    callsub pop_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_append_dynamic_arr_struct_route@16:
    // box_storage/contract.py:180
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:180
    // @arc4.abimethod
    callsub append_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_dynamic_arr_struct_route@15:
    // box_storage/contract.py:176
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_dynamic_arr_struct
    intc_0 // 1
    return

main_create_dynamic_arr_struct_route@14:
    // box_storage/contract.py:167
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub create_dynamic_arr_struct
    intc_0 // 1
    return

main_boxes_exist_route@13:
    // box_storage/contract.py:163
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub boxes_exist
    pushbytes 0x00
    intc_2 // 0
    uncover 5
    setbit
    intc_0 // 1
    uncover 4
    setbit
    intc_1 // 2
    uncover 3
    setbit
    pushint 3 // 3
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_boxes_route@12:
    // box_storage/contract.py:154
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub read_boxes
    uncover 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 13 // 0x0014
    concat
    dig 1
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    itob
    concat
    swap
    concat
    swap
    concat
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_indirect_extract_and_replace_route@11:
    // box_storage/contract.py:148
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub indirect_extract_and_replace
    intc_0 // 1
    return

main_delete_boxes_route@10:
    // box_storage/contract.py:135
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_boxes
    intc_0 // 1
    return

main_sum_many_ints_route@9:
    // box_storage/contract.py:127
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub sum_many_ints
    itob
    bytec 5 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_set_many_ints_route@8:
    // box_storage/contract.py:123
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // box_storage/contract.py:123
    // @arc4.abimethod()
    callsub set_many_ints
    intc_0 // 1
    return

main_create_many_ints_route@7:
    // box_storage/contract.py:119
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub create_many_ints
    intc_0 // 1
    return

main_check_keys_route@6:
    // box_storage/contract.py:112
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_set_boxes_route@5:
    // box_storage/contract.py:76
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // box_storage/contract.py:76
    // @arc4.abimethod
    callsub set_boxes
    intc_0 // 1
    return

main_bare_routing@32:
    // box_storage/contract.py:62
    // class BoxContract(arc4.ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@34
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// examples.box_storage.contract.BoxContract.set_boxes(a: uint64, b: bytes, c: bytes) -> void:
set_boxes:
    // box_storage/contract.py:76-77
    // @arc4.abimethod
    // def set_boxes(self, a: UInt64, b: arc4.DynamicBytes, c: arc4.String) -> None:
    proto 3 0
    // box_storage/contract.py:78
    // self.box_a.value = a
    frame_dig -3
    itob
    bytec 8 // "box_a"
    swap
    box_put
    // box_storage/contract.py:79
    // self.box_b.value = b.copy()
    bytec 6 // "b"
    box_del
    pop
    bytec 6 // "b"
    frame_dig -2
    box_put
    // box_storage/contract.py:80
    // self.box_c.value = c
    bytec_1 // 0x424f585f43
    box_del
    pop
    bytec_1 // 0x424f585f43
    frame_dig -1
    box_put
    // box_storage/contract.py:81
    // self.box_d.value = b.native
    frame_dig -2
    extract 2 0
    bytec 4 // "box_d"
    box_del
    pop
    bytec 4 // "box_d"
    dig 1
    box_put
    // box_storage/contract.py:82
    // self.box_large.create()
    bytec 7 // "box_large"
    pushint 6160 // 6160
    box_create
    pop
    // box_storage/contract.py:83
    // self.box_large.value.e = UInt64(42)
    pushint 42 // 42
    itob
    bytec 7 // "box_large"
    intc 4 // 4096
    uncover 2
    box_replace
    // box_storage/contract.py:84
    // self.box_large.ref.replace(size_of(Bytes1024) * 4, arc4.UInt64(42).bytes)
    bytec 7 // "box_large"
    intc 4 // 4096
    pushbytes 0x000000000000002a
    box_replace
    // box_storage/contract.py:87
    // assert self.box_b.value.length == b_value.length, "direct reference should match copy"
    bytec 6 // "b"
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    // box_storage/contract.py:86
    // b_value = self.box_b.value.copy()
    bytec 6 // "b"
    // box_storage/contract.py:86-87
    // b_value = self.box_b.value.copy()
    // assert self.box_b.value.length == b_value.length, "direct reference should match copy"
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    // box_storage/contract.py:87
    // assert self.box_b.value.length == b_value.length, "direct reference should match copy"
    ==
    assert // direct reference should match copy
    // box_storage/contract.py:89
    // self.box_a.value += 3
    bytec 8 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3 // 3
    +
    itob
    bytec 8 // "box_a"
    swap
    box_put
    // box_storage/contract.py:91-92
    // # test .length
    // assert self.box_a.length == 8
    bytec 8 // "box_a"
    box_len
    pop
    intc_3 // 8
    ==
    assert
    // box_storage/contract.py:93
    // assert self.box_b.length == b.bytes.length
    bytec 6 // "b"
    box_len
    pop
    frame_dig -2
    len
    ==
    assert
    // box_storage/contract.py:94
    // assert self.box_c.length == c.bytes.length
    bytec_1 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    frame_dig -1
    len
    swap
    dig 1
    ==
    assert
    // box_storage/contract.py:95
    // assert self.box_d.length == b.native.length
    bytec 4 // "box_d"
    box_len
    pop
    dig 2
    len
    swap
    dig 1
    ==
    assert
    // box_storage/contract.py:97-98
    // # test .value.bytes
    // assert self.box_c.value.bytes[0] == c.bytes[0]
    bytec_1 // 0x424f585f43
    intc_2 // 0
    intc_0 // 1
    box_extract
    frame_dig -1
    extract 0 1
    ==
    assert
    // box_storage/contract.py:99
    // assert self.box_c.value.bytes[-1] == c.bytes[-1]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_0 // 1
    -
    bytec_1 // 0x424f585f43
    swap
    intc_0 // 1
    box_extract
    dig 2
    intc_0 // 1
    -
    frame_dig -1
    swap
    intc_0 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:100
    // assert self.box_c.value.bytes[:-1] == c.bytes[:-1]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_0 // 1
    dig 1
    <
    dig 1
    intc_0 // 1
    uncover 2
    select
    -
    bytec_1 // 0x424f585f43
    intc_2 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 3
    >=
    intc_0 // 1
    dig 4
    uncover 2
    select
    dig 3
    swap
    -
    frame_dig -1
    intc_2 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:101
    // assert self.box_c.value.bytes[:2] == c.bytes[:2]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_1 // 2
    dig 1
    <
    intc_1 // 2
    swap
    select
    bytec_1 // 0x424f585f43
    intc_2 // 0
    uncover 2
    box_extract
    intc_1 // 2
    dig 3
    >=
    intc_1 // 2
    uncover 4
    uncover 2
    select
    frame_dig -1
    intc_2 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:103-104
    // # test .value with Bytes type
    // assert self.box_d.value[0] == b.native[0]
    bytec 4 // "box_d"
    intc_2 // 0
    intc_0 // 1
    box_extract
    frame_dig -2
    extract 2 1
    ==
    assert
    // box_storage/contract.py:105
    // assert self.box_d.value[-1] == b.native[-1]
    bytec 4 // "box_d"
    box_len
    pop
    intc_0 // 1
    -
    bytec 4 // "box_d"
    swap
    intc_0 // 1
    box_extract
    dig 1
    intc_0 // 1
    -
    dig 3
    swap
    intc_0 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:106
    // assert self.box_d.value[:-1] == b.native[:-1]
    bytec 4 // "box_d"
    box_len
    pop
    intc_0 // 1
    dig 1
    <
    dig 1
    intc_0 // 1
    uncover 2
    select
    -
    bytec 4 // "box_d"
    intc_2 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 2
    >=
    intc_0 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    dig 3
    intc_2 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:107
    // assert self.box_d.value[:5] == b.native[:5]
    bytec 4 // "box_d"
    box_len
    pop
    pushint 5 // 5
    dig 1
    <
    pushint 5 // 5
    swap
    select
    bytec 4 // "box_d"
    intc_2 // 0
    uncover 2
    box_extract
    pushint 5 // 5
    dig 2
    >=
    pushint 5 // 5
    dig 3
    uncover 2
    select
    dig 3
    intc_2 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:108
    // assert self.box_d.value[: UInt64(2)] == b.native[: UInt64(2)]
    bytec 4 // "box_d"
    box_len
    pop
    intc_1 // 2
    dig 1
    <
    intc_1 // 2
    swap
    select
    bytec 4 // "box_d"
    intc_2 // 0
    uncover 2
    box_extract
    intc_1 // 2
    dig 2
    >=
    intc_1 // 2
    uncover 3
    uncover 2
    select
    uncover 2
    intc_2 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:110
    // assert self.box_large.length == size_of(LargeStruct)
    bytec 7 // "box_large"
    box_len
    pop
    pushint 6160 // 6160
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.create_many_ints() -> void:
create_many_ints:
    // box_storage/contract.py:121
    // self.many_ints.create()
    bytec 9 // "many_ints"
    pushint 4104 // 4104
    box_create
    pop
    retsub


// examples.box_storage.contract.BoxContract.set_many_ints(index: uint64, value: uint64) -> void:
set_many_ints:
    // box_storage/contract.py:123-124
    // @arc4.abimethod()
    // def set_many_ints(self, index: UInt64, value: UInt64) -> None:
    proto 2 0
    // box_storage/contract.py:125
    // self.many_ints.value[index] = value
    frame_dig -1
    itob
    frame_dig -2
    intc_3 // 8
    *
    bytec 9 // "many_ints"
    swap
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.sum_many_ints() -> uint64:
sum_many_ints:
    // box_storage/contract.py:127-128
    // @arc4.abimethod()
    // def sum_many_ints(self) -> UInt64:
    proto 0 1
    pushbytes ""
    dup

sum_many_ints_while_top@6:
    pushint 10510 // 10510
    global OpcodeBudget
    >
    bz sum_many_ints_after_while@11
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 14 // 0x068101
    itxn_field ApprovalProgram
    bytec 14 // 0x068101
    itxn_field ClearStateProgram
    intc_2 // 0
    itxn_field Fee
    itxn_submit
    b sum_many_ints_while_top@6

sum_many_ints_after_while@11:
    // box_storage/contract.py:130
    // total = UInt64(0)
    intc_2 // 0
    frame_bury 1
    // box_storage/contract.py:131
    // for val in self.many_ints.value:
    bytec 9 // "many_ints"
    box_len
    bury 1
    assert // check self.many_ints exists
    intc_2 // 0
    frame_bury 0

sum_many_ints_for_header@1:
    // box_storage/contract.py:131
    // for val in self.many_ints.value:
    frame_dig 0
    pushint 513 // 513
    <
    bz sum_many_ints_after_for@4
    frame_dig 0
    dup
    intc_3 // 8
    *
    bytec 9 // "many_ints"
    swap
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:132
    // total = total + val
    frame_dig 1
    +
    frame_bury 1
    intc_0 // 1
    +
    frame_bury 0
    b sum_many_ints_for_header@1

sum_many_ints_after_for@4:
    // box_storage/contract.py:133
    // return total
    frame_dig 1
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.delete_boxes() -> void:
delete_boxes:
    // box_storage/contract.py:137
    // del self.box_a.value
    bytec 8 // "box_a"
    box_del
    pop
    // box_storage/contract.py:138
    // del self.box_b.value
    bytec 6 // "b"
    box_del
    pop
    // box_storage/contract.py:139
    // del self.box_c.value
    bytec_1 // 0x424f585f43
    box_del
    pop
    // box_storage/contract.py:140
    // assert self.box_a.get(default=UInt64(42)) == 42
    bytec 8 // "box_a"
    box_get
    swap
    btoi
    pushint 42 // 42
    dig 1
    dig 3
    select
    pushint 42 // 42
    ==
    assert
    // box_storage/contract.py:141
    // assert self.box_b.get(default=arc4.DynamicBytes(b"42")).native == b"42"
    bytec 6 // "b"
    box_get
    bytec 11 // 0x00023432
    cover 2
    select
    extract 2 0
    pushbytes 0x3432
    ==
    assert
    // box_storage/contract.py:142
    // assert self.box_c.get(default=arc4.String("42")) == "42"
    bytec_1 // 0x424f585f43
    box_get
    bytec 11 // 0x00023432
    cover 2
    select
    bytec 11 // 0x00023432
    ==
    assert
    // box_storage/contract.py:144
    // assert not a_exists
    swap
    !
    assert
    // box_storage/contract.py:145
    // assert a == 0
    !
    assert
    // box_storage/contract.py:146
    // del self.box_large.value
    bytec 7 // "box_large"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.indirect_extract_and_replace() -> void:
indirect_extract_and_replace:
    // box_storage/contract.py:150
    // large = self.box_large.value.copy()
    bytec 7 // "box_large"
    // box_storage/contract.py:150-151
    // large = self.box_large.value.copy()
    // large.e += 1
    intc 4 // 4096
    intc_3 // 8
    box_extract
    // box_storage/contract.py:151
    // large.e += 1
    btoi
    intc_0 // 1
    +
    itob
    // box_storage/contract.py:152
    // self.box_large.value = large.copy()
    bytec 7 // "box_large"
    // box_storage/contract.py:151-152
    // large.e += 1
    // self.box_large.value = large.copy()
    intc 4 // 4096
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.read_boxes() -> uint64, bytes, bytes, uint64:
read_boxes:
    // box_storage/contract.py:157
    // get_box_value_plus_1(self.box_a) - 1,
    bytec 8 // "box_a"
    // box_storage/contract.py:391
    // return box.value + 1
    box_get
    assert // check Box exists
    btoi
    intc_0 // 1
    +
    // box_storage/contract.py:157
    // get_box_value_plus_1(self.box_a) - 1,
    intc_0 // 1
    -
    // box_storage/contract.py:158
    // self.box_b.value.native,
    bytec 6 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    // box_storage/contract.py:159
    // self.box_c.value,
    bytec_1 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    // box_storage/contract.py:160
    // self.box_large.value.e,
    bytec 7 // "box_large"
    intc 4 // 4096
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:156-161
    // return (
    //     get_box_value_plus_1(self.box_a) - 1,
    //     self.box_b.value.native,
    //     self.box_c.value,
    //     self.box_large.value.e,
    // )
    retsub


// examples.box_storage.contract.BoxContract.boxes_exist() -> uint64, uint64, uint64, uint64:
boxes_exist:
    // box_storage/contract.py:165
    // return bool(self.box_a), bool(self.box_b), bool(self.box_c), bool(self.box_large)
    bytec 8 // "box_a"
    box_len
    bury 1
    bytec 6 // "b"
    box_len
    bury 1
    bytec_1 // 0x424f585f43
    box_len
    bury 1
    bytec 7 // "box_large"
    box_len
    bury 1
    retsub


// examples.box_storage.contract.BoxContract.create_dynamic_arr_struct() -> void:
create_dynamic_arr_struct:
    // box_storage/contract.py:170
    // a=Txn.num_app_args,
    txn NumAppArgs
    // box_storage/contract.py:172
    // b=Txn.num_app_args * 2,
    dup
    intc_1 // 2
    *
    // box_storage/contract.py:169-174
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    swap
    itob
    bytec 13 // 0x0014
    concat
    swap
    itob
    concat
    pushbytes 0x001600000000
    concat
    // box_storage/contract.py:169
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:169-174
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    box_del
    pop
    // box_storage/contract.py:169
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:169-174
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    swap
    box_put
    retsub


// examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct() -> void:
delete_dynamic_arr_struct:
    // box_storage/contract.py:178
    // del self.dynamic_arr_struct.value
    bytec_0 // "dynamic_arr_struct"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.append_dynamic_arr_struct(times: uint64) -> uint64:
append_dynamic_arr_struct:
    // box_storage/contract.py:180-181
    // @arc4.abimethod
    // def append_dynamic_arr_struct(self, times: UInt64) -> UInt64:
    proto 1 1
    // box_storage/contract.py:182-183
    // # TODO: support append using high level array operations
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    bytec_0 // "dynamic_arr_struct"
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    intc_1 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:184
    // arr_len = self.dynamic_arr_struct.value.arr.length
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    dup
    // box_storage/contract.py:185
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    bytec_0 // "dynamic_arr_struct"
    pushint 18 // 18
    intc_1 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_1 // 2
    box_extract
    btoi
    // box_storage/contract.py:189
    // get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    dig 1
    frame_dig -1
    +
    // box_storage/contract.py:407
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    intc_3 // 8
    *
    // box_storage/contract.py:407-408
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22 // 22
    +
    // box_storage/contract.py:414
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    swap
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:415
    // return head_and_dyn_arr + dyn_arr2_index
    +
    // box_storage/contract.py:187-188
    // # expand box
    // self.dynamic_arr_struct.ref.resize(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:187-190
    // # expand box
    // self.dynamic_arr_struct.ref.resize(
    //     get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    // )
    swap
    box_resize
    // box_storage/contract.py:407
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    intc_3 // 8
    *
    // box_storage/contract.py:407-408
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22 // 22
    +
    // box_storage/contract.py:193
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    frame_dig -1
    intc_3 // 8
    *
    bzero
    // box_storage/contract.py:191-192
    // # splice in new data
    // self.dynamic_arr_struct.ref.splice(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:191-194
    // # splice in new data
    // self.dynamic_arr_struct.ref.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    uncover 2
    // box_storage/contract.py:193
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    intc_2 // 0
    // box_storage/contract.py:191-194
    // # splice in new data
    // self.dynamic_arr_struct.ref.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    uncover 3
    box_splice
    // box_storage/contract.py:196
    // for i in urange(times):
    intc_2 // 0

append_dynamic_arr_struct_for_header@1:
    // box_storage/contract.py:196
    // for i in urange(times):
    frame_dig 1
    frame_dig -1
    <
    bz append_dynamic_arr_struct_after_for@4
    // box_storage/contract.py:197
    // box.value.arr.arr[arr_len] = i
    frame_dig 1
    dup
    itob
    frame_dig 0
    dup
    cover 2
    intc_3 // 8
    *
    pushint 22 // 22
    +
    // box_storage/contract.py:195
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:197
    // box.value.arr.arr[arr_len] = i
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:198
    // arr_len += 1
    intc_0 // 1
    +
    frame_bury 0
    // box_storage/contract.py:196
    // for i in urange(times):
    intc_0 // 1
    +
    frame_bury 1
    b append_dynamic_arr_struct_for_header@1

append_dynamic_arr_struct_after_for@4:
    // box_storage/contract.py:407
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 0
    dup
    intc_3 // 8
    *
    // box_storage/contract.py:415
    // return head_and_dyn_arr + dyn_arr2_index
    pushint 24 // 24
    +
    // box_storage/contract.py:199
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_1 // 2
    -
    // box_storage/contract.py:200
    // box.value.arr.length = arc4.UInt16(arr_len)
    dig 1
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:195
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:200
    // box.value.arr.length = arc4.UInt16(arr_len)
    pushint 20 // 20
    uncover 2
    box_replace
    // box_storage/contract.py:201
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:195
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:201
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    pushint 18 // 18
    uncover 2
    box_replace
    // box_storage/contract.py:203
    // self.dynamic_arr_struct.value.arr.length == arr_len
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    ==
    // box_storage/contract.py:202-204
    // assert (
    //     self.dynamic_arr_struct.value.arr.length == arr_len
    // ), "expected arr length to be correct"
    assert // expected arr length to be correct
    // box_storage/contract.py:205
    // assert self.dynamic_arr_struct.value.arr2.length == 0, "expected arr2 length to be correct"
    bytec_0 // "dynamic_arr_struct"
    pushint 18 // 18
    intc_1 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_1 // 2
    box_extract
    btoi
    !
    assert // expected arr2 length to be correct
    // box_storage/contract.py:206
    // return self.dynamic_arr_struct.value.arr.length
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct(times: uint64) -> uint64:
pop_dynamic_arr_struct:
    // box_storage/contract.py:208-209
    // @arc4.abimethod
    // def pop_dynamic_arr_struct(self, times: UInt64) -> UInt64:
    proto 1 1
    // box_storage/contract.py:212
    // arr_len = self.dynamic_arr_struct.value.arr.length - times
    bytec_0 // "dynamic_arr_struct"
    box_len
    bury 1
    assert // check self.dynamic_arr_struct exists
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    frame_dig -1
    -
    // box_storage/contract.py:213
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    bytec_0 // "dynamic_arr_struct"
    pushint 18 // 18
    intc_1 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_1 // 2
    box_extract
    btoi
    // box_storage/contract.py:407
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    dig 1
    intc_3 // 8
    *
    // box_storage/contract.py:408
    // return head + dyn_arr_index
    dup
    // box_storage/contract.py:407-408
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22 // 22
    +
    // box_storage/contract.py:415
    // return head_and_dyn_arr + dyn_arr2_index
    swap
    pushint 24 // 24
    +
    // box_storage/contract.py:216
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_1 // 2
    -
    // box_storage/contract.py:217
    // box.value.arr.length = arc4.UInt16(arr_len)
    uncover 3
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:214-215
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:217
    // box.value.arr.length = arc4.UInt16(arr_len)
    pushint 20 // 20
    uncover 2
    box_replace
    // box_storage/contract.py:218
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:214-215
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:218
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    pushint 18 // 18
    uncover 2
    box_replace
    // box_storage/contract.py:220
    // box.ref.splice(index, times * size_of(UInt64), b"")
    frame_dig -1
    intc_3 // 8
    *
    // box_storage/contract.py:214-215
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:220
    // box.ref.splice(index, times * size_of(UInt64), b"")
    dig 2
    uncover 2
    pushbytes 0x
    box_splice
    // box_storage/contract.py:414
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    swap
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:415
    // return head_and_dyn_arr + dyn_arr2_index
    +
    // box_storage/contract.py:225
    // self.dynamic_arr_struct.ref.resize(size)
    bytec_0 // "dynamic_arr_struct"
    swap
    box_resize
    // box_storage/contract.py:227
    // return self.dynamic_arr_struct.value.arr.length
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    retsub


// examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct() -> uint64:
sum_dynamic_arr_struct:
    // box_storage/contract.py:229-230
    // @arc4.abimethod
    // def sum_dynamic_arr_struct(self) -> UInt64:
    proto 0 1
    pushbytes ""
    dup
    // box_storage/contract.py:231
    // assert self.dynamic_arr_struct.value.a == 1, "expected 1"
    bytec_0 // "dynamic_arr_struct"
    intc_2 // 0
    intc_3 // 8
    box_extract
    btoi
    intc_0 // 1
    ==
    assert // expected 1
    // box_storage/contract.py:232
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    bytec_0 // "dynamic_arr_struct"
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    intc_1 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:233
    // total = self.dynamic_arr_struct.value.a + self.dynamic_arr_struct.value.b
    bytec_0 // "dynamic_arr_struct"
    intc_2 // 0
    intc_3 // 8
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    pushint 10 // 10
    intc_3 // 8
    box_extract
    btoi
    +
    // box_storage/contract.py:234
    // for val in self.dynamic_arr_struct.value.arr:
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    intc_2 // 0

sum_dynamic_arr_struct_for_header@1:
    // box_storage/contract.py:234
    // for val in self.dynamic_arr_struct.value.arr:
    frame_dig 4
    frame_dig 3
    <
    bz sum_dynamic_arr_struct_after_for@4
    bytec_0 // "dynamic_arr_struct"
    pushint 20 // 20
    intc_1 // 2
    box_extract
    btoi
    frame_dig 4
    dup
    uncover 2
    <
    assert // index out of bounds
    dup
    intc_3 // 8
    *
    pushint 22 // 22
    +
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:235
    // total += val
    frame_dig 2
    +
    frame_bury 2
    intc_0 // 1
    +
    frame_bury 4
    b sum_dynamic_arr_struct_for_header@1

sum_dynamic_arr_struct_after_for@4:
    // box_storage/contract.py:236
    // for val in self.dynamic_arr_struct.value.arr2:
    bytec_0 // "dynamic_arr_struct"
    box_len
    bury 1
    assert // check self.dynamic_arr_struct exists
    bytec_0 // "dynamic_arr_struct"
    pushint 18 // 18
    intc_1 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    intc_2 // 0
    frame_bury 1

sum_dynamic_arr_struct_for_header@5:
    // box_storage/contract.py:236
    // for val in self.dynamic_arr_struct.value.arr2:
    frame_dig 1
    frame_dig 0
    <
    bz sum_dynamic_arr_struct_after_for@8
    bytec_0 // "dynamic_arr_struct"
    pushint 18 // 18
    intc_1 // 2
    box_extract
    btoi
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    intc_1 // 2
    +
    +
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:237
    // total += val
    frame_dig 2
    +
    frame_bury 2
    intc_0 // 1
    +
    frame_bury 1
    b sum_dynamic_arr_struct_for_header@5

sum_dynamic_arr_struct_after_for@8:
    // box_storage/contract.py:238
    // return total
    frame_dig 2
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.create_dynamic_box() -> void:
create_dynamic_box:
    // box_storage/contract.py:242
    // self.dynamic_box.value = Array[UInt64]()
    bytec_3 // "dynamic_box"
    box_del
    pop
    bytec_3 // "dynamic_box"
    pushbytes 0x0000
    box_put
    retsub


// examples.box_storage.contract.BoxContract.delete_dynamic_box() -> void:
delete_dynamic_box:
    // box_storage/contract.py:246
    // del self.dynamic_box.value
    bytec_3 // "dynamic_box"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.append_dynamic_box(times: uint64) -> uint64:
append_dynamic_box:
    // box_storage/contract.py:248-249
    // @arc4.abimethod
    // def append_dynamic_box(self, times: UInt64) -> UInt64:
    proto 1 1
    // box_storage/contract.py:252
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_3 // "dynamic_box"
    // box_storage/contract.py:253
    // arr_len = box.value.length.native
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    dup
    // box_storage/contract.py:255
    // self.dynamic_box.ref.resize(2 + (arr_len + times) * 8)
    frame_dig -1
    +
    intc_3 // 8
    *
    intc_1 // 2
    +
    bytec_3 // "dynamic_box"
    swap
    box_resize
    // box_storage/contract.py:256
    // for i in urange(times):
    intc_2 // 0

append_dynamic_box_for_header@1:
    // box_storage/contract.py:256
    // for i in urange(times):
    frame_dig 1
    frame_dig -1
    <
    bz append_dynamic_box_after_for@4
    // box_storage/contract.py:257
    // box.value.arr[arr_len] = i
    frame_dig 1
    dup
    itob
    frame_dig 0
    dup
    cover 2
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:252
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_3 // "dynamic_box"
    // box_storage/contract.py:257
    // box.value.arr[arr_len] = i
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:258
    // arr_len += 1
    intc_0 // 1
    +
    frame_bury 0
    // box_storage/contract.py:256
    // for i in urange(times):
    intc_0 // 1
    +
    frame_bury 1
    b append_dynamic_box_for_header@1

append_dynamic_box_after_for@4:
    // box_storage/contract.py:260
    // box.value.length = arc4.UInt16(arr_len)
    frame_dig 0
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:252
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_3 // "dynamic_box"
    // box_storage/contract.py:260
    // box.value.length = arc4.UInt16(arr_len)
    intc_2 // 0
    uncover 2
    box_replace
    // box_storage/contract.py:261
    // return self.dynamic_box.value.length
    bytec_3 // "dynamic_box"
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.pop_dynamic_box(times: uint64) -> uint64:
pop_dynamic_box:
    // box_storage/contract.py:263-264
    // @arc4.abimethod
    // def pop_dynamic_box(self, times: UInt64) -> UInt64:
    proto 1 1
    // box_storage/contract.py:267
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_3 // "dynamic_box"
    // box_storage/contract.py:268
    // arr_len = box.value.length.native - times
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    frame_dig -1
    -
    // box_storage/contract.py:269
    // box.value.length = arc4.UInt16(arr_len)
    dup
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:267
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_3 // "dynamic_box"
    // box_storage/contract.py:269
    // box.value.length = arc4.UInt16(arr_len)
    intc_2 // 0
    uncover 2
    box_replace
    // box_storage/contract.py:270
    // self.dynamic_box.ref.resize(2 + arr_len * 8)
    intc_3 // 8
    *
    intc_1 // 2
    +
    bytec_3 // "dynamic_box"
    swap
    box_resize
    // box_storage/contract.py:272
    // return self.dynamic_box.value.length
    bytec_3 // "dynamic_box"
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    retsub


// examples.box_storage.contract.BoxContract.sum_dynamic_box() -> uint64:
sum_dynamic_box:
    // box_storage/contract.py:274-275
    // @arc4.abimethod
    // def sum_dynamic_box(self) -> UInt64:
    proto 0 1
    // box_storage/contract.py:276
    // total = UInt64()
    intc_2 // 0
    // box_storage/contract.py:277
    // for val in self.dynamic_box.value:
    bytec_3 // "dynamic_box"
    intc_2 // 0
    intc_1 // 2
    box_extract
    btoi
    intc_2 // 0

sum_dynamic_box_for_header@1:
    // box_storage/contract.py:277
    // for val in self.dynamic_box.value:
    frame_dig 2
    frame_dig 1
    <
    bz sum_dynamic_box_after_for@4
    frame_dig 2
    dup
    intc_3 // 8
    *
    intc_1 // 2
    +
    bytec_3 // "dynamic_box"
    swap
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:278
    // total += val
    frame_dig 0
    +
    frame_bury 0
    intc_0 // 1
    +
    frame_bury 2
    b sum_dynamic_box_for_header@1

sum_dynamic_box_after_for@4:
    // box_storage/contract.py:279
    // return total
    retsub


// examples.box_storage.contract.BoxContract.slice_box() -> void:
slice_box:
    // box_storage/contract.py:283
    // box_0 = Box(Bytes, key=String("0"))
    bytec 10 // "0"
    // box_storage/contract.py:284
    // box_0.value = Bytes(b"Testing testing 123")
    box_del
    pop
    // box_storage/contract.py:283
    // box_0 = Box(Bytes, key=String("0"))
    bytec 10 // "0"
    // box_storage/contract.py:284
    // box_0.value = Bytes(b"Testing testing 123")
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    // box_storage/contract.py:283
    // box_0 = Box(Bytes, key=String("0"))
    bytec 10 // "0"
    // box_storage/contract.py:285
    // assert box_0.value[0:7] == b"Testing"
    box_len
    pop
    dup
    intc_2 // 0
    dig 2
    select
    pushint 7 // 7
    dig 2
    <
    uncover 2
    pushint 7 // 7
    uncover 2
    select
    dig 1
    -
    // box_storage/contract.py:283
    // box_0 = Box(Bytes, key=String("0"))
    bytec 10 // "0"
    // box_storage/contract.py:285
    // assert box_0.value[0:7] == b"Testing"
    cover 2
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    // box_storage/contract.py:287
    // self.box_c.value = arc4.String("Hello")
    bytec_1 // 0x424f585f43
    box_del
    pop
    bytec_1 // 0x424f585f43
    pushbytes 0x000548656c6c6f
    box_put
    // box_storage/contract.py:288
    // assert self.box_c.value.bytes[2:10] == b"Hello"
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_1 // 2
    dig 1
    <
    dig 1
    intc_1 // 2
    uncover 2
    select
    pushint 10 // 10
    dig 2
    <
    uncover 2
    pushint 10 // 10
    uncover 2
    select
    dig 1
    -
    bytec_1 // 0x424f585f43
    cover 2
    box_extract
    pushbytes 0x48656c6c6f
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.arc4_box() -> void:
arc4_box:
    // box_storage/contract.py:292-293
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    pushbytess 0x64 0x00010203 // 0x64, 0x00010203
    // box_storage/contract.py:293
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    box_put
    retsub


// examples.box_storage.contract.BoxContract.test_box_ref() -> void:
test_box_ref:
    // box_storage/contract.py:302-303
    // # init ref, with valid key types
    // box_ref = BoxRef(key="blob")
    bytec_2 // "blob"
    // box_storage/contract.py:304
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:305
    // box_ref = BoxRef(key=b"blob")
    bytec_2 // 0x626c6f62
    // box_storage/contract.py:306
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:307
    // box_ref = BoxRef(key=Bytes(b"blob"))
    bytec_2 // 0x626c6f62
    // box_storage/contract.py:308
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:310
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:312-313
    // # create
    // assert box_ref.create(size=32)
    pushint 32 // 32
    box_create
    assert
    // box_storage/contract.py:316-317
    // # manipulate data
    // sender_bytes = Txn.sender.bytes
    txn Sender
    // box_storage/contract.py:318
    // app_address = Global.current_application_address.bytes
    global CurrentApplicationAddress
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:320
    // box_ref.replace(0, sender_bytes)
    intc_2 // 0
    dig 3
    box_replace
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:321
    // box_ref.resize(8000)
    pushint 8000 // 8000
    box_resize
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:322
    // box_ref.splice(0, 0, app_address)
    intc_2 // 0
    dup
    dig 3
    box_splice
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:323
    // box_ref.replace(64, value_3)
    pushint 64 // 64
    // box_storage/contract.py:319
    // value_3 = Bytes(b"hello")
    bytec 12 // 0x68656c6c6f
    // box_storage/contract.py:323
    // box_ref.replace(64, value_3)
    box_replace
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:324
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    intc_2 // 0
    pushint 69 // 69
    box_extract
    // box_storage/contract.py:325
    // assert prefix == app_address + sender_bytes + value_3
    dig 1
    dig 3
    concat
    // box_storage/contract.py:319
    // value_3 = Bytes(b"hello")
    bytec 12 // 0x68656c6c6f
    // box_storage/contract.py:325
    // assert prefix == app_address + sender_bytes + value_3
    concat
    ==
    assert
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:327-328
    // # delete
    // assert box_ref.delete()
    box_del
    assert
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:331-332
    // # query
    // value, exists = box_ref.maybe()
    box_get
    // box_storage/contract.py:333
    // assert not exists
    dup
    !
    assert
    // box_storage/contract.py:334
    // assert value == b""
    dig 1
    pushbytes 0x
    ==
    assert
    // box_storage/contract.py:335
    // assert box_ref.get(default=sender_bytes) == sender_bytes
    dig 3
    cover 2
    select
    dig 2
    ==
    assert
    // box_storage/contract.py:337-338
    // # update
    // box_ref.put(sender_bytes + app_address)
    concat
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:337-338
    // # update
    // box_ref.put(sender_bytes + app_address)
    swap
    box_put
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:340
    // assert box_ref.length == 64
    box_len
    pop
    pushint 64 // 64
    ==
    assert
    // box_storage/contract.py:309
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:396
    // return ref.length
    box_len
    pop
    // box_storage/contract.py:341
    // assert get_box_ref_length(box_ref) == 64
    pushint 64 // 64
    ==
    assert
    // box_storage/contract.py:343-344
    // # instance box ref
    // self.box_ref.create(size=UInt64(32))
    bytec 15 // "box_ref"
    pushint 32 // 32
    box_create
    pop
    // box_storage/contract.py:346
    // self.box_ref.delete()
    bytec 15 // "box_ref"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_test() -> void:
box_map_test:
    // box_storage/contract.py:350
    // key_0 = UInt64(0)
    intc_2 // 0
    // box_storage/contract.py:353
    // self.box_map[key_0] = value
    itob
    dup
    box_del
    pop
    dup
    // box_storage/contract.py:352
    // value = String("Hmmmmm")
    pushbytes "Hmmmmm"
    // box_storage/contract.py:353
    // self.box_map[key_0] = value
    box_put
    // box_storage/contract.py:356
    // assert self.box_map[key_0].bytes.length == value.bytes.length
    dup
    box_len
    pop
    pushint 6 // 6
    ==
    assert
    // box_storage/contract.py:357
    // assert self.box_map[key_0].bytes.length == box_0.length
    dup
    box_len
    pop
    swap
    dup
    box_len
    pop
    uncover 2
    ==
    assert
    // box_storage/contract.py:358
    // assert self.box_map.length(key_0) == value.bytes.length
    box_len
    pop
    pushint 6 // 6
    ==
    assert
    // box_storage/contract.py:351
    // key_1 = UInt64(1)
    intc_0 // 1
    // box_storage/contract.py:360
    // assert self.box_map.get(key_1, default=String("default")) == String("default")
    itob
    dup
    box_get
    bytec 16 // "default"
    cover 2
    select
    bytec 16 // "default"
    ==
    assert
    // box_storage/contract.py:361
    // value, exists = self.box_map.maybe(key_1)
    dup
    box_len
    bury 1
    // box_storage/contract.py:362
    // assert not exists
    !
    assert
    // box_storage/contract.py:368
    // tmp_box_map[key_1] = String("hello")
    dup
    box_del
    pop
    dup
    bytec 12 // "hello"
    box_put
    // box_storage/contract.py:370
    // del tmp_box_map[key_1]
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_set(key: uint64, value: bytes) -> void:
box_map_set:
    // box_storage/contract.py:372-373
    // @arc4.abimethod
    // def box_map_set(self, key: UInt64, value: String) -> None:
    proto 2 0
    // box_storage/contract.py:374
    // self.box_map[key] = value
    frame_dig -2
    itob
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.box_map_get(key: uint64) -> bytes:
box_map_get:
    // box_storage/contract.py:376-377
    // @arc4.abimethod
    // def box_map_get(self, key: UInt64) -> String:
    proto 1 1
    // box_storage/contract.py:378
    // return self.box_map[key]
    frame_dig -1
    itob
    box_get
    assert // check self.box_map entry exists
    retsub


// examples.box_storage.contract.BoxContract.box_map_del(key: uint64) -> void:
box_map_del:
    // box_storage/contract.py:380-381
    // @arc4.abimethod
    // def box_map_del(self, key: UInt64) -> None:
    proto 1 0
    // box_storage/contract.py:382
    // del self.box_map[key]
    frame_dig -1
    itob
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_exists(key: uint64) -> uint64:
box_map_exists:
    // box_storage/contract.py:384-385
    // @arc4.abimethod
    // def box_map_exists(self, key: UInt64) -> bool:
    proto 1 1
    // box_storage/contract.py:386
    // return key in self.box_map
    frame_dig -1
    itob
    box_len
    bury 1
    retsub
