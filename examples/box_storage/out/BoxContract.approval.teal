#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 2 1 8 0 4096 4098 5000 4138
    bytecblock "dynamic_arr_struct" "box" "dynamic_box" 0x151f7c75 0x424f585f43 "blob" "box_large" "box_a" "box_d" "b" "too_many_bools" "big_bytes" "big_fixed_bytes" "many_ints" 0x00023432 "0" 0x68656c6c6f 0x068101 0x0014 "box_ref" "default"
    // box_storage/contract.py:80
    // class BoxContract(arc4.ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@52
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x7d37296e 0x33325d3d 0x0199408d 0x772059ca 0xaa68d894 0x9b01ee56 0x1d6f6daf 0x2641daed 0x50c22157 0x9d52ee88 0x9fabe74e 0xf09069ae 0x01263df6 0xd566c632 0xfabcb885 0xa6174812 0xf13dd937 0x5ab60f2e 0xf07a0064 0x78f9af3f 0x5cbb9dcc 0x996497ae 0x6cec72ff 0x6f9d1075 0x0d22b441 0x59ef3760 0xaa666b96 0xdfbdd636 0x41427cd1 0x2a141f6c 0x7e843744 0x25600b57 0x29ea595d 0x11453152 0xced1221e 0x04ef4971 0x23ecb32c 0xeef75816 0xb532913a 0xc29f1669 0x9c888c09 0xe6f68506 0x8ee2c364 // method "set_boxes(uint64,byte[],string)void", method "check_keys()void", method "create_many_ints()void", method "set_many_ints(uint64,uint64)void", method "create_big_fixed_bytes()void", method "update_big_fixed_bytes(uint64,byte[])void", method "assert_big_fixed_bytes(uint64,byte[])void", method "slice_big_fixed_bytes(uint64,uint64)byte[]", method "create_big_bytes(uint64)void", method "update_big_bytes(uint64,byte[])void", method "assert_big_bytes(uint64,byte[])void", method "slice_big_bytes(uint64,uint64)byte[]", method "sum_many_ints()uint64", method "delete_boxes()void", method "indirect_extract_and_replace()void", method "read_boxes()(uint64,byte[],string,uint64)", method "boxes_exist()(bool,bool,bool,bool)", method "create_dynamic_arr_struct()void", method "delete_dynamic_arr_struct()void", method "append_dynamic_arr_struct(uint64)uint64", method "pop_dynamic_arr_struct(uint64)uint64", method "set_nested_struct((uint64,(uint64,uint64[][],uint64),(uint64,uint64[][],uint64)[],uint64))void", method "nested_write(uint64,uint64)void", method "nested_read(uint64,uint64,uint64)uint64", method "sum_dynamic_arr_struct()uint64", method "create_bools()void", method "set_bool(uint64,bool)void", method "sum_bools(uint64)uint64", method "create_dynamic_box()void", method "delete_dynamic_box()void", method "append_dynamic_box(uint64)uint64", method "pop_dynamic_box(uint64)uint64", method "sum_dynamic_box()uint64", method "write_dynamic_box(uint64,uint64)void", method "write_dynamic_arr_struct(uint64,uint64)void", method "slice_box()void", method "arc4_box()void", method "test_box_ref()void", method "box_map_test()void", method "box_map_set(uint64,string)void", method "box_map_get(uint64)string", method "box_map_del(uint64)void", method "box_map_exists(uint64)bool"
    txna ApplicationArgs 0
    match set_boxes main_check_keys_route@7 main_create_many_ints_route@8 set_many_ints main_create_big_fixed_bytes_route@10 update_big_fixed_bytes assert_big_fixed_bytes slice_big_fixed_bytes create_big_bytes update_big_bytes assert_big_bytes slice_big_bytes sum_many_ints delete_boxes indirect_extract_and_replace read_boxes boxes_exist create_dynamic_arr_struct main_delete_dynamic_arr_struct_route@24 append_dynamic_arr_struct pop_dynamic_arr_struct set_nested_struct nested_write nested_read sum_dynamic_arr_struct main_create_bools_route@31 set_bool sum_bools create_dynamic_box main_delete_dynamic_box_route@35 append_dynamic_box pop_dynamic_box sum_dynamic_box write_dynamic_box write_dynamic_arr_struct slice_box main_arc4_box_route@42 test_box_ref box_map_test box_map_set box_map_get box_map_del box_map_exists
    err

main_arc4_box_route@42:
    // box_storage/contract.py:412-413
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    pushbytess 0x64 0x00010203
    // box_storage/contract.py:413
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    box_put
    // box_storage/contract.py:410
    // @arc4.abimethod
    intc_1 // 1
    return

main_delete_dynamic_box_route@35:
    // box_storage/contract.py:358
    // del self.dynamic_box.value
    bytec_2 // "dynamic_box"
    box_del
    pop
    // box_storage/contract.py:356
    // @arc4.abimethod
    intc_1 // 1
    return

main_create_bools_route@31:
    // box_storage/contract.py:336
    // self.too_many_bools.create()
    bytec 10 // "too_many_bools"
    pushint 4125
    box_create
    pop
    // box_storage/contract.py:334
    // @arc4.abimethod
    intc_1 // 1
    return

main_delete_dynamic_arr_struct_route@24:
    // box_storage/contract.py:231
    // del self.dynamic_arr_struct.value
    bytec_0 // "dynamic_arr_struct"
    box_del
    pop
    // box_storage/contract.py:229
    // @arc4.abimethod
    intc_1 // 1
    return

main_create_big_fixed_bytes_route@10:
    // box_storage/contract.py:150
    // self.big_fixed_bytes.create()
    bytec 12 // "big_fixed_bytes"
    intc 6 // 5000
    box_create
    pop
    // box_storage/contract.py:148
    // @arc4.abimethod()
    intc_1 // 1
    return

main_create_many_ints_route@8:
    // box_storage/contract.py:142
    // self.many_ints.create()
    bytec 13 // "many_ints"
    pushint 4104
    box_create
    pop
    // box_storage/contract.py:140
    // @arc4.abimethod()
    intc_1 // 1
    return

main_check_keys_route@7:
    // box_storage/contract.py:133
    // @arc4.abimethod
    intc_1 // 1
    return

main___algopy_default_create@52:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// examples.box_storage.contract.BoxContract.set_boxes[routing]() -> void:
set_boxes:
    // box_storage/contract.py:97
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // box_storage/contract.py:99
    // self.box_a.value = a
    uncover 4
    itob
    bytec 7 // "box_a"
    swap
    box_put
    // box_storage/contract.py:100
    // self.box_b.value = b.copy()
    bytec 9 // "b"
    box_del
    pop
    bytec 9 // "b"
    dig 4
    box_put
    // box_storage/contract.py:101
    // self.box_c.value = c
    bytec 4 // 0x424f585f43
    box_del
    pop
    bytec 4 // 0x424f585f43
    dig 2
    box_put
    // box_storage/contract.py:102
    // self.box_d.value = b.native
    dig 3
    extract 2 0
    bytec 8 // "box_d"
    box_del
    pop
    bytec 8 // "box_d"
    dig 1
    box_put
    // box_storage/contract.py:103
    // self.box_large.create()
    bytec 6 // "box_large"
    pushint 6160
    box_create
    pop
    // box_storage/contract.py:104
    // self.box_large.value.e = UInt64(42)
    pushint 42
    itob
    bytec 6 // "box_large"
    intc 4 // 4096
    uncover 2
    box_replace
    // box_storage/contract.py:105
    // self.box_large.replace(size_of(Bytes1024) * 4, arc4.UInt64(42).bytes)
    bytec 6 // "box_large"
    intc 4 // 4096
    pushbytes 0x000000000000002a
    box_replace
    // box_storage/contract.py:110
    // self.box_a.value += 3
    bytec 7 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3
    +
    itob
    bytec 7 // "box_a"
    swap
    box_put
    // box_storage/contract.py:112-113
    // # test .length
    // assert self.box_a.length == 8
    bytec 7 // "box_a"
    box_len
    pop
    intc_2 // 8
    ==
    assert
    // box_storage/contract.py:114
    // assert self.box_b.length == b.bytes.length
    bytec 9 // "b"
    box_len
    pop
    uncover 4
    ==
    assert
    // box_storage/contract.py:115
    // assert self.box_c.length == c.bytes.length
    bytec 4 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    dup
    dig 3
    ==
    assert
    // box_storage/contract.py:116
    // assert self.box_d.length == b.native.length
    bytec 8 // "box_d"
    box_len
    pop
    dig 2
    len
    dup2
    ==
    assert
    // box_storage/contract.py:118-119
    // # test .value.bytes
    // assert self.box_c.value.bytes[0] == c.bytes[0]
    bytec 4 // 0x424f585f43
    intc_3 // 0
    intc_1 // 1
    box_extract
    dig 6
    extract 0 1
    ==
    assert
    // box_storage/contract.py:120
    // assert self.box_c.value.bytes[-1] == c.bytes[-1]
    dig 2
    intc_1 // 1
    -
    bytec 4 // 0x424f585f43
    swap
    intc_1 // 1
    box_extract
    dig 5
    intc_1 // 1
    -
    dig 7
    swap
    intc_1 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:121
    // assert self.box_c.value.bytes[:-1] == c.bytes[:-1]
    intc_1 // 1
    dig 3
    >=
    intc_1 // 1
    dig 4
    uncover 2
    select
    dig 3
    swap
    -
    bytec 4 // 0x424f585f43
    intc_3 // 0
    uncover 2
    box_extract
    intc_1 // 1
    dig 6
    >=
    intc_1 // 1
    dig 7
    uncover 2
    select
    dig 6
    swap
    -
    dig 7
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:122
    // assert self.box_c.value.bytes[:2] == c.bytes[:2]
    intc_0 // 2
    dig 3
    >=
    intc_0 // 2
    uncover 4
    uncover 2
    select
    bytec 4 // 0x424f585f43
    intc_3 // 0
    uncover 2
    box_extract
    intc_0 // 2
    dig 5
    >=
    intc_0 // 2
    uncover 6
    uncover 2
    select
    uncover 5
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:124-125
    // # test .value with Bytes type
    // assert self.box_d.value[0] == b.native[0]
    bytec 8 // "box_d"
    intc_3 // 0
    intc_1 // 1
    box_extract
    uncover 4
    extract 2 1
    ==
    assert
    // box_storage/contract.py:126
    // assert self.box_d.value[-1] == b.native[-1]
    dig 1
    intc_1 // 1
    -
    bytec 8 // "box_d"
    swap
    intc_1 // 1
    box_extract
    dig 1
    intc_1 // 1
    -
    dig 4
    swap
    intc_1 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:127
    // assert self.box_d.value[:-1] == b.native[:-1]
    intc_1 // 1
    dig 2
    >=
    intc_1 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    intc_1 // 1
    dig 2
    >=
    intc_1 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    dig 4
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:128
    // assert self.box_d.value[:5] == b.native[:5]
    pushint 5
    dig 2
    >=
    pushint 5
    dig 3
    uncover 2
    select
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    pushint 5
    dig 2
    >=
    pushint 5
    dig 3
    uncover 2
    select
    dig 4
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:129
    // assert self.box_d.value[: UInt64(2)] == b.native[: UInt64(2)]
    intc_0 // 2
    dig 2
    >=
    intc_0 // 2
    uncover 3
    uncover 2
    select
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    intc_0 // 2
    dig 2
    >=
    intc_0 // 2
    uncover 3
    uncover 2
    select
    uncover 2
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:131
    // assert self.box_large.length == size_of(LargeStruct)
    bytec 6 // "box_large"
    box_len
    pop
    pushint 6160
    ==
    assert
    // box_storage/contract.py:97
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.set_many_ints[routing]() -> void:
set_many_ints:
    // box_storage/contract.py:144
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // box_storage/contract.py:146
    // self.many_ints.value[index] = value
    swap
    intc_2 // 8
    *
    bytec 13 // "many_ints"
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:144
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.update_big_fixed_bytes[routing]() -> void:
update_big_fixed_bytes:
    // box_storage/contract.py:152
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // box_storage/contract.py:154
    // self.big_fixed_bytes.splice(start_index, value.length, value)
    dup
    len
    bytec 12 // "big_fixed_bytes"
    uncover 3
    uncover 2
    uncover 3
    box_splice
    // box_storage/contract.py:152
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.assert_big_fixed_bytes[routing]() -> void:
assert_big_fixed_bytes:
    // box_storage/contract.py:156
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // box_storage/contract.py:158
    // assert self.big_fixed_bytes.value[index] == value
    bytec 12 // "big_fixed_bytes"
    uncover 2
    intc_1 // 1
    box_extract
    ==
    assert
    // box_storage/contract.py:156
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.slice_big_fixed_bytes[routing]() -> void:
slice_big_fixed_bytes:
    // box_storage/contract.py:160
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:162
    // return self.big_fixed_bytes.value[start:end]
    dig 1
    intc 6 // 5000
    >=
    uncover 2
    intc 6 // 5000
    uncover 2
    select
    dig 1
    intc 6 // 5000
    >=
    uncover 2
    intc 6 // 5000
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    dig 1
    -
    bytec 12 // "big_fixed_bytes"
    cover 2
    box_extract
    // box_storage/contract.py:160
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.create_big_bytes[routing]() -> void:
create_big_bytes:
    // box_storage/contract.py:164
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:166
    // self.big_bytes.create(size=size)
    bytec 11 // "big_bytes"
    swap
    box_create
    pop
    // box_storage/contract.py:164
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.update_big_bytes[routing]() -> void:
update_big_bytes:
    // box_storage/contract.py:168
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // box_storage/contract.py:170
    // self.big_bytes.splice(start_index, value.length, value)
    dup
    len
    bytec 11 // "big_bytes"
    uncover 3
    uncover 2
    uncover 3
    box_splice
    // box_storage/contract.py:168
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.assert_big_bytes[routing]() -> void:
assert_big_bytes:
    // box_storage/contract.py:172
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // box_storage/contract.py:174
    // assert self.big_bytes.value[index] == value
    bytec 11 // "big_bytes"
    uncover 2
    intc_1 // 1
    box_extract
    ==
    assert
    // box_storage/contract.py:172
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.slice_big_bytes[routing]() -> void:
slice_big_bytes:
    // box_storage/contract.py:176
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:178
    // return self.big_bytes.value[start:end]
    bytec 11 // "big_bytes"
    box_len
    pop
    dig 2
    dig 1
    >=
    uncover 3
    dig 2
    uncover 2
    select
    dig 2
    dig 2
    >=
    uncover 3
    uncover 3
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    dig 1
    -
    bytec 11 // "big_bytes"
    cover 2
    box_extract
    // box_storage/contract.py:176
    // @arc4.abimethod()
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.sum_many_ints[routing]() -> void:
sum_many_ints:
    pushbytes ""
    dup

sum_many_ints_while_top@7:
    pushint 10510
    global OpcodeBudget
    >
    bz sum_many_ints_after_while@12
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 17 // 0x068101
    itxn_field ApprovalProgram
    bytec 17 // 0x068101
    itxn_field ClearStateProgram
    intc_3 // 0
    itxn_field Fee
    itxn_submit
    b sum_many_ints_while_top@7

sum_many_ints_after_while@12:
    // box_storage/contract.py:183
    // total = UInt64(0)
    intc_3 // 0
    bury 1
    // box_storage/contract.py:184
    // for val in self.many_ints.value:
    bytec 13 // "many_ints"
    box_len
    bury 1
    assert // check self.many_ints exists
    intc_3 // 0
    bury 2

sum_many_ints_for_header@2:
    // box_storage/contract.py:184
    // for val in self.many_ints.value:
    dig 1
    pushint 513
    <
    bz sum_many_ints_after_for@5
    dig 1
    dup
    intc_2 // 8
    *
    bytec 13 // "many_ints"
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:185
    // total = total + val
    dig 2
    +
    bury 2
    intc_1 // 1
    +
    bury 2
    b sum_many_ints_for_header@2

sum_many_ints_after_for@5:
    // box_storage/contract.py:180
    // @arc4.abimethod()
    dup
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.delete_boxes[routing]() -> void:
delete_boxes:
    // box_storage/contract.py:190
    // del self.box_a.value
    bytec 7 // "box_a"
    box_del
    pop
    // box_storage/contract.py:191
    // del self.box_b.value
    bytec 9 // "b"
    box_del
    pop
    // box_storage/contract.py:192
    // del self.box_c.value
    bytec 4 // 0x424f585f43
    box_del
    pop
    // box_storage/contract.py:193
    // assert self.box_a.get(default=UInt64(42)) == 42
    bytec 7 // "box_a"
    box_get
    swap
    btoi
    pushint 42
    dig 1
    dig 3
    select
    pushint 42
    ==
    assert
    // box_storage/contract.py:194
    // assert self.box_b.get(default=arc4.DynamicBytes(b"42")).native == b"42"
    bytec 9 // "b"
    box_get
    bytec 14 // 0x00023432
    cover 2
    select
    extract 2 0
    pushbytes 0x3432
    ==
    assert
    // box_storage/contract.py:195
    // assert self.box_c.get(default=arc4.String("42")) == "42"
    bytec 4 // 0x424f585f43
    box_get
    bytec 14 // 0x00023432
    cover 2
    select
    bytec 14 // 0x00023432
    ==
    assert
    // box_storage/contract.py:197
    // assert not a_exists
    swap
    !
    assert
    // box_storage/contract.py:198
    // assert a == 0
    !
    assert
    // box_storage/contract.py:199
    // del self.box_large.value
    bytec 6 // "box_large"
    box_del
    pop
    // box_storage/contract.py:188
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.indirect_extract_and_replace[routing]() -> void:
indirect_extract_and_replace:
    // box_storage/contract.py:203
    // large = self.box_large.value.copy()
    bytec 6 // "box_large"
    // box_storage/contract.py:203-204
    // large = self.box_large.value.copy()
    // large.e += 1
    intc 4 // 4096
    intc_2 // 8
    box_extract
    // box_storage/contract.py:204
    // large.e += 1
    btoi
    intc_1 // 1
    +
    itob
    // box_storage/contract.py:205
    // self.box_large.value = large.copy()
    bytec 6 // "box_large"
    // box_storage/contract.py:203-205
    // large = self.box_large.value.copy()
    // large.e += 1
    // self.box_large.value = large.copy()
    intc 4 // 4096
    uncover 2
    box_replace
    // box_storage/contract.py:201
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.read_boxes[routing]() -> void:
read_boxes:
    // box_storage/contract.py:210
    // get_box_value_plus_1(self.box_a) - 1,
    bytec 7 // "box_a"
    // box_storage/contract.py:511
    // return box.value + 1
    box_get
    assert // check Box exists
    btoi
    intc_1 // 1
    +
    // box_storage/contract.py:210
    // get_box_value_plus_1(self.box_a) - 1,
    intc_1 // 1
    -
    // box_storage/contract.py:211
    // self.box_b.value.native,
    bytec 9 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    // box_storage/contract.py:212
    // self.box_c.value,
    bytec 4 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    // box_storage/contract.py:213
    // self.box_large.value.e,
    bytec 6 // "box_large"
    intc 4 // 4096
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:207
    // @arc4.abimethod
    uncover 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    dup
    len
    pushint 20
    +
    itob
    extract 6 2
    uncover 3
    itob
    uncover 2
    uncover 4
    concat
    concat
    concat
    bytec 18 // 0x0014
    swap
    concat
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.boxes_exist[routing]() -> void:
boxes_exist:
    // box_storage/contract.py:218
    // return bool(self.box_a), bool(self.box_b), bool(self.box_c), bool(self.box_large)
    bytec 7 // "box_a"
    box_len
    bury 1
    bytec 9 // "b"
    box_len
    cover 2
    pop
    bytec 4 // 0x424f585f43
    box_len
    cover 3
    pop
    bytec 6 // "box_large"
    box_len
    cover 4
    pop
    // box_storage/contract.py:216
    // @arc4.abimethod
    pushbytes 0x00
    intc_3 // 0
    uncover 2
    setbit
    intc_1 // 1
    uncover 2
    setbit
    intc_0 // 2
    uncover 2
    setbit
    pushint 3
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.create_dynamic_arr_struct[routing]() -> void:
create_dynamic_arr_struct:
    // box_storage/contract.py:223
    // a=Txn.num_app_args,
    txn NumAppArgs
    // box_storage/contract.py:225
    // b=Txn.num_app_args * 2,
    dup
    intc_0 // 2
    *
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    swap
    itob
    swap
    itob
    pushbytes 0x001600000000
    concat
    bytec 18 // 0x0014
    swap
    concat
    concat
    // box_storage/contract.py:222
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    box_del
    pop
    // box_storage/contract.py:222
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    swap
    box_put
    // box_storage/contract.py:220
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.append_dynamic_arr_struct[routing]() -> void:
append_dynamic_arr_struct:
    // box_storage/contract.py:233
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // box_storage/contract.py:235-237
    // # TODO: support append using high level array operations, instead of
    // #       relying on struct layout tricks with FixedArrayInAStruct
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    bytec_0 // "dynamic_arr_struct"
    pushint 10
    intc_2 // 8
    box_extract
    btoi
    intc_0 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:238
    // arr_len = self.dynamic_arr_struct.value.arr.length
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    dup
    cover 2
    // box_storage/contract.py:239
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    bytec_0 // "dynamic_arr_struct"
    pushint 18
    intc_0 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_0 // 2
    box_extract
    btoi
    // box_storage/contract.py:243
    // get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    dig 1
    dig 3
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    intc_2 // 8
    *
    // box_storage/contract.py:527-528
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22
    +
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    swap
    intc_2 // 8
    *
    intc_0 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    // box_storage/contract.py:241-242
    // # expand box
    // self.dynamic_arr_struct.resize(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:241-244
    // # expand box
    // self.dynamic_arr_struct.resize(
    //     get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    // )
    swap
    box_resize
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    intc_2 // 8
    *
    // box_storage/contract.py:527-528
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22
    +
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    swap
    intc_2 // 8
    *
    bzero
    // box_storage/contract.py:245-246
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:245-248
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    uncover 2
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    intc_3 // 0
    // box_storage/contract.py:245-248
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    uncover 3
    box_splice
    // box_storage/contract.py:251
    // for i in urange(times):
    intc_3 // 0

append_dynamic_arr_struct_for_header@2:
    // box_storage/contract.py:251
    // for i in urange(times):
    dup
    dig 3
    <
    bz append_dynamic_arr_struct_after_for@5
    // box_storage/contract.py:252
    // box.value.arr.arr[arr_len] = i
    dupn 2
    itob
    dig 3
    dup
    cover 2
    intc_2 // 8
    *
    pushint 22
    +
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:252
    // box.value.arr.arr[arr_len] = i
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:253
    // arr_len += 1
    intc_1 // 1
    +
    bury 3
    // box_storage/contract.py:251
    // for i in urange(times):
    intc_1 // 1
    +
    bury 1
    b append_dynamic_arr_struct_for_header@2

append_dynamic_arr_struct_after_for@5:
    // box_storage/contract.py:254
    // box.value.arr.length = arc4.UInt16(arr_len)
    dig 1
    dup
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:254
    // box.value.arr.length = arc4.UInt16(arr_len)
    pushint 20
    uncover 2
    box_replace
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    dup
    intc_2 // 8
    *
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    pushint 24
    +
    // box_storage/contract.py:255-256
    // # when calculating arr2_offset need to sub 2 from 0th index to account for length bytes
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_0 // 2
    -
    // box_storage/contract.py:257
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:257
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    pushint 18
    uncover 2
    box_replace
    // box_storage/contract.py:260
    // self.dynamic_arr_struct.value.arr.length == arr_len
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    dup
    uncover 2
    ==
    // box_storage/contract.py:259-261
    // assert (
    //     self.dynamic_arr_struct.value.arr.length == arr_len
    // ), "expected arr length to be correct"
    assert // expected arr length to be correct
    // box_storage/contract.py:262
    // assert self.dynamic_arr_struct.value.arr2.length == 0, "expected arr2 length to be correct"
    bytec_0 // "dynamic_arr_struct"
    pushint 18
    intc_0 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_0 // 2
    box_extract
    btoi
    !
    assert // expected arr2 length to be correct
    // box_storage/contract.py:233
    // @arc4.abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct[routing]() -> void:
pop_dynamic_arr_struct:
    // box_storage/contract.py:265
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:270
    // arr_len = self.dynamic_arr_struct.value.arr.length - times
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    dig 1
    -
    // box_storage/contract.py:271
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    bytec_0 // "dynamic_arr_struct"
    pushint 18
    intc_0 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_0 // 2
    box_extract
    btoi
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    dig 1
    intc_2 // 8
    *
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    dup
    // box_storage/contract.py:527-528
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    // return head + dyn_arr_index
    pushint 22
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    swap
    pushint 24
    +
    // box_storage/contract.py:274
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_0 // 2
    -
    // box_storage/contract.py:275
    // box.value.arr.length = arc4.UInt16(arr_len)
    uncover 3
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:275
    // box.value.arr.length = arc4.UInt16(arr_len)
    pushint 20
    uncover 2
    box_replace
    // box_storage/contract.py:276
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:276
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    pushint 18
    uncover 2
    box_replace
    // box_storage/contract.py:278
    // box.splice(index, times * size_of(UInt64), b"")
    uncover 2
    intc_2 // 8
    *
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_0 // "dynamic_arr_struct"
    // box_storage/contract.py:278
    // box.splice(index, times * size_of(UInt64), b"")
    dig 2
    uncover 2
    pushbytes 0x
    box_splice
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    swap
    intc_2 // 8
    *
    intc_0 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    // box_storage/contract.py:283
    // self.dynamic_arr_struct.resize(size)
    bytec_0 // "dynamic_arr_struct"
    swap
    box_resize
    // box_storage/contract.py:285
    // return self.dynamic_arr_struct.value.arr.length
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    // box_storage/contract.py:265
    // @arc4.abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.set_nested_struct[routing]() -> void:
set_nested_struct:
    intc_3 // 0
    dup
    pushbytes ""
    dupn 6
    // box_storage/contract.py:287
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    uncover 2
    dup
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 20
    ==
    assert // invalid tail pointer at index 1 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    uncover 2
    substring3
    dup
    len
    dig 1
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    swap
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_0 // 2
    *
    swap
    extract 2 0
    intc_3 // 0

set_nested_struct_for_header@1:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dup
    dig 4
    <
    bz set_nested_struct_after_for@4
    dupn 2
    intc_0 // 2
    *
    dig 3
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 6
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 8
    *
    intc_0 // 2
    +
    +
    bury 4
    intc_1 // 1
    +
    bury 1
    b set_nested_struct_for_header@1

set_nested_struct_after_for@4:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 2
    pushint 40
    +
    dup
    bury 14
    dig 6
    dup
    cover 2
    pushint 10
    extract_uint16 // on error: invalid tuple encoding
    dup
    uncover 2
    ==
    assert // invalid tail pointer at index 2 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    dig 6
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 14
    intc_0 // 2
    *
    bury 9
    extract 2 0
    bury 15
    intc_3 // 0
    bury 10

set_nested_struct_for_header@5:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 9
    dig 12
    <
    bz set_nested_struct_after_for@12
    dig 9
    intc_0 // 2
    *
    dig 15
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 10
    ==
    assert // invalid tail pointer for (len+(uint64,(len+(len+uint64[])[]),uint64)[])
    dig 1
    len
    substring3
    dup
    len
    dig 1
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    swap
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 13
    intc_0 // 2
    *
    bury 8
    extract 2 0
    bury 14
    intc_3 // 0
    bury 9

set_nested_struct_for_header@7:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 8
    dig 11
    <
    bz set_nested_struct_after_for@10
    dig 8
    dup
    intc_0 // 2
    *
    dig 15
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 10
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 8
    *
    intc_0 // 2
    +
    +
    bury 8
    intc_1 // 1
    +
    bury 9
    b set_nested_struct_for_header@7

set_nested_struct_after_for@10:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 6
    pushint 20
    +
    dig 8
    +
    bury 8
    dig 9
    intc_1 // 1
    +
    bury 10
    b set_nested_struct_for_header@5

set_nested_struct_after_for@12:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 7
    intc_0 // 2
    +
    dig 13
    +
    dig 5
    ==
    assert // invalid number of bytes for examples.box_storage.contract.NestedStruct
    // box_storage/contract.py:290
    // assert struct.a, "struct.a is truthy"
    dig 5
    intc_3 // 0
    extract_uint64
    assert // struct.a is truthy
    // box_storage/contract.py:291
    // struct_bytes = Txn.application_args(1)
    txna ApplicationArgs 1
    // box_storage/contract.py:292
    // struct_size = struct_bytes.length
    dup
    len
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 5 // 4098
    // box_storage/contract.py:294-295
    // # initialize box to zero
    // box.create(size=tail_offset + struct_size)
    +
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:294-295
    // # initialize box to zero
    // box.create(size=tail_offset + struct_size)
    swap
    box_create
    pop
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:296-297
    // # set correct offset for dynamic portion
    // box.replace(tail_offset - 2, arc4.UInt16(tail_offset).bytes)
    intc 4 // 4096
    pushbytes 0x1002
    box_replace
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 5 // 4098
    // box_storage/contract.py:298-299
    // # set dynamic data
    // box.replace(tail_offset, struct_bytes)
    uncover 2
    box_replace
    // box_storage/contract.py:287
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.nested_write[routing]() -> void:
nested_write:
    // box_storage/contract.py:301
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    dup
    btoi
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:304
    // box.value.nested.a = value
    intc 5 // 4098
    uncover 3
    box_replace
    // box_storage/contract.py:305
    // box.value.nested.b = value + 1
    dup
    intc_1 // 1
    +
    itob
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:305
    // box.value.nested.b = value + 1
    pushint 4110
    uncover 2
    box_replace
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    dup
    intc_0 // 2
    +
    itob
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    pushint 4136
    intc_0 // 2
    box_extract
    btoi
    dig 3
    >
    assert // index out of bounds
    intc_0 // 2
    dig 3
    *
    intc 7 // 4138
    dig 1
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    swap
    intc_0 // 2
    box_extract
    btoi
    intc 7 // 4138
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_0 // 2
    +
    dig 4
    intc_2 // 8
    *
    swap
    dig 1
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    swap
    uncover 4
    box_replace
    // box_storage/contract.py:307
    // box.value.nested.inner.c = value + 3
    dig 2
    pushint 3
    +
    itob
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:307
    // box.value.nested.inner.c = value + 3
    pushint 4118
    uncover 2
    box_replace
    // box_storage/contract.py:308
    // box.value.nested.inner.d = value + 4
    dig 2
    pushint 4
    +
    itob
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:308
    // box.value.nested.inner.d = value + 4
    pushint 4128
    uncover 2
    box_replace
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    uncover 2
    pushint 5
    +
    itob
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    pushint 4108
    intc_0 // 2
    box_extract
    btoi
    intc 5 // 4098
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_0 // 2
    +
    dup
    dig 4
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    swap
    intc_0 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_0 // 2
    +
    dup
    uncover 4
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    swap
    intc_0 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_0 // 2
    box_extract
    btoi
    uncover 4
    >
    assert // index out of bounds
    intc_0 // 2
    +
    uncover 2
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:301
    // @arc4.abimethod()
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.nested_read[routing]() -> void:
nested_read:
    // box_storage/contract.py:311
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:314
    // a = box.value.nested.a
    intc 5 // 4098
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:315
    // b = box.value.nested.b
    pushint 4110
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    pushint 4136
    intc_0 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_0 // 2
    dig 5
    *
    intc 7 // 4138
    dig 1
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    swap
    intc_0 // 2
    box_extract
    btoi
    intc 7 // 4138
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 6
    >
    assert // index out of bounds
    intc_0 // 2
    +
    dig 5
    intc_2 // 8
    *
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:317
    // c = box.value.nested.inner.c
    pushint 4118
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:318
    // d = box.value.nested.inner.d
    pushint 4128
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    pushint 4108
    intc_0 // 2
    box_extract
    btoi
    intc 5 // 4098
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_0 // 2
    box_extract
    btoi
    uncover 10
    >
    assert // index out of bounds
    intc_0 // 2
    +
    dup
    uncover 5
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    swap
    intc_0 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 8
    >
    assert // index out of bounds
    intc_0 // 2
    +
    intc_0 // 2
    uncover 8
    *
    dig 1
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    swap
    intc_0 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_0 // 2
    box_extract
    btoi
    dig 7
    >
    assert // index out of bounds
    intc_0 // 2
    +
    uncover 6
    intc_2 // 8
    *
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_1 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:321
    // return a + b + arr_arr + c + d + woah_arr_arr
    uncover 5
    uncover 5
    +
    uncover 4
    +
    uncover 3
    +
    uncover 2
    +
    +
    // box_storage/contract.py:311
    // @arc4.abimethod()
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct[routing]() -> void:
sum_dynamic_arr_struct:
    pushbytes ""
    dup
    // box_storage/contract.py:325
    // assert self.dynamic_arr_struct.value.a == 1, "expected 1"
    bytec_0 // "dynamic_arr_struct"
    intc_3 // 0
    intc_2 // 8
    box_extract
    btoi
    dup
    intc_1 // 1
    ==
    assert // expected 1
    // box_storage/contract.py:326
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    bytec_0 // "dynamic_arr_struct"
    pushint 10
    intc_2 // 8
    box_extract
    btoi
    dup
    intc_0 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:327
    // total = self.dynamic_arr_struct.value.a + self.dynamic_arr_struct.value.b
    +
    // box_storage/contract.py:328
    // for val in self.dynamic_arr_struct.value.arr:
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    intc_3 // 0

sum_dynamic_arr_struct_for_header@2:
    // box_storage/contract.py:328
    // for val in self.dynamic_arr_struct.value.arr:
    dup
    dig 2
    <
    bz sum_dynamic_arr_struct_after_for@5
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    dig 1
    dup
    uncover 2
    <
    assert // index out of bounds
    dup
    intc_2 // 8
    *
    pushint 22
    +
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:329
    // total += val
    dig 4
    +
    bury 4
    intc_1 // 1
    +
    bury 1
    b sum_dynamic_arr_struct_for_header@2

sum_dynamic_arr_struct_after_for@5:
    // box_storage/contract.py:330
    // for val in self.dynamic_arr_struct.value.arr2:
    bytec_0 // "dynamic_arr_struct"
    pushint 18
    intc_0 // 2
    box_extract
    btoi
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_0 // 2
    box_extract
    btoi
    bury 5
    intc_3 // 0
    bury 4

sum_dynamic_arr_struct_for_header@6:
    // box_storage/contract.py:330
    // for val in self.dynamic_arr_struct.value.arr2:
    dig 3
    dig 5
    <
    bz sum_dynamic_arr_struct_after_for@9
    bytec_0 // "dynamic_arr_struct"
    pushint 18
    intc_0 // 2
    box_extract
    btoi
    intc_0 // 2
    +
    dig 4
    dup
    cover 2
    intc_2 // 8
    *
    +
    bytec_0 // "dynamic_arr_struct"
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:331
    // total += val
    dig 4
    +
    bury 4
    intc_1 // 1
    +
    bury 4
    b sum_dynamic_arr_struct_for_header@6

sum_dynamic_arr_struct_after_for@9:
    // box_storage/contract.py:323
    // @arc4.abimethod
    dig 2
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.set_bool[routing]() -> void:
set_bool:
    // box_storage/contract.py:338
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_3 // 0
    getbit
    // box_storage/contract.py:340
    // self.too_many_bools.value[index] = value
    dig 1
    intc_2 // 8
    /
    uncover 2
    intc_2 // 8
    %
    bytec 10 // "too_many_bools"
    dig 2
    intc_1 // 1
    box_extract
    dig 1
    intc_2 // 8
    <
    assert // index access is out of bounds
    swap
    uncover 3
    setbit
    bytec 10 // "too_many_bools"
    cover 2
    box_replace
    // box_storage/contract.py:338
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.sum_bools[routing]() -> void:
sum_bools:
    // box_storage/contract.py:342
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:344
    // total = UInt64()
    intc_3 // 0
    // box_storage/contract.py:345
    // for value in self.too_many_bools.value:
    bytec 10 // "too_many_bools"
    box_len
    bury 1
    assert // check self.too_many_bools exists
    intc_3 // 0

sum_bools_for_header@2:
    // box_storage/contract.py:345
    // for value in self.too_many_bools.value:
    dup
    pushint 33000
    <
    bz sum_bools_after_for@9
    dupn 2
    intc_2 // 8
    /
    swap
    intc_2 // 8
    %
    bytec 10 // "too_many_bools"
    uncover 2
    intc_1 // 1
    box_extract
    swap
    getbit
    // box_storage/contract.py:346
    // if value:
    bz sum_bools_after_if_else@5
    // box_storage/contract.py:347
    // total += 1
    dig 1
    intc_1 // 1
    +
    bury 2

sum_bools_after_if_else@5:
    // box_storage/contract.py:348
    // if total == stop_at_total:
    dig 1
    dig 3
    ==
    bnz sum_bools_after_for@9
    dup
    intc_1 // 1
    +
    bury 1
    b sum_bools_for_header@2

sum_bools_after_for@9:
    // box_storage/contract.py:342
    // @arc4.abimethod()
    dig 1
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.create_dynamic_box[routing]() -> void:
create_dynamic_box:
    // box_storage/contract.py:354
    // self.dynamic_box.value = Array[UInt64]()
    bytec_2 // "dynamic_box"
    box_del
    pop
    bytec_2 // "dynamic_box"
    pushbytes 0x0000
    box_put
    // box_storage/contract.py:352
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.append_dynamic_box[routing]() -> void:
append_dynamic_box:
    // box_storage/contract.py:360
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_2 // "dynamic_box"
    // box_storage/contract.py:365
    // arr_len = box.value.length.as_uint64()
    intc_3 // 0
    intc_0 // 2
    box_extract
    btoi
    dup
    uncover 2
    // box_storage/contract.py:367
    // self.dynamic_box.resize(2 + (arr_len + times) * 8)
    +
    intc_2 // 8
    *
    intc_0 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    box_resize
    // box_storage/contract.py:368
    // for i in urange(times):
    intc_3 // 0

append_dynamic_box_for_header@2:
    // box_storage/contract.py:368
    // for i in urange(times):
    dup
    dig 3
    <
    bz append_dynamic_box_after_for@5
    // box_storage/contract.py:369
    // box.value.arr[arr_len] = i
    dupn 2
    itob
    dig 3
    dup
    cover 2
    intc_2 // 8
    *
    intc_0 // 2
    +
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_2 // "dynamic_box"
    // box_storage/contract.py:369
    // box.value.arr[arr_len] = i
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:370
    // arr_len += 1
    intc_1 // 1
    +
    bury 3
    // box_storage/contract.py:368
    // for i in urange(times):
    intc_1 // 1
    +
    bury 1
    b append_dynamic_box_for_header@2

append_dynamic_box_after_for@5:
    // box_storage/contract.py:372
    // box.value.length = arc4.UInt16(arr_len)
    dig 1
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_2 // "dynamic_box"
    // box_storage/contract.py:372
    // box.value.length = arc4.UInt16(arr_len)
    intc_3 // 0
    uncover 2
    box_replace
    // box_storage/contract.py:373
    // return self.dynamic_box.value.length
    bytec_2 // "dynamic_box"
    intc_3 // 0
    intc_0 // 2
    box_extract
    btoi
    // box_storage/contract.py:360
    // @arc4.abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.pop_dynamic_box[routing]() -> void:
pop_dynamic_box:
    // box_storage/contract.py:375
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:379
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_2 // "dynamic_box"
    // box_storage/contract.py:380
    // arr_len = box.value.length.as_uint64() - times
    intc_3 // 0
    intc_0 // 2
    box_extract
    btoi
    swap
    -
    // box_storage/contract.py:381
    // box.value.length = arc4.UInt16(arr_len)
    dup
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // box_storage/contract.py:379
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec_2 // "dynamic_box"
    // box_storage/contract.py:381
    // box.value.length = arc4.UInt16(arr_len)
    intc_3 // 0
    uncover 2
    box_replace
    // box_storage/contract.py:382
    // self.dynamic_box.resize(2 + arr_len * 8)
    intc_2 // 8
    *
    intc_0 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    box_resize
    // box_storage/contract.py:384
    // return self.dynamic_box.value.length
    bytec_2 // "dynamic_box"
    intc_3 // 0
    intc_0 // 2
    box_extract
    btoi
    // box_storage/contract.py:375
    // @arc4.abimethod
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.sum_dynamic_box[routing]() -> void:
sum_dynamic_box:
    // box_storage/contract.py:388
    // total = UInt64()
    intc_3 // 0
    // box_storage/contract.py:389
    // for val in self.dynamic_box.value:
    bytec_2 // "dynamic_box"
    intc_3 // 0
    intc_0 // 2
    box_extract
    btoi
    intc_3 // 0

sum_dynamic_box_for_header@2:
    // box_storage/contract.py:389
    // for val in self.dynamic_box.value:
    dup
    dig 2
    <
    bz sum_dynamic_box_after_for@5
    dupn 2
    intc_2 // 8
    *
    intc_0 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    intc_2 // 8
    box_extract
    btoi
    // box_storage/contract.py:390
    // total += val
    dig 4
    +
    bury 4
    intc_1 // 1
    +
    bury 1
    b sum_dynamic_box_for_header@2

sum_dynamic_box_after_for@5:
    // box_storage/contract.py:386
    // @arc4.abimethod
    dig 2
    itob
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.write_dynamic_box[routing]() -> void:
write_dynamic_box:
    // box_storage/contract.py:393
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // box_storage/contract.py:395
    // self.dynamic_box.value[index] = value
    swap
    intc_2 // 8
    *
    intc_0 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:393
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.write_dynamic_arr_struct[routing]() -> void:
write_dynamic_arr_struct:
    // box_storage/contract.py:397
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // box_storage/contract.py:399
    // self.dynamic_arr_struct.value.arr[index] = value
    bytec_0 // "dynamic_arr_struct"
    pushint 20
    intc_0 // 2
    box_extract
    btoi
    dig 2
    >
    assert // index out of bounds
    swap
    intc_2 // 8
    *
    pushint 22
    +
    bytec_0 // "dynamic_arr_struct"
    swap
    uncover 2
    box_replace
    // box_storage/contract.py:397
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.slice_box[routing]() -> void:
slice_box:
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 15 // "0"
    // box_storage/contract.py:404
    // box_0.value = Bytes(b"Testing testing 123")
    box_del
    pop
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 15 // "0"
    // box_storage/contract.py:404
    // box_0.value = Bytes(b"Testing testing 123")
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 15 // "0"
    // box_storage/contract.py:405
    // assert box_0.value[0:7] == b"Testing"
    intc_3 // 0
    pushint 7
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    // box_storage/contract.py:407
    // self.box_c.value = arc4.String("Hello")
    bytec 4 // 0x424f585f43
    box_del
    pop
    bytec 4 // 0x424f585f43
    pushbytes 0x000548656c6c6f
    box_put
    // box_storage/contract.py:408
    // assert self.box_c.value.bytes[2:10] == b"Hello"
    bytec 4 // 0x424f585f43
    intc_0 // 2
    pushint 5
    box_extract
    pushbytes 0x48656c6c6f
    ==
    assert
    // box_storage/contract.py:401
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.test_box_ref[routing]() -> void:
test_box_ref:
    // box_storage/contract.py:422-423
    // # init ref, with valid key types
    // box_ref = Box(Bytes, key="blob")
    bytec 5 // "blob"
    // box_storage/contract.py:424
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:432-433
    // # create
    // assert box_ref.create(size=UInt64(32))
    pushint 32
    box_create
    assert
    // box_storage/contract.py:436-437
    // # manipulate data
    // sender_bytes = Txn.sender.bytes
    txn Sender
    // box_storage/contract.py:438
    // app_address = Global.current_application_address.bytes
    global CurrentApplicationAddress
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:440
    // box_ref.replace(0, sender_bytes)
    intc_3 // 0
    dig 3
    box_replace
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:441
    // box_ref.resize(8000)
    pushint 8000
    box_resize
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:442
    // box_ref.splice(0, 0, app_address)
    intc_3 // 0
    dup
    dig 3
    box_splice
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:443
    // box_ref.replace(64, value_3)
    pushint 64
    // box_storage/contract.py:439
    // value_3 = Bytes(b"hello")
    bytec 16 // 0x68656c6c6f
    // box_storage/contract.py:443
    // box_ref.replace(64, value_3)
    box_replace
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:444
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    intc_3 // 0
    pushint 69
    box_extract
    // box_storage/contract.py:445
    // assert prefix == app_address + sender_bytes + value_3
    dig 1
    dig 3
    concat
    // box_storage/contract.py:439
    // value_3 = Bytes(b"hello")
    bytec 16 // 0x68656c6c6f
    // box_storage/contract.py:445
    // assert prefix == app_address + sender_bytes + value_3
    concat
    ==
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:447-448
    // # delete
    // del box_ref.value
    box_del
    pop
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:451-452
    // # query
    // value, exists = box_ref.maybe()
    box_get
    // box_storage/contract.py:453
    // assert not exists
    dup
    !
    assert
    // box_storage/contract.py:454
    // assert value == b""
    dig 1
    pushbytes 0x
    ==
    assert
    // box_storage/contract.py:455
    // assert box_ref.get(default=sender_bytes) == sender_bytes
    dig 3
    cover 2
    select
    dig 2
    ==
    assert
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    concat
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    box_del
    pop
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    swap
    box_put
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec 5 // "blob"
    // box_storage/contract.py:459
    // assert box_ref, "Blob exists"
    box_len
    pop
    // box_storage/contract.py:460
    // assert box_ref.length == 64
    pushint 64
    ==
    assert
    // box_storage/contract.py:463-464
    // # instance box ref
    // self.box_ref.create(size=UInt64(32))
    bytec 19 // "box_ref"
    pushint 32
    box_create
    pop
    // box_storage/contract.py:466
    // del self.box_ref.value
    bytec 19 // "box_ref"
    box_del
    pop
    // box_storage/contract.py:420
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_test[routing]() -> void:
box_map_test:
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_3 // 0
    // box_storage/contract.py:473
    // self.box_map[key_0] = value
    itob
    dup
    box_del
    pop
    // box_storage/contract.py:472
    // value = String("Hmmmmm")
    pushbytes "Hmmmmm"
    // box_storage/contract.py:473
    // self.box_map[key_0] = value
    box_put
    // box_storage/contract.py:471
    // key_1 = UInt64(1)
    intc_1 // 1
    // box_storage/contract.py:480
    // assert self.box_map.get(key_1, default=String("default")) == String("default")
    itob
    dup
    box_get
    bytec 20 // "default"
    cover 2
    select
    bytec 20 // "default"
    ==
    assert
    // box_storage/contract.py:481
    // value, exists = self.box_map.maybe(key_1)
    dup
    box_len
    bury 1
    // box_storage/contract.py:482
    // assert not exists
    !
    assert
    // box_storage/contract.py:488
    // tmp_box_map[key_1] = String("hello")
    dup
    box_del
    pop
    dup
    bytec 16 // "hello"
    box_put
    // box_storage/contract.py:490
    // del tmp_box_map[key_1]
    box_del
    pop
    // box_storage/contract.py:468
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_set[routing]() -> void:
box_map_set:
    // box_storage/contract.py:492
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // box_storage/contract.py:494
    // self.box_map[key] = value
    swap
    itob
    dup
    box_del
    pop
    swap
    box_put
    // box_storage/contract.py:492
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_get[routing]() -> void:
box_map_get:
    // box_storage/contract.py:496
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:498
    // return self.box_map[key]
    itob
    box_get
    assert // check self.box_map entry exists
    // box_storage/contract.py:496
    // @arc4.abimethod
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_del[routing]() -> void:
box_map_del:
    // box_storage/contract.py:500
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:502
    // del self.box_map[key]
    itob
    box_del
    pop
    // box_storage/contract.py:500
    // @arc4.abimethod
    intc_1 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_exists[routing]() -> void:
box_map_exists:
    // box_storage/contract.py:504
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // box_storage/contract.py:506
    // return key in self.box_map
    itob
    box_len
    bury 1
    // box_storage/contract.py:504
    // @arc4.abimethod
    pushbytes 0x00
    intc_3 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
