#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 2 8 0 4098 4096 5000 4138
    bytecblock "box" "dynamic_arr_struct" 0x151f7c75 0x424f585f43 "blob" "dynamic_box" "box_large" "box_a" "box_d" "b" "too_many_bools" "big_bytes" "many_ints" "big_fixed_bytes" 0x68656c6c6f "0" 0x00023432 "default" "box_ref" 0x0014 0x068101
    intc_3 // 0
    dupn 3
    pushbytes ""
    dupn 20
    txn NumAppArgs
    bz main___algopy_default_create@52
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x7d37296e 0x33325d3d 0x0199408d 0x772059ca 0xaa68d894 0x9b01ee56 0x1d6f6daf 0x2641daed 0x50c22157 0x9d52ee88 0x9fabe74e 0xf09069ae 0x01263df6 0xd566c632 0xfabcb885 0xa6174812 0xf13dd937 0x5ab60f2e 0xf07a0064 0x78f9af3f 0x5cbb9dcc 0x996497ae 0x6cec72ff 0x6f9d1075 0x0d22b441 0x59ef3760 0xaa666b96 0xdfbdd636 0x41427cd1 0x2a141f6c 0x7e843744 0x25600b57 0x29ea595d 0x11453152 0xced1221e 0x04ef4971 0x23ecb32c 0xeef75816 0xb532913a 0xc29f1669 0x9c888c09 0xe6f68506 0x8ee2c364 // method "set_boxes(uint64,byte[],string)void", method "check_keys()void", method "create_many_ints()void", method "set_many_ints(uint64,uint64)void", method "create_big_fixed_bytes()void", method "update_big_fixed_bytes(uint64,byte[])void", method "assert_big_fixed_bytes(uint64,byte[])void", method "slice_big_fixed_bytes(uint64,uint64)byte[]", method "create_big_bytes(uint64)void", method "update_big_bytes(uint64,byte[])void", method "assert_big_bytes(uint64,byte[])void", method "slice_big_bytes(uint64,uint64)byte[]", method "sum_many_ints()uint64", method "delete_boxes()void", method "indirect_extract_and_replace()void", method "read_boxes()(uint64,byte[],string,uint64)", method "boxes_exist()(bool,bool,bool,bool)", method "create_dynamic_arr_struct()void", method "delete_dynamic_arr_struct()void", method "append_dynamic_arr_struct(uint64)uint64", method "pop_dynamic_arr_struct(uint64)uint64", method "set_nested_struct((uint64,(uint64,uint64[][],uint64),(uint64,uint64[][],uint64)[],uint64))void", method "nested_write(uint64,uint64)void", method "nested_read(uint64,uint64,uint64)uint64", method "sum_dynamic_arr_struct()uint64", method "create_bools()void", method "set_bool(uint64,bool)void", method "sum_bools(uint64)uint64", method "create_dynamic_box()void", method "delete_dynamic_box()void", method "append_dynamic_box(uint64)uint64", method "pop_dynamic_box(uint64)uint64", method "sum_dynamic_box()uint64", method "write_dynamic_box(uint64,uint64)void", method "write_dynamic_arr_struct(uint64,uint64)void", method "slice_box()void", method "arc4_box()void", method "test_box_ref()void", method "box_map_test()void", method "box_map_set(uint64,string)void", method "box_map_get(uint64)string", method "box_map_del(uint64)void", method "box_map_exists(uint64)bool"
    txna ApplicationArgs 0
    match main_set_boxes_route@6 main_check_keys_route@7 main_create_many_ints_route@8 main_set_many_ints_route@9 main_create_big_fixed_bytes_route@10 main_update_big_fixed_bytes_route@11 main_assert_big_fixed_bytes_route@12 main_slice_big_fixed_bytes_route@13 main_create_big_bytes_route@14 main_update_big_bytes_route@15 main_assert_big_bytes_route@16 main_slice_big_bytes_route@17 main_while_top@167 main_delete_boxes_route@19 main_indirect_extract_and_replace_route@20 main_read_boxes_route@21 main_boxes_exist_route@22 main_create_dynamic_arr_struct_route@23 main_delete_dynamic_arr_struct_route@24 main_append_dynamic_arr_struct_route@25 main_pop_dynamic_arr_struct_route@26 main_set_nested_struct_route@27 main_nested_write_route@28 main_nested_read_route@29 main_sum_dynamic_arr_struct_route@30 main_create_bools_route@31 main_set_bool_route@32 main_sum_bools_route@33 main_create_dynamic_box_route@34 main_delete_dynamic_box_route@35 main_append_dynamic_box_route@36 main_pop_dynamic_box_route@37 main_sum_dynamic_box_route@38 main_write_dynamic_box_route@39 main_write_dynamic_arr_struct_route@40 main_slice_box_route@41 main_arc4_box_route@42 main_test_box_ref_route@43 main_box_map_test_route@44 main_box_map_set_route@45 main_box_map_get_route@46 main_box_map_del_route@47 main_box_map_exists_route@48
    err

main_box_map_exists_route@48:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    itob
    box_len
    bury 1
    pushbytes 0x00
    intc_3 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_del_route@47:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    itob
    box_del
    pop
    intc_0 // 1
    return

main_box_map_get_route@46:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    itob
    box_get
    assert // check self.box_map entry exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_set_route@45:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    swap
    itob
    dup
    box_del
    pop
    swap
    box_put
    intc_0 // 1
    return

main_box_map_test_route@44:
    intc_3 // 0
    itob
    dup
    box_del
    pop
    pushbytes "Hmmmmm"
    box_put
    intc_0 // 1
    itob
    dup
    box_get
    bytec 17 // "default"
    cover 2
    select
    bytec 17 // "default"
    ==
    assert
    dup
    box_len
    bury 1
    !
    assert
    dup
    box_del
    pop
    dup
    bytec 14 // "hello"
    box_put
    box_del
    pop
    intc_0 // 1
    return

main_test_box_ref_route@43:
    bytec 4 // "blob"
    box_len
    bury 1
    !
    assert // no data
    bytec 4 // "blob"
    pushint 32
    box_create
    assert
    txn Sender
    global CurrentApplicationAddress
    bytec 4 // "blob"
    intc_3 // 0
    dig 3
    box_replace
    bytec 4 // "blob"
    pushint 8000
    box_resize
    bytec 4 // "blob"
    intc_3 // 0
    dup
    dig 3
    box_splice
    bytec 4 // "blob"
    pushint 64
    bytec 14 // 0x68656c6c6f
    box_replace
    bytec 4 // "blob"
    intc_3 // 0
    pushint 69
    box_extract
    dig 1
    dig 3
    concat
    bytec 14 // 0x68656c6c6f
    concat
    ==
    assert
    bytec 4 // "blob"
    box_del
    pop
    bytec 4 // "blob"
    box_get
    dup
    !
    assert
    dig 1
    pushbytes 0x
    ==
    assert
    dig 3
    cover 2
    select
    dig 2
    ==
    assert
    concat
    bytec 4 // "blob"
    box_del
    pop
    bytec 4 // "blob"
    swap
    box_put
    bytec 4 // "blob"
    box_len
    pop
    pushint 64
    ==
    assert
    bytec 18 // "box_ref"
    pushint 32
    box_create
    pop
    bytec 18 // "box_ref"
    box_del
    pop
    intc_0 // 1
    return

main_arc4_box_route@42:
    pushbytess 0x64 0x00010203
    box_put
    intc_0 // 1
    return

main_slice_box_route@41:
    bytec 15 // "0"
    box_del
    pop
    bytec 15 // "0"
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    bytec 15 // "0"
    intc_3 // 0
    pushint 7
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    bytec_3 // 0x424f585f43
    box_del
    pop
    bytec_3 // 0x424f585f43
    pushbytes 0x000548656c6c6f
    box_put
    bytec_3 // 0x424f585f43
    intc_1 // 2
    pushint 5
    box_extract
    pushbytes 0x48656c6c6f
    ==
    assert
    intc_0 // 1
    return

main_write_dynamic_arr_struct_route@40:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_1 // 2
    box_extract
    btoi
    dig 2
    >
    assert // index out of bounds
    swap
    intc_2 // 8
    *
    pushint 22
    +
    bytec_1 // "dynamic_arr_struct"
    swap
    uncover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_write_dynamic_box_route@39:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    swap
    intc_2 // 8
    *
    intc_1 // 2
    +
    bytec 5 // "dynamic_box"
    swap
    uncover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_sum_dynamic_box_route@38:
    intc_3 // 0
    bury 2
    bytec 5 // "dynamic_box"
    intc_3 // 0
    intc_1 // 2
    box_extract
    btoi
    bury 16
    intc_3 // 0
    bury 9

main_for_header@76:
    dig 8
    dig 16
    <
    bz main_after_for@78
    dig 8
    dup
    intc_2 // 8
    *
    intc_1 // 2
    +
    bytec 5 // "dynamic_box"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dig 3
    +
    bury 3
    intc_0 // 1
    +
    bury 9
    b main_for_header@76

main_after_for@78:
    dig 1
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_pop_dynamic_box_route@37:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 3
    intc_3 // 0
    bury 21

main_for_header@81:
    dig 20
    dig 3
    <
    bz main_after_for@83
    bytec 5 // "dynamic_box"
    intc_3 // 0
    intc_2 // 8
    callsub box_dynamic_array_pop_fixed_size
    dig 20
    intc_0 // 1
    +
    bury 21
    b main_for_header@81

main_after_for@83:
    bytec 5 // "dynamic_box"
    intc_3 // 0
    intc_1 // 2
    box_extract
    btoi
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_append_dynamic_box_route@36:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 3
    intc_3 // 0
    bury 13

main_for_header@86:
    dig 12
    dig 3
    <
    bz main_after_for@88
    dig 12
    dup
    itob
    bytec 5 // "dynamic_box"
    intc_3 // 0
    uncover 2
    intc_0 // 1
    intc_2 // 8
    callsub box_dynamic_array_concat_fixed
    intc_0 // 1
    +
    bury 13
    b main_for_header@86

main_after_for@88:
    bytec 5 // "dynamic_box"
    intc_3 // 0
    intc_1 // 2
    box_extract
    btoi
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_dynamic_box_route@35:
    bytec 5 // "dynamic_box"
    box_del
    pop
    intc_0 // 1
    return

main_create_dynamic_box_route@34:
    bytec 5 // "dynamic_box"
    box_del
    pop
    bytec 5 // "dynamic_box"
    pushbytes 0x0000
    box_put
    intc_0 // 1
    return

main_sum_bools_route@33:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 4
    intc_3 // 0
    bury 2
    bytec 10 // "too_many_bools"
    box_len
    bury 1
    assert // check self.too_many_bools exists
    intc_3 // 0
    bury 9

main_for_header@95:
    dig 8
    pushint 33000
    <
    bz main_after_for@101
    dig 8
    dup
    intc_2 // 8
    /
    swap
    intc_2 // 8
    %
    bytec 10 // "too_many_bools"
    uncover 2
    intc_0 // 1
    box_extract // on error: index out of bounds
    swap
    getbit
    bz main_after_if_else@98
    dig 1
    intc_0 // 1
    +
    bury 2

main_after_if_else@98:
    dig 1
    dig 4
    ==
    bnz main_after_for@101
    dig 8
    intc_0 // 1
    +
    bury 9
    b main_for_header@95

main_after_for@101:
    dig 1
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_set_bool_route@32:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_3 // 0
    getbit
    dig 1
    intc_2 // 8
    /
    uncover 2
    intc_2 // 8
    %
    bytec 10 // "too_many_bools"
    dig 2
    intc_0 // 1
    box_extract
    dig 1
    intc_2 // 8
    <
    assert // index access is out of bounds
    swap
    uncover 3
    setbit
    bytec 10 // "too_many_bools"
    cover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_create_bools_route@31:
    bytec 10 // "too_many_bools"
    pushint 4125
    box_create
    pop
    intc_0 // 1
    return

main_sum_dynamic_arr_struct_route@30:
    bytec_1 // "dynamic_arr_struct"
    intc_3 // 0
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dup
    intc_0 // 1
    ==
    assert // expected 1
    bytec_1 // "dynamic_arr_struct"
    pushint 10
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dup
    intc_1 // 2
    ==
    assert // expected 2
    +
    bury 2
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_1 // 2
    box_extract
    btoi
    bury 15
    intc_3 // 0
    bury 9

main_for_header@108:
    dig 8
    dig 15
    <
    bz main_after_for@110
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_1 // 2
    box_extract
    btoi
    dig 9
    dup
    uncover 2
    <
    assert // index out of bounds
    dup
    intc_2 // 8
    *
    pushint 22
    +
    bytec_1 // "dynamic_arr_struct"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dig 3
    +
    bury 3
    intc_0 // 1
    +
    bury 9
    b main_for_header@108

main_after_for@110:
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    intc_1 // 2
    box_extract
    btoi
    bytec_1 // "dynamic_arr_struct"
    swap
    intc_1 // 2
    box_extract
    btoi
    bury 14
    intc_3 // 0
    bury 8

main_for_header@111:
    dig 7
    dig 14
    <
    bz main_after_for@113
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    intc_1 // 2
    box_extract
    btoi
    intc_1 // 2
    +
    dig 8
    dup
    cover 2
    intc_2 // 8
    *
    +
    bytec_1 // "dynamic_arr_struct"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dig 3
    +
    bury 3
    intc_0 // 1
    +
    bury 8
    b main_for_header@111

main_after_for@113:
    dig 1
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_nested_read_route@29:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bytec_0 // "box"
    intc 4 // 4098
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    bytec_0 // "box"
    pushint 4110
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    bytec_0 // "box"
    pushint 4136
    intc_1 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_1 // 2
    dig 5
    *
    intc 7 // 4138
    dig 1
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    intc 7 // 4138
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 6
    >
    assert // index out of bounds
    intc_1 // 2
    +
    dig 5
    intc_2 // 8
    *
    +
    bytec_0 // "box"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    bytec_0 // "box"
    pushint 4118
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    bytec_0 // "box"
    pushint 4128
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    bytec_0 // "box"
    pushint 4108
    intc_1 // 2
    box_extract
    btoi
    intc 4 // 4098
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    uncover 10
    >
    assert // index out of bounds
    intc_1 // 2
    +
    dup
    uncover 5
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 8
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    uncover 8
    *
    dig 1
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 7
    >
    assert // index out of bounds
    intc_1 // 2
    +
    uncover 6
    intc_2 // 8
    *
    +
    bytec_0 // "box"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    uncover 5
    uncover 5
    +
    uncover 4
    +
    uncover 3
    +
    uncover 2
    +
    +
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_nested_write_route@28:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    dup
    btoi
    bytec_0 // "box"
    intc 4 // 4098
    uncover 3
    box_replace // on error: index out of bounds
    dup
    intc_0 // 1
    +
    itob
    bytec_0 // "box"
    pushint 4110
    uncover 2
    box_replace // on error: index out of bounds
    dup
    intc_1 // 2
    +
    itob
    bytec_0 // "box"
    pushint 4136
    intc_1 // 2
    box_extract
    btoi
    dig 3
    >
    assert // index out of bounds
    intc_1 // 2
    dig 3
    *
    intc 7 // 4138
    dig 1
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    intc 7 // 4138
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_1 // 2
    +
    dig 4
    intc_2 // 8
    *
    swap
    dig 1
    +
    bytec_0 // "box"
    swap
    uncover 4
    box_replace // on error: index out of bounds
    dig 2
    pushint 3
    +
    itob
    bytec_0 // "box"
    pushint 4118
    uncover 2
    box_replace // on error: index out of bounds
    dig 2
    pushint 4
    +
    itob
    bytec_0 // "box"
    pushint 4128
    uncover 2
    box_replace // on error: index out of bounds
    uncover 2
    pushint 5
    +
    itob
    bytec_0 // "box"
    pushint 4108
    intc_1 // 2
    box_extract
    btoi
    intc 4 // 4098
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_1 // 2
    +
    dup
    dig 4
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    dig 5
    >
    assert // index out of bounds
    intc_1 // 2
    +
    dup
    uncover 4
    +
    bytec_0 // "box"
    swap
    intc_1 // 2
    box_extract
    btoi
    +
    bytec_0 // "box"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    uncover 4
    >
    assert // index out of bounds
    intc_1 // 2
    +
    uncover 2
    +
    bytec_0 // "box"
    swap
    uncover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_set_nested_struct_route@27:
    txna ApplicationArgs 1
    dup
    bury 23
    dup
    len
    dup
    cover 2
    bury 3
    dup
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 20
    ==
    assert // invalid tail pointer at index 1 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    uncover 2
    substring3
    dup
    len
    dig 1
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    swap
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 21
    intc_1 // 2
    *
    bury 8
    extract 2 0
    bury 25
    intc_3 // 0
    bury 12

main_for_header@120:
    dig 11
    dig 19
    <
    bz main_after_for@122
    dig 11
    dup
    intc_1 // 2
    *
    dig 26
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 10
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 8
    *
    intc_1 // 2
    +
    +
    bury 8
    intc_0 // 1
    +
    bury 12
    b main_for_header@120

main_after_for@122:
    dig 6
    pushint 40
    +
    dup
    bury 21
    dig 22
    dup
    cover 2
    pushint 10
    extract_uint16 // on error: invalid tuple encoding
    dup
    uncover 2
    ==
    assert // invalid tail pointer at index 2 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    dig 2
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 20
    intc_1 // 2
    *
    bury 7
    extract 2 0
    bury 24
    intc_3 // 0
    bury 11

main_for_header@123:
    dig 10
    dig 18
    <
    bz main_after_for@128
    dig 10
    intc_1 // 2
    *
    dig 24
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 8
    ==
    assert // invalid tail pointer for (len+(uint64,(len+(len+uint64[])[]),uint64)[])
    dig 1
    len
    substring3
    dup
    len
    dig 1
    intc_2 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    swap
    substring3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 19
    intc_1 // 2
    *
    bury 6
    extract 2 0
    bury 23
    intc_3 // 0
    bury 10

main_for_header@125:
    dig 9
    dig 17
    <
    bz main_after_for@127
    dig 9
    dup
    intc_1 // 2
    *
    dig 24
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 8
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 8
    *
    intc_1 // 2
    +
    +
    bury 6
    intc_0 // 1
    +
    bury 10
    b main_for_header@125

main_after_for@127:
    dig 4
    pushint 20
    +
    dig 6
    +
    bury 6
    dig 10
    intc_0 // 1
    +
    bury 11
    b main_for_header@123

main_after_for@128:
    dig 5
    intc_1 // 2
    +
    dig 20
    +
    dig 1
    ==
    assert // invalid number of bytes for examples.box_storage.contract.NestedStruct
    dig 21
    intc_3 // 0
    extract_uint64
    assert // struct.a is truthy
    txna ApplicationArgs 1
    dup
    len
    intc 4 // 4098
    +
    bytec_0 // "box"
    swap
    box_create
    pop
    bytec_0 // "box"
    intc 5 // 4096
    pushbytes 0x1002
    box_replace
    bytec_0 // "box"
    intc 4 // 4098
    uncover 2
    box_replace
    intc_0 // 1
    return

main_pop_dynamic_arr_struct_route@26:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 3
    intc_3 // 0
    bury 21

main_for_header@131:
    dig 20
    dig 3
    <
    bz main_after_for@133
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    intc_1 // 2
    box_extract
    btoi
    intc_2 // 8
    -
    itob
    extract 6 2
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    uncover 2
    box_replace
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_2 // 8
    callsub box_dynamic_array_pop_fixed_size
    dig 20
    intc_0 // 1
    +
    bury 21
    b main_for_header@131

main_after_for@133:
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_1 // 2
    box_extract
    btoi
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_append_dynamic_arr_struct_route@25:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bury 3
    intc_3 // 0
    bury 13

main_for_header@136:
    dig 12
    dig 3
    <
    bz main_after_for@138
    dig 12
    dup
    itob
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    intc_1 // 2
    box_extract
    btoi
    intc_2 // 8
    +
    itob
    extract 6 2
    bytec_1 // "dynamic_arr_struct"
    pushint 18
    uncover 2
    box_replace
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    uncover 2
    intc_0 // 1
    intc_2 // 8
    callsub box_dynamic_array_concat_fixed
    intc_0 // 1
    +
    bury 13
    b main_for_header@136

main_after_for@138:
    bytec_1 // "dynamic_arr_struct"
    pushint 20
    intc_1 // 2
    box_extract
    btoi
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_dynamic_arr_struct_route@24:
    bytec_1 // "dynamic_arr_struct"
    box_del
    pop
    intc_0 // 1
    return

main_create_dynamic_arr_struct_route@23:
    txn NumAppArgs
    dup
    intc_1 // 2
    *
    swap
    itob
    bytec 19 // 0x0014
    concat
    swap
    itob
    concat
    pushbytes 0x001600000000
    concat
    bytec_1 // "dynamic_arr_struct"
    box_del
    pop
    bytec_1 // "dynamic_arr_struct"
    swap
    box_put
    intc_0 // 1
    return

main_boxes_exist_route@22:
    bytec 7 // "box_a"
    box_len
    bury 1
    bytec 9 // "b"
    box_len
    cover 2
    pop
    bytec_3 // 0x424f585f43
    box_len
    cover 3
    pop
    bytec 6 // "box_large"
    box_len
    cover 4
    pop
    pushbytes 0x00
    intc_3 // 0
    uncover 2
    setbit
    intc_0 // 1
    uncover 2
    setbit
    intc_1 // 2
    uncover 2
    setbit
    pushint 3
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_boxes_route@21:
    bytec 7 // "box_a"
    box_get
    assert // check Box exists
    btoi
    intc_0 // 1
    +
    intc_0 // 1
    -
    bytec 9 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    bytec_3 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    bytec 6 // "box_large"
    intc 5 // 4096
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    uncover 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    bytec 19 // 0x0014
    concat
    dig 1
    len
    pushint 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    itob
    concat
    swap
    concat
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_indirect_extract_and_replace_route@20:
    bytec 6 // "box_large"
    intc 5 // 4096
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    intc_0 // 1
    +
    itob
    bytec 6 // "box_large"
    intc 5 // 4096
    uncover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_delete_boxes_route@19:
    bytec 7 // "box_a"
    box_del
    pop
    bytec 9 // "b"
    box_del
    pop
    bytec_3 // 0x424f585f43
    box_del
    pop
    bytec 7 // "box_a"
    box_get
    swap
    btoi
    pushint 42
    dig 1
    dig 3
    select
    pushint 42
    ==
    assert
    bytec 9 // "b"
    box_get
    bytec 16 // 0x00023432
    cover 2
    select
    extract 2 0
    pushbytes 0x3432
    ==
    assert
    bytec_3 // 0x424f585f43
    box_get
    bytec 16 // 0x00023432
    cover 2
    select
    bytec 16 // 0x00023432
    ==
    assert
    swap
    !
    assert
    !
    assert
    bytec 6 // "box_large"
    box_del
    pop
    intc_0 // 1
    return

main_while_top@167:
    pushint 10510
    global OpcodeBudget
    >
    bz main_after_while@172
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 20 // 0x068101
    itxn_field ApprovalProgram
    bytec 20 // 0x068101
    itxn_field ClearStateProgram
    intc_3 // 0
    itxn_field Fee
    itxn_submit
    b main_while_top@167

main_after_while@172:
    intc_3 // 0
    bury 2
    bytec 12 // "many_ints"
    box_len
    bury 1
    assert // check self.many_ints exists
    intc_3 // 0
    bury 9

main_for_header@153:
    dig 8
    pushint 513
    <
    bz main_after_for@155
    dig 8
    dup
    intc_2 // 8
    *
    bytec 12 // "many_ints"
    swap
    intc_2 // 8
    box_extract // on error: index out of bounds
    btoi
    dig 3
    +
    bury 3
    intc_0 // 1
    +
    bury 9
    b main_for_header@153

main_after_for@155:
    dig 1
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_slice_big_bytes_route@17:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bytec 11 // "big_bytes"
    box_len
    pop
    dig 2
    dig 1
    >=
    uncover 3
    dig 2
    uncover 2
    select
    dig 2
    dig 2
    >=
    swap
    cover 3
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    dig 1
    -
    bytec 11 // "big_bytes"
    cover 2
    box_extract
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_assert_big_bytes_route@16:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    bytec 11 // "big_bytes"
    uncover 2
    intc_0 // 1
    box_extract
    ==
    assert
    intc_0 // 1
    return

main_update_big_bytes_route@15:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    len
    bytec 11 // "big_bytes"
    cover 3
    swap
    box_splice
    intc_0 // 1
    return

main_create_big_bytes_route@14:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    bytec 11 // "big_bytes"
    swap
    box_create
    pop
    intc_0 // 1
    return

main_slice_big_fixed_bytes_route@13:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dig 1
    intc 6 // 5000
    >=
    uncover 2
    intc 6 // 5000
    uncover 2
    select
    dig 1
    intc 6 // 5000
    >=
    uncover 2
    intc 6 // 5000
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    dig 1
    -
    bytec 13 // "big_fixed_bytes"
    cover 2
    box_extract
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_assert_big_fixed_bytes_route@12:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    bytec 13 // "big_fixed_bytes"
    uncover 2
    intc_0 // 1
    box_extract
    ==
    assert
    intc_0 // 1
    return

main_update_big_fixed_bytes_route@11:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    dup
    len
    bytec 13 // "big_fixed_bytes"
    cover 3
    swap
    box_splice
    intc_0 // 1
    return

main_create_big_fixed_bytes_route@10:
    bytec 13 // "big_fixed_bytes"
    intc 6 // 5000
    box_create
    pop
    intc_0 // 1
    return

main_set_many_ints_route@9:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    swap
    intc_2 // 8
    *
    bytec 12 // "many_ints"
    swap
    uncover 2
    box_replace // on error: index out of bounds
    intc_0 // 1
    return

main_create_many_ints_route@8:
    bytec 12 // "many_ints"
    pushint 4104
    box_create
    pop
    intc_0 // 1
    return

main_check_keys_route@7:
    intc_0 // 1
    return

main_set_boxes_route@6:
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_3 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    uncover 4
    itob
    bytec 7 // "box_a"
    swap
    box_put
    bytec 9 // "b"
    box_del
    pop
    bytec 9 // "b"
    dig 4
    box_put
    bytec_3 // 0x424f585f43
    box_del
    pop
    bytec_3 // 0x424f585f43
    dig 2
    box_put
    dig 3
    extract 2 0
    bytec 8 // "box_d"
    box_del
    pop
    bytec 8 // "box_d"
    dig 1
    box_put
    bytec 6 // "box_large"
    pushint 6160
    box_create
    pop
    pushint 42
    itob
    bytec 6 // "box_large"
    intc 5 // 4096
    uncover 2
    box_replace // on error: index out of bounds
    bytec 6 // "box_large"
    intc 5 // 4096
    pushbytes 0x000000000000002a
    box_replace
    bytec 7 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3
    +
    itob
    bytec 7 // "box_a"
    swap
    box_put
    bytec 7 // "box_a"
    box_len
    pop
    intc_2 // 8
    ==
    assert
    bytec 9 // "b"
    box_len
    pop
    uncover 4
    ==
    assert
    bytec_3 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    dup
    dig 3
    ==
    assert
    bytec 8 // "box_d"
    box_len
    pop
    dig 2
    len
    dup2
    ==
    assert
    bytec_3 // 0x424f585f43
    intc_3 // 0
    intc_0 // 1
    box_extract
    dig 6
    extract 0 1
    ==
    assert
    dig 2
    intc_0 // 1
    -
    bytec_3 // 0x424f585f43
    swap
    intc_0 // 1
    box_extract
    dig 5
    intc_0 // 1
    -
    dig 7
    swap
    intc_0 // 1
    extract3
    ==
    assert
    intc_0 // 1
    dig 3
    >=
    intc_0 // 1
    dig 4
    uncover 2
    select
    dig 3
    swap
    -
    bytec_3 // 0x424f585f43
    intc_3 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 6
    >=
    intc_0 // 1
    dig 7
    uncover 2
    select
    dig 6
    swap
    -
    dig 7
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    intc_1 // 2
    dig 3
    >=
    intc_1 // 2
    uncover 4
    uncover 2
    select
    bytec_3 // 0x424f585f43
    intc_3 // 0
    uncover 2
    box_extract
    intc_1 // 2
    dig 5
    >=
    intc_1 // 2
    uncover 6
    uncover 2
    select
    uncover 5
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    bytec 8 // "box_d"
    intc_3 // 0
    intc_0 // 1
    box_extract
    uncover 4
    extract 2 1
    ==
    assert
    dig 1
    intc_0 // 1
    -
    bytec 8 // "box_d"
    swap
    intc_0 // 1
    box_extract
    dig 1
    intc_0 // 1
    -
    dig 4
    swap
    intc_0 // 1
    extract3
    ==
    assert
    intc_0 // 1
    dig 2
    >=
    intc_0 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 2
    >=
    intc_0 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    dig 4
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    pushint 5
    dig 2
    >=
    pushint 5
    dig 3
    uncover 2
    select
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    pushint 5
    dig 2
    >=
    pushint 5
    dig 3
    uncover 2
    select
    dig 4
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    intc_1 // 2
    dig 2
    >=
    intc_1 // 2
    uncover 3
    uncover 2
    select
    bytec 8 // "box_d"
    intc_3 // 0
    uncover 2
    box_extract
    intc_1 // 2
    dig 2
    >=
    intc_1 // 2
    uncover 3
    uncover 2
    select
    uncover 2
    intc_3 // 0
    uncover 2
    substring3
    ==
    assert
    bytec 6 // "box_large"
    box_len
    pop
    pushint 6160
    ==
    assert
    intc_0 // 1
    return

main___algopy_default_create@52:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// _puya_lib.box_arc4.box_dynamic_array_pop_fixed_size(box_key: bytes, array_offset: uint64, fixed_byte_size: uint64) -> void:
box_dynamic_array_pop_fixed_size:
    proto 3 0
    frame_dig -3
    frame_dig -2
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 1
    -
    dup
    itob
    extract 6 2
    frame_dig -3
    frame_dig -2
    uncover 2
    box_replace
    frame_dig -2
    intc_1 // 2
    +
    swap
    frame_dig -1
    *
    +
    frame_dig -3
    swap
    frame_dig -1
    pushbytes 0x
    box_splice
    frame_dig -3
    box_len
    pop
    frame_dig -1
    -
    frame_dig -3
    swap
    box_resize
    retsub


// _puya_lib.box_arc4.box_dynamic_array_concat_fixed(box_key: bytes, array_offset: uint64, new_items_bytes: bytes, new_items_count: uint64, fixed_element_size: uint64) -> void:
box_dynamic_array_concat_fixed:
    proto 5 0
    frame_dig -5
    frame_dig -4
    intc_1 // 2
    box_extract
    btoi
    frame_dig -5
    box_len
    pop
    frame_dig -2
    frame_dig -1
    *
    +
    frame_dig -5
    swap
    box_resize
    dup
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig -5
    frame_dig -4
    uncover 2
    box_replace
    frame_dig -4
    intc_1 // 2
    +
    swap
    frame_dig -1
    *
    +
    frame_dig -5
    swap
    intc_3 // 0
    frame_dig -3
    box_splice
    retsub
