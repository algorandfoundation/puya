#pragma version 10
#pragma typetrack false

// examples.box_storage.contract.BoxContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 8 4096
    bytecblock 0x424f585f43 0x626c6f62 "dynamic_box" "box_d" "b" "box_large" 0x151f7c75 "box_a" "0" "many_ints" 0x68656c6c6f 0x00023432 "default" "box_ref" 0x068101
    pushbytes ""
    dupn 5
    txn NumAppArgs
    bz main_bare_routing@36
    pushbytess 0x7d37296e 0x33325d3d 0x0199408d 0x772059ca 0x01263df6 0xd566c632 0xfabcb885 0xa6174812 0xf13dd937 0x41427cd1 0x2a141f6c 0x7e843744 0x25600b57 0x29ea595d 0x04ef4971 0x23ecb32c 0xeef75816 0xb532913a 0xc29f1669 0x9c888c09 0xe6f68506 0x8ee2c364 // method "set_boxes(uint64,byte[],string)void", method "check_keys()void", method "create_many_ints()void", method "set_many_ints(uint64,uint64)void", method "sum_many_ints()uint64", method "delete_boxes()void", method "indirect_extract_and_replace()void", method "read_boxes()(uint64,byte[],string,uint64)", method "boxes_exist()(bool,bool,bool,bool)", method "create_dynamic_box()void", method "delete_dynamic_box()void", method "append_dynamic_box(uint64)uint64", method "pop_dynamic_box(uint64)uint64", method "sum_dynamic_box()uint64", method "slice_box()void", method "arc4_box()void", method "test_box_ref()void", method "box_map_test()void", method "box_map_set(uint64,string)void", method "box_map_get(uint64)string", method "box_map_del(uint64)void", method "box_map_exists(uint64)bool"
    txna ApplicationArgs 0
    match main_set_boxes_route@5 main_check_keys_route@6 main_create_many_ints_route@7 main_set_many_ints_route@8 main_sum_many_ints_route@9 main_delete_boxes_route@13 main_indirect_extract_and_replace_route@14 main_read_boxes_route@15 main_boxes_exist_route@16 main_create_dynamic_box_route@17 main_delete_dynamic_box_route@18 main_append_dynamic_box_route@19 main_pop_dynamic_box_route@23 main_sum_dynamic_box_route@24 main_slice_box_route@28 main_arc4_box_route@29 main_test_box_ref_route@30 main_box_map_test_route@31 main_box_map_set_route@32 main_box_map_get_route@33 main_box_map_del_route@34 main_box_map_exists_route@35

main_after_if_else@38:
    intc_1 // 0
    return

main_box_map_exists_route@35:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    itob
    box_len
    bury 1
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_del_route@34:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    itob
    box_del
    pop
    intc_0 // 1
    return

main_box_map_get_route@33:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    itob
    box_get
    assert // check self.box_map entry exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_box_map_set_route@32:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    swap
    itob
    dup
    box_del
    pop
    swap
    box_put
    intc_0 // 1
    return

main_box_map_test_route@31:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 0
    itob
    dup
    box_del
    pop
    dup
    pushbytes "Hmmmmm"
    box_put
    dup
    box_len
    pop
    pushint 6 // 6
    ==
    assert
    dup
    box_len
    pop
    swap
    dup
    box_len
    pop
    uncover 2
    ==
    assert
    box_len
    pop
    pushint 6 // 6
    ==
    assert
    intc_0 // 1
    itob
    dup
    box_get
    bytec 12 // "default"
    cover 2
    select
    bytec 12 // "default"
    ==
    assert
    dup
    box_len
    bury 1
    !
    assert
    dup
    box_del
    pop
    dup
    bytec 10 // "hello"
    box_put
    box_del
    pop
    intc_0 // 1
    return

main_test_box_ref_route@30:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_1 // "blob"
    box_len
    bury 1
    !
    assert // no data
    bytec_1 // 0x626c6f62
    box_len
    bury 1
    !
    assert // no data
    bytec_1 // 0x626c6f62
    box_len
    bury 1
    !
    assert // no data
    bytec_1 // "blob"
    box_len
    bury 1
    !
    assert // no data
    bytec_1 // "blob"
    pushint 32 // 32
    box_create
    assert
    txn Sender
    global CurrentApplicationAddress
    bytec_1 // "blob"
    intc_1 // 0
    dig 3
    box_replace
    bytec_1 // "blob"
    pushint 8000 // 8000
    box_resize
    bytec_1 // "blob"
    intc_1 // 0
    dup
    dig 3
    box_splice
    bytec_1 // "blob"
    pushint 64 // 64
    bytec 10 // 0x68656c6c6f
    box_replace
    bytec_1 // "blob"
    intc_1 // 0
    pushint 69 // 69
    box_extract
    dig 1
    dig 3
    concat
    bytec 10 // 0x68656c6c6f
    concat
    ==
    assert
    bytec_1 // "blob"
    box_del
    assert
    bytec_1 // "blob"
    box_get
    dup
    !
    assert
    dig 1
    pushbytes 0x
    ==
    assert
    dig 3
    cover 2
    select
    dig 2
    ==
    assert
    concat
    bytec_1 // "blob"
    swap
    box_put
    bytec_1 // "blob"
    box_len
    pop
    pushint 64 // 64
    ==
    assert
    bytec_1 // "blob"
    box_len
    pop
    pushint 64 // 64
    ==
    assert
    bytec 13 // "box_ref"
    pushint 32 // 32
    box_create
    pop
    bytec 13 // "box_ref"
    box_del
    pop
    intc_0 // 1
    return

main_arc4_box_route@29:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytess 0x64 0x00010203 // 0x64, 0x00010203
    box_put
    intc_0 // 1
    return

main_slice_box_route@28:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 8 // "0"
    box_del
    pop
    bytec 8 // "0"
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    bytec 8 // "0"
    box_len
    pop
    dup
    intc_1 // 0
    dig 2
    select
    pushint 7 // 7
    dig 2
    <
    uncover 2
    pushint 7 // 7
    uncover 2
    select
    dig 1
    -
    bytec 8 // "0"
    cover 2
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    bytec_0 // 0x424f585f43
    box_del
    pop
    bytec_0 // 0x424f585f43
    pushbytes 0x000548656c6c6f
    box_put
    bytec_0 // 0x424f585f43
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    dig 1
    intc_2 // 2
    uncover 2
    select
    pushint 10 // 10
    dig 2
    <
    uncover 2
    pushint 10 // 10
    uncover 2
    select
    dig 1
    -
    bytec_0 // 0x424f585f43
    cover 2
    box_extract
    pushbytes 0x48656c6c6f
    ==
    assert
    intc_0 // 1
    return

main_sum_dynamic_box_route@24:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 0
    bury 1
    bytec_2 // "dynamic_box"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    bury 5
    intc_1 // 0
    bury 3

main_for_header@25:
    dig 2
    dig 5
    <
    bz main_after_for@27
    dig 2
    dup
    intc_3 // 8
    *
    intc_2 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    intc_3 // 8
    box_extract
    btoi
    dig 2
    +
    bury 2
    intc_0 // 1
    +
    bury 3
    b main_for_header@25

main_after_for@27:
    dup
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_pop_dynamic_box_route@23:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    bytec_2 // "dynamic_box"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    swap
    -
    dup
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    bytec_2 // "dynamic_box"
    intc_1 // 0
    uncover 2
    box_replace
    intc_3 // 8
    *
    intc_2 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    box_resize
    bytec_2 // "dynamic_box"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_append_dynamic_box_route@19:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    dup
    bury 3
    bytec_2 // "dynamic_box"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    dup
    bury 8
    +
    intc_3 // 8
    *
    intc_2 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    box_resize
    intc_1 // 0
    bury 4

main_for_header@20:
    dig 3
    dig 2
    <
    bz main_after_for@22
    dig 3
    dup
    itob
    dig 7
    dup
    cover 2
    intc_3 // 8
    *
    intc_2 // 2
    +
    bytec_2 // "dynamic_box"
    swap
    uncover 2
    box_replace
    intc_0 // 1
    +
    bury 7
    intc_0 // 1
    +
    bury 4
    b main_for_header@20

main_after_for@22:
    dig 5
    itob
    dup
    bitlen
    pushint 16 // 16
    <=
    assert // overflow
    extract 6 2
    bytec_2 // "dynamic_box"
    intc_1 // 0
    uncover 2
    box_replace
    bytec_2 // "dynamic_box"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_dynamic_box_route@18:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // "dynamic_box"
    box_del
    pop
    intc_0 // 1
    return

main_create_dynamic_box_route@17:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec_2 // "dynamic_box"
    box_del
    pop
    bytec_2 // "dynamic_box"
    pushbytes 0x0000
    box_put
    intc_0 // 1
    return

main_boxes_exist_route@16:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 7 // "box_a"
    box_len
    bury 1
    bytec 4 // "b"
    box_len
    cover 2
    pop
    bytec_0 // 0x424f585f43
    box_len
    cover 3
    pop
    bytec 5 // "box_large"
    box_len
    cover 4
    pop
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_0 // 1
    uncover 2
    setbit
    intc_2 // 2
    uncover 2
    setbit
    pushint 3 // 3
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_read_boxes_route@15:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 7 // "box_a"
    box_get
    assert // check Box exists
    btoi
    intc_0 // 1
    +
    intc_0 // 1
    -
    bytec 4 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    bytec_0 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    bytec 5 // "box_large"
    intc 4 // 4096
    intc_3 // 8
    box_extract
    btoi
    uncover 3
    itob
    dig 3
    len
    itob
    extract 6 2
    uncover 4
    concat
    swap
    pushbytes 0x0014
    concat
    dig 1
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    concat
    uncover 2
    itob
    concat
    swap
    concat
    swap
    concat
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_indirect_extract_and_replace_route@14:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 5 // "box_large"
    intc 4 // 4096
    intc_3 // 8
    box_extract
    btoi
    intc_0 // 1
    +
    itob
    bytec 5 // "box_large"
    intc 4 // 4096
    uncover 2
    box_replace
    intc_0 // 1
    return

main_delete_boxes_route@13:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 7 // "box_a"
    box_del
    pop
    bytec 4 // "b"
    box_del
    pop
    bytec_0 // 0x424f585f43
    box_del
    pop
    bytec 7 // "box_a"
    box_get
    swap
    btoi
    pushint 42 // 42
    dig 1
    dig 3
    select
    pushint 42 // 42
    ==
    assert
    bytec 4 // "b"
    box_get
    bytec 11 // 0x00023432
    cover 2
    select
    extract 2 0
    pushbytes 0x3432
    ==
    assert
    bytec_0 // 0x424f585f43
    box_get
    bytec 11 // 0x00023432
    cover 2
    select
    bytec 11 // 0x00023432
    ==
    assert
    swap
    !
    assert
    !
    assert
    bytec 5 // "box_large"
    box_del
    pop
    intc_0 // 1
    return

main_sum_many_ints_route@9:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating

main_while_top@47:
    pushint 10510 // 10510
    global OpcodeBudget
    >
    bz main_after_while@52
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 14 // 0x068101
    itxn_field ApprovalProgram
    bytec 14 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b main_while_top@47

main_after_while@52:
    intc_1 // 0
    bury 1
    bytec 9 // "many_ints"
    box_len
    bury 1
    assert // check self.many_ints exists
    intc_1 // 0
    bury 3

main_for_header@10:
    dig 2
    pushint 513 // 513
    <
    bz main_after_for@12
    dig 2
    dup
    intc_3 // 8
    *
    bytec 9 // "many_ints"
    swap
    intc_3 // 8
    box_extract
    btoi
    dig 2
    +
    bury 2
    intc_0 // 1
    +
    bury 3
    b main_for_header@10

main_after_for@12:
    dup
    itob
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_set_many_ints_route@8:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    swap
    intc_3 // 8
    *
    bytec 9 // "many_ints"
    swap
    uncover 2
    box_replace
    intc_0 // 1
    return

main_create_many_ints_route@7:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 9 // "many_ints"
    pushint 4104 // 4104
    box_create
    pop
    intc_0 // 1
    return

main_check_keys_route@6:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_set_boxes_route@5:
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    uncover 2
    itob
    bytec 7 // "box_a"
    swap
    box_put
    bytec 4 // "b"
    box_del
    pop
    bytec 4 // "b"
    dig 2
    box_put
    bytec_0 // 0x424f585f43
    box_del
    pop
    bytec_0 // 0x424f585f43
    dig 1
    box_put
    dig 1
    extract 2 0
    bytec_3 // "box_d"
    box_del
    pop
    bytec_3 // "box_d"
    dig 1
    box_put
    bytec 5 // "box_large"
    pushint 6160 // 6160
    box_create
    pop
    pushint 42 // 42
    itob
    bytec 5 // "box_large"
    intc 4 // 4096
    uncover 2
    box_replace
    bytec 5 // "box_large"
    intc 4 // 4096
    pushbytes 0x000000000000002a
    box_replace
    bytec 4 // "b"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    bytec 4 // "b"
    intc_1 // 0
    intc_2 // 2
    box_extract
    btoi
    ==
    assert // direct reference should match copy
    bytec 7 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3 // 3
    +
    itob
    bytec 7 // "box_a"
    swap
    box_put
    bytec 7 // "box_a"
    box_len
    pop
    intc_3 // 8
    ==
    assert
    bytec 4 // "b"
    box_len
    pop
    dig 3
    len
    ==
    assert
    bytec_0 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    dig 2
    len
    swap
    dig 1
    ==
    assert
    bytec_3 // "box_d"
    box_len
    pop
    dig 2
    len
    swap
    dig 1
    ==
    assert
    bytec_0 // 0x424f585f43
    intc_1 // 0
    intc_0 // 1
    box_extract
    dig 4
    extract 0 1
    ==
    assert
    bytec_0 // 0x424f585f43
    box_len
    pop
    intc_0 // 1
    -
    bytec_0 // 0x424f585f43
    swap
    intc_0 // 1
    box_extract
    dig 2
    intc_0 // 1
    -
    dig 5
    swap
    intc_0 // 1
    extract3
    ==
    assert
    bytec_0 // 0x424f585f43
    box_len
    pop
    intc_0 // 1
    dig 1
    <
    dig 1
    intc_0 // 1
    uncover 2
    select
    -
    bytec_0 // 0x424f585f43
    intc_1 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 3
    >=
    intc_0 // 1
    dig 4
    uncover 2
    select
    dig 3
    swap
    -
    dig 5
    intc_1 // 0
    uncover 2
    substring3
    ==
    assert
    bytec_0 // 0x424f585f43
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    intc_2 // 2
    swap
    select
    bytec_0 // 0x424f585f43
    intc_1 // 0
    uncover 2
    box_extract
    intc_2 // 2
    dig 3
    >=
    intc_2 // 2
    uncover 4
    uncover 2
    select
    uncover 4
    intc_1 // 0
    uncover 2
    substring3
    ==
    assert
    bytec_3 // "box_d"
    intc_1 // 0
    intc_0 // 1
    box_extract
    uncover 3
    extract 2 1
    ==
    assert
    bytec_3 // "box_d"
    box_len
    pop
    intc_0 // 1
    -
    bytec_3 // "box_d"
    swap
    intc_0 // 1
    box_extract
    dig 1
    intc_0 // 1
    -
    dig 3
    swap
    intc_0 // 1
    extract3
    ==
    assert
    bytec_3 // "box_d"
    box_len
    pop
    intc_0 // 1
    dig 1
    <
    dig 1
    intc_0 // 1
    uncover 2
    select
    -
    bytec_3 // "box_d"
    intc_1 // 0
    uncover 2
    box_extract
    intc_0 // 1
    dig 2
    >=
    intc_0 // 1
    dig 3
    uncover 2
    select
    dig 2
    swap
    -
    dig 3
    intc_1 // 0
    uncover 2
    substring3
    ==
    assert
    bytec_3 // "box_d"
    box_len
    pop
    pushint 5 // 5
    dig 1
    <
    pushint 5 // 5
    swap
    select
    bytec_3 // "box_d"
    intc_1 // 0
    uncover 2
    box_extract
    pushint 5 // 5
    dig 2
    >=
    pushint 5 // 5
    dig 3
    uncover 2
    select
    dig 3
    intc_1 // 0
    uncover 2
    substring3
    ==
    assert
    bytec_3 // "box_d"
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    intc_2 // 2
    swap
    select
    bytec_3 // "box_d"
    intc_1 // 0
    uncover 2
    box_extract
    intc_2 // 2
    dig 2
    >=
    intc_2 // 2
    uncover 3
    uncover 2
    select
    uncover 2
    intc_1 // 0
    uncover 2
    substring3
    ==
    assert
    bytec 5 // "box_large"
    box_len
    pop
    pushint 6160 // 6160
    ==
    assert
    intc_0 // 1
    return

main_bare_routing@36:
    txn OnCompletion
    bnz main_after_if_else@38
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return
