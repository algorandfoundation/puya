#pragma version 10
#pragma typetrack false

// examples.box_storage.contract.BoxContract.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 2 5
    bytecblock 0x 0x424f585f43 0x626c6f62 "box_d" "box_a" "b" "box_large" 0x64 0x68656c6c6f "0" 0x00 0x151f7c75 0x3432 "box_ref" "Hmmmmm" 0x00023432 "default"

main_block@0:
    txn ApplicationID
    bnz main_after_if_else@2

main_call___init__@1:
    callsub __init__

main_after_if_else@2:
    callsub approval_program
    return


// examples.box_storage.contract.get_box_value_plus_1(box: bytes) -> uint64:
get_box_value_plus_1:
    // box_storage/contract.py:223-224
    // @subroutine
    // def get_box_value_plus_1(box: Box[UInt64]) -> UInt64:
    proto 1 1

get_box_value_plus_1_block@0:
    // box_storage/contract.py:225
    // return box.value + 1
    frame_dig -1
    box_get
    assert // check Box exists
    btoi
    intc_1 // 1
    +
    retsub


// examples.box_storage.contract.get_box_ref_length(ref: bytes) -> uint64:
get_box_ref_length:
    // box_storage/contract.py:228-229
    // @subroutine
    // def get_box_ref_length(ref: BoxRef) -> UInt64:
    proto 1 1

get_box_ref_length_block@0:
    // box_storage/contract.py:230
    // return ref.length
    frame_dig -1
    box_len
    assert // check BoxRef exists
    retsub


// examples.box_storage.contract.get_box_map_value_from_key_plus_1(box_map: bytes, key: uint64) -> bytes:
get_box_map_value_from_key_plus_1:
    // box_storage/contract.py:233-234
    // @subroutine
    // def get_box_map_value_from_key_plus_1(box_map: BoxMap[UInt64, String], key: UInt64) -> String:
    proto 2 1

get_box_map_value_from_key_plus_1_block@0:
    // box_storage/contract.py:235
    // return box_map[key + 1]
    frame_dig -1
    intc_1 // 1
    +
    itob
    frame_dig -2
    swap
    concat
    box_get
    assert // check BoxMap entry exists
    retsub


// examples.box_storage.contract.BoxContract.__init__() -> void:
__init__:

__init___block@0:
    retsub


// examples.box_storage.contract.BoxContract.set_boxes(a: uint64, b: bytes, c: bytes) -> void:
set_boxes:
    // box_storage/contract.py:41-42
    // @arc4.abimethod
    // def set_boxes(self, a: UInt64, b: arc4.DynamicBytes, c: arc4.String) -> None:
    proto 3 0

set_boxes_block@0:
    // box_storage/contract.py:43
    // self.box_a.value = a
    frame_dig -3
    itob
    bytec 4 // "box_a"
    swap
    box_put
    // box_storage/contract.py:44
    // self.box_b.value = b.copy()
    frame_dig -2
    bytec 5 // "b"
    box_del
    pop
    bytec 5 // "b"
    swap
    box_put
    // box_storage/contract.py:45
    // self.box_c.value = c
    bytec_1 // 0x424f585f43
    box_del
    pop
    bytec_1 // 0x424f585f43
    frame_dig -1
    box_put
    // box_storage/contract.py:46
    // self.box_d.value = b.native
    frame_dig -2
    extract 2 0
    bytec_3 // "box_d"
    box_del
    pop
    bytec_3 // "box_d"
    swap
    box_put
    // box_storage/contract.py:47
    // self.box_large.create()
    bytec 6 // "box_large"
    pushint 6152 // 6152
    box_create
    pop
    // box_storage/contract.py:48-50
    // # TODO: support direct mutation of large structs in boxes
    // # self.box_large.value.e = arc4.UInt64(42)
    // self.box_large.ref.replace(size_of(Bytes1024) * 4, arc4.UInt64(42).bytes)
    pushint 1024 // 1024
    pushint 4 // 4
    *
    bytec 6 // "box_large"
    swap
    pushbytes 0x000000000000002a
    box_replace
    // box_storage/contract.py:52
    // b_value = self.box_b.value.copy()
    bytec 5 // "b"
    box_get
    assert // check self.box_b exists
    // box_storage/contract.py:53
    // assert self.box_b.value.length == b_value.length, "direct reference should match copy"
    bytec 5 // "b"
    box_get
    assert // check self.box_b exists
    intc_0 // 0
    extract_uint16
    swap
    intc_0 // 0
    extract_uint16
    ==
    assert // direct reference should match copy
    // box_storage/contract.py:55
    // self.box_a.value += 3
    bytec 4 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3 // 3
    +
    itob
    bytec 4 // "box_a"
    swap
    box_put
    // box_storage/contract.py:57-58
    // # test .length
    // assert self.box_a.length == 8
    bytec 4 // "box_a"
    box_len
    assert // check self.box_a exists
    pushint 8 // 8
    ==
    assert
    // box_storage/contract.py:59
    // assert self.box_b.length == b.bytes.length
    bytec 5 // "b"
    box_len
    assert // check self.box_b exists
    frame_dig -2
    len
    ==
    assert
    // box_storage/contract.py:60
    // assert self.box_c.length == c.bytes.length
    bytec_1 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    frame_dig -1
    len
    ==
    assert
    // box_storage/contract.py:61
    // assert self.box_d.length == b.native.length
    bytec_3 // "box_d"
    box_len
    assert // check self.box_d exists
    frame_dig -2
    extract 2 0
    len
    ==
    assert
    // box_storage/contract.py:63-64
    // # test .value.bytes
    // assert self.box_c.value.bytes[0] == c.bytes[0]
    bytec_1 // 0x424f585f43
    intc_0 // 0
    intc_1 // 1
    box_extract
    frame_dig -1
    intc_0 // 0
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    ==
    assert
    // box_storage/contract.py:65
    // assert self.box_c.value.bytes[-1] == c.bytes[-1]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_1 // 1
    -
    bytec_1 // 0x424f585f43
    swap
    intc_1 // 1
    box_extract
    frame_dig -1
    len
    intc_1 // 1
    -
    frame_dig -1
    swap
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    ==
    assert
    // box_storage/contract.py:66
    // assert self.box_c.value.bytes[:-1] == c.bytes[:-1]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_1 // 1
    dig 1
    <
    swap
    dup
    intc_1 // 1
    uncover 3
    select
    -
    intc_0 // 0
    -
    bytec_1 // 0x424f585f43
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -1
    len
    intc_1 // 1
    dig 1
    >=
    intc_1 // 1
    dig 2
    uncover 2
    select
    -
    frame_dig -1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:67
    // assert self.box_c.value.bytes[:2] == c.bytes[:2]
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    swap
    intc_2 // 2
    uncover 2
    select
    intc_0 // 0
    -
    bytec_1 // 0x424f585f43
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -1
    len
    intc_2 // 2
    dig 1
    >=
    intc_2 // 2
    uncover 2
    uncover 2
    select
    frame_dig -1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:69-70
    // # test .value with Bytes type
    // assert self.box_d.value[0] == b.native[0]
    bytec_3 // "box_d"
    intc_0 // 0
    intc_1 // 1
    box_extract
    frame_dig -2
    extract 2 0
    intc_0 // 0
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    ==
    assert
    // box_storage/contract.py:71
    // assert self.box_d.value[-1] == b.native[-1]
    bytec_3 // "box_d"
    box_len
    pop
    intc_1 // 1
    -
    bytec_3 // "box_d"
    swap
    intc_1 // 1
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_1 // 1
    -
    intc_1 // 1
    extract3 // on error: Index access is out of bounds
    ==
    assert
    // box_storage/contract.py:72
    // assert self.box_d.value[:-1] == b.native[:-1]
    bytec_3 // "box_d"
    box_len
    pop
    intc_1 // 1
    dig 1
    <
    swap
    dup
    intc_1 // 1
    uncover 3
    select
    -
    intc_0 // 0
    -
    bytec_3 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_1 // 1
    dig 1
    >=
    intc_1 // 1
    dig 2
    uncover 2
    select
    -
    swap
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:73
    // assert self.box_d.value[:5] == b.native[:5]
    bytec_3 // "box_d"
    box_len
    pop
    intc_3 // 5
    dig 1
    <
    swap
    intc_3 // 5
    uncover 2
    select
    intc_0 // 0
    -
    bytec_3 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_3 // 5
    dig 1
    >=
    intc_3 // 5
    uncover 2
    uncover 2
    select
    swap
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:74
    // assert self.box_d.value[: UInt64(2)] == b.native[: UInt64(2)]
    bytec_3 // "box_d"
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    swap
    intc_2 // 2
    uncover 2
    select
    intc_0 // 0
    -
    bytec_3 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_2 // 2
    dig 1
    >=
    intc_2 // 2
    uncover 2
    uncover 2
    select
    swap
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:76
    // assert self.box_large.length == size_of(LargeStruct)
    bytec 6 // "box_large"
    box_len
    assert // check self.box_large exists
    pushint 6152 // 6152
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.check_keys() -> void:
check_keys:

check_keys_block@0:
    // box_storage/contract.py:80
    // assert self.box_a.key == b"box_a", "box a key ok"
    bytec 4 // "box_a"
    dup
    ==
    assert // box a key ok
    // box_storage/contract.py:81
    // assert self.box_b.key == b"b", "box b key ok"
    bytec 5 // "b"
    dup
    ==
    assert // box b key ok
    // box_storage/contract.py:82
    // assert self.box_c.key == b"BOX_C", "box c key ok"
    bytec_1 // 0x424f585f43
    dup
    ==
    assert // box c key ok
    // box_storage/contract.py:83
    // assert self.box_large.key == b"box_large", "box large key ok"
    bytec 6 // "box_large"
    dup
    ==
    assert // box large key ok
    retsub


// examples.box_storage.contract.BoxContract.delete_boxes() -> void:
delete_boxes:

delete_boxes_block@0:
    // box_storage/contract.py:87
    // del self.box_a.value
    bytec 4 // "box_a"
    box_del
    pop
    // box_storage/contract.py:88
    // del self.box_b.value
    bytec 5 // "b"
    box_del
    pop
    // box_storage/contract.py:89
    // del self.box_c.value
    bytec_1 // 0x424f585f43
    box_del
    pop
    // box_storage/contract.py:90
    // assert self.box_a.get(default=UInt64(42)) == 42
    bytec 4 // "box_a"
    box_get
    swap
    btoi
    pushint 42 // 42
    swap
    uncover 2
    select
    pushint 42 // 42
    ==
    assert
    // box_storage/contract.py:91
    // assert self.box_b.get(default=arc4.DynamicBytes(b"42")).native == b"42"
    bytec 12 // 0x3432
    len
    itob
    extract 6 2
    bytec 12 // 0x3432
    concat
    bytec 5 // "b"
    box_get
    swap
    uncover 2
    swap
    uncover 2
    select
    extract 2 0
    bytec 12 // 0x3432
    ==
    assert
    // box_storage/contract.py:92
    // assert self.box_c.get(default=arc4.String("42")) == "42"
    bytec_1 // 0x424f585f43
    box_get
    swap
    bytec 15 // 0x00023432
    swap
    uncover 2
    select
    bytec 15 // 0x00023432
    ==
    assert
    // box_storage/contract.py:93
    // a, a_exists = self.box_a.maybe()
    bytec 4 // "box_a"
    box_get
    swap
    btoi
    swap
    // box_storage/contract.py:94
    // assert not a_exists
    !
    assert
    // box_storage/contract.py:95
    // assert a == 0
    intc_0 // 0
    ==
    assert
    // box_storage/contract.py:96
    // del self.box_large.value
    bytec 6 // "box_large"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.read_boxes() -> uint64, bytes, bytes, uint64:
read_boxes:

read_boxes_block@0:
    // box_storage/contract.py:103
    // large_e = arc4.UInt64.from_bytes(large_box_ref.extract(size_of(Bytes1024) * 4, 8))
    pushint 1024 // 1024
    pushint 4 // 4
    *
    // box_storage/contract.py:100-102
    // # TODO: support direct reading of large structs in boxes
    // # large_e = self.box_large.value.e
    // large_box_ref = BoxRef(key=self.box_large.key)
    bytec 6 // "box_large"
    // box_storage/contract.py:103
    // large_e = arc4.UInt64.from_bytes(large_box_ref.extract(size_of(Bytes1024) * 4, 8))
    swap
    pushint 8 // 8
    box_extract
    // box_storage/contract.py:105
    // get_box_value_plus_1(self.box_a) - 1,
    bytec 4 // "box_a"
    callsub get_box_value_plus_1
    intc_1 // 1
    -
    // box_storage/contract.py:106
    // self.box_b.value.native,
    bytec 5 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    // box_storage/contract.py:107
    // self.box_c.value,
    bytec_1 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    // box_storage/contract.py:108
    // large_e.native,
    uncover 3
    btoi
    // box_storage/contract.py:104-109
    // return (
    //     get_box_value_plus_1(self.box_a) - 1,
    //     self.box_b.value.native,
    //     self.box_c.value,
    //     large_e.native,
    // )
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    retsub


// examples.box_storage.contract.BoxContract.boxes_exist() -> uint64, uint64, uint64, uint64:
boxes_exist:

boxes_exist_block@0:
    // box_storage/contract.py:113
    // return bool(self.box_a), bool(self.box_b), bool(self.box_c), bool(self.box_large)
    bytec 4 // "box_a"
    box_len
    bury 1
    bytec 5 // "b"
    box_len
    bury 1
    bytec_1 // 0x424f585f43
    box_len
    bury 1
    bytec 6 // "box_large"
    box_len
    bury 1
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    retsub


// examples.box_storage.contract.BoxContract.slice_box() -> void:
slice_box:

slice_box_block@0:
    // box_storage/contract.py:117
    // box_0 = Box(Bytes, key=String("0"))
    bytec 9 // "0"
    // box_storage/contract.py:118
    // box_0.value = Bytes(b"Testing testing 123")
    box_del
    pop
    // box_storage/contract.py:117
    // box_0 = Box(Bytes, key=String("0"))
    bytec 9 // "0"
    // box_storage/contract.py:118
    // box_0.value = Bytes(b"Testing testing 123")
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    // box_storage/contract.py:117
    // box_0 = Box(Bytes, key=String("0"))
    bytec 9 // "0"
    // box_storage/contract.py:119
    // assert box_0.value[0:7] == b"Testing"
    box_len
    pop
    intc_0 // 0
    dig 1
    <
    swap
    dup
    intc_0 // 0
    uncover 3
    select
    swap
    pushint 7 // 7
    dig 1
    <
    swap
    pushint 7 // 7
    uncover 2
    select
    dig 1
    -
    // box_storage/contract.py:117
    // box_0 = Box(Bytes, key=String("0"))
    bytec 9 // "0"
    // box_storage/contract.py:119
    // assert box_0.value[0:7] == b"Testing"
    uncover 2
    uncover 2
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    // box_storage/contract.py:121
    // self.box_c.value = arc4.String("Hello")
    bytec_1 // 0x424f585f43
    box_del
    pop
    bytec_1 // 0x424f585f43
    pushbytes 0x000548656c6c6f
    box_put
    // box_storage/contract.py:122
    // assert self.box_c.value.bytes[2:10] == b"Hello"
    bytec_1 // 0x424f585f43
    box_len
    pop
    intc_2 // 2
    dig 1
    <
    swap
    dup
    intc_2 // 2
    uncover 3
    select
    swap
    pushint 10 // 10
    dig 1
    <
    swap
    pushint 10 // 10
    uncover 2
    select
    dig 1
    -
    bytec_1 // 0x424f585f43
    uncover 2
    uncover 2
    box_extract
    pushbytes 0x48656c6c6f
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.arc4_box() -> void:
arc4_box:

arc4_box_block@0:
    // box_storage/contract.py:127
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    bytec_0 // 0x
    bytec 10 // 0x00
    concat
    pushbytes 0x01
    concat
    pushbytes 0x02
    concat
    pushbytes 0x03
    concat
    bytec_0 // 0x
    concat
    // box_storage/contract.py:126
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 7 // 0x64
    // box_storage/contract.py:127
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    swap
    box_put
    // box_storage/contract.py:126
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 7 // 0x64
    // box_storage/contract.py:129
    // assert box_d.value[0] == 0
    box_get
    assert // check Box exists
    intc_0 // 0
    intc_1 // 1
    *
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    bytec 10 // 0x00
    b==
    assert
    // box_storage/contract.py:126
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 7 // 0x64
    // box_storage/contract.py:130
    // assert box_d.value[1] == 1
    box_get
    assert // check Box exists
    intc_1 // 1
    dup
    *
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x01
    b==
    assert
    // box_storage/contract.py:126
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 7 // 0x64
    // box_storage/contract.py:131
    // assert box_d.value[2] == 2
    box_get
    assert // check Box exists
    intc_2 // 2
    intc_1 // 1
    *
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x02
    b==
    assert
    // box_storage/contract.py:126
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 7 // 0x64
    // box_storage/contract.py:132
    // assert box_d.value[3] == 3
    box_get
    assert // check Box exists
    pushint 3 // 3
    intc_1 // 1
    *
    intc_1 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x03
    b==
    assert
    retsub


// examples.box_storage.contract.BoxContract.test_box_ref() -> void:
test_box_ref:

test_box_ref_block@0:
    // box_storage/contract.py:136-137
    // # init ref, with valid key types
    // box_ref = BoxRef(key="blob")
    bytec_2 // "blob"
    // box_storage/contract.py:138
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:139
    // box_ref = BoxRef(key=b"blob")
    bytec_2 // 0x626c6f62
    // box_storage/contract.py:140
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:141
    // box_ref = BoxRef(key=Bytes(b"blob"))
    bytec_2 // 0x626c6f62
    // box_storage/contract.py:142
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:144
    // assert not box_ref, "no data"
    box_len
    bury 1
    !
    assert // no data
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:146-147
    // # create
    // assert box_ref.create(size=32)
    pushint 32 // 32
    box_create
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:148
    // assert box_ref, "has data"
    box_len
    bury 1
    assert // has data
    // box_storage/contract.py:150-151
    // # manipulate data
    // sender_bytes = Txn.sender.bytes
    txn Sender
    // box_storage/contract.py:152
    // app_address = Global.current_application_address.bytes
    global CurrentApplicationAddress
    swap
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:154
    // box_ref.replace(0, sender_bytes)
    intc_0 // 0
    dig 2
    box_replace
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:155
    // box_ref.resize(8000)
    pushint 8000 // 8000
    box_resize
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:156
    // box_ref.splice(0, 0, app_address)
    intc_0 // 0
    dup
    dig 4
    box_splice
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:157
    // box_ref.replace(64, value_3)
    pushint 64 // 64
    // box_storage/contract.py:153
    // value_3 = Bytes(b"hello")
    bytec 8 // 0x68656c6c6f
    // box_storage/contract.py:157
    // box_ref.replace(64, value_3)
    box_replace
    // box_storage/contract.py:153
    // value_3 = Bytes(b"hello")
    bytec 8 // 0x68656c6c6f
    // box_storage/contract.py:158
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    len
    pushint 64 // 64
    +
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:158
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    intc_0 // 0
    uncover 2
    box_extract
    // box_storage/contract.py:159
    // assert prefix == app_address + sender_bytes + value_3
    dig 2
    dig 2
    concat
    // box_storage/contract.py:153
    // value_3 = Bytes(b"hello")
    bytec 8 // 0x68656c6c6f
    // box_storage/contract.py:159
    // assert prefix == app_address + sender_bytes + value_3
    concat
    ==
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:161-162
    // # delete
    // assert box_ref.delete()
    box_del
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:163
    // assert box_ref.key == b"blob"
    dup
    ==
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:165-166
    // # query
    // value, exists = box_ref.maybe()
    box_get
    // box_storage/contract.py:167
    // assert not exists
    !
    assert
    // box_storage/contract.py:168
    // assert value == b""
    bytec_0 // 0x
    ==
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:169
    // assert box_ref.get(default=sender_bytes) == sender_bytes
    box_get
    swap
    dig 2
    swap
    uncover 2
    select
    dig 1
    ==
    assert
    // box_storage/contract.py:171-172
    // # update
    // box_ref.put(sender_bytes + app_address)
    swap
    concat
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:171-172
    // # update
    // box_ref.put(sender_bytes + app_address)
    swap
    box_put
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:173
    // assert box_ref, "Blob exists"
    box_len
    bury 1
    assert // Blob exists
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:174
    // assert box_ref.length == 64
    box_len
    assert // check BoxRef exists
    pushint 64 // 64
    ==
    assert
    // box_storage/contract.py:143
    // box_ref = BoxRef(key=String("blob"))
    bytec_2 // "blob"
    // box_storage/contract.py:175
    // assert get_box_ref_length(box_ref) == 64
    callsub get_box_ref_length
    pushint 64 // 64
    ==
    assert
    // box_storage/contract.py:177-178
    // # instance box ref
    // self.box_ref.create(size=UInt64(32))
    bytec 13 // "box_ref"
    pushint 32 // 32
    box_create
    pop
    // box_storage/contract.py:179
    // assert self.box_ref, "has data"
    bytec 13 // "box_ref"
    box_len
    bury 1
    assert // has data
    // box_storage/contract.py:180
    // self.box_ref.delete()
    bytec 13 // "box_ref"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_test() -> void:
box_map_test:

box_map_test_block@0:
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:187
    // self.box_map[key_0] = value
    itob
    bytec_0 // ""
    swap
    concat
    dup
    box_del
    pop
    // box_storage/contract.py:186
    // value = String("Hmmmmm")
    bytec 14 // "Hmmmmm"
    // box_storage/contract.py:187
    // self.box_map[key_0] = value
    box_put
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:188
    // box_0 = self.box_map.box(key_0)
    itob
    bytec_0 // ""
    swap
    concat
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:190
    // assert self.box_map[key_0].bytes.length == value.bytes.length
    itob
    bytec_0 // ""
    swap
    concat
    box_len
    assert // check self.box_map entry exists
    // box_storage/contract.py:186
    // value = String("Hmmmmm")
    bytec 14 // "Hmmmmm"
    // box_storage/contract.py:190
    // assert self.box_map[key_0].bytes.length == value.bytes.length
    len
    ==
    assert
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:191
    // assert self.box_map[key_0].bytes.length == box_0.length
    itob
    bytec_0 // ""
    swap
    concat
    box_len
    assert // check self.box_map entry exists
    swap
    box_len
    assert // check Box exists
    ==
    assert
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:192
    // assert self.box_map.length(key_0) == value.bytes.length
    itob
    bytec_0 // ""
    swap
    concat
    box_len
    assert // check self.box_map entry exists
    // box_storage/contract.py:186
    // value = String("Hmmmmm")
    bytec 14 // "Hmmmmm"
    // box_storage/contract.py:192
    // assert self.box_map.length(key_0) == value.bytes.length
    len
    ==
    assert
    // box_storage/contract.py:185
    // key_1 = UInt64(1)
    intc_1 // 1
    // box_storage/contract.py:194
    // assert self.box_map.get(key_1, default=String("default")) == String("default")
    itob
    bytec_0 // ""
    swap
    concat
    box_get
    swap
    bytec 16 // "default"
    swap
    uncover 2
    select
    bytec 16 // "default"
    ==
    assert
    // box_storage/contract.py:185
    // key_1 = UInt64(1)
    intc_1 // 1
    // box_storage/contract.py:195
    // value, exists = self.box_map.maybe(key_1)
    itob
    bytec_0 // ""
    swap
    concat
    box_get
    bury 1
    // box_storage/contract.py:196
    // assert not exists
    !
    assert
    // box_storage/contract.py:184
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:197
    // assert key_0 in self.box_map
    itob
    bytec_0 // ""
    swap
    concat
    box_len
    bury 1
    assert
    // box_storage/contract.py:198
    // assert self.box_map.key_prefix == b""
    bytec_0 // ""
    dup
    ==
    assert
    // box_storage/contract.py:185
    // key_1 = UInt64(1)
    intc_1 // 1
    // box_storage/contract.py:202
    // tmp_box_map[key_1] = String("hello")
    itob
    // box_storage/contract.py:200-201
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:202
    // tmp_box_map[key_1] = String("hello")
    swap
    concat
    dup
    box_del
    pop
    bytec 8 // "hello"
    box_put
    // box_storage/contract.py:200-201
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:203
    // assert get_box_map_value_from_key_plus_1(tmp_box_map, UInt64(0)) == "hello"
    intc_0 // 0
    callsub get_box_map_value_from_key_plus_1
    bytec 8 // "hello"
    ==
    assert
    // box_storage/contract.py:185
    // key_1 = UInt64(1)
    intc_1 // 1
    // box_storage/contract.py:204
    // del tmp_box_map[key_1]
    itob
    // box_storage/contract.py:200-201
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:204
    // del tmp_box_map[key_1]
    swap
    concat
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_set(key: uint64, value: bytes) -> void:
box_map_set:
    // box_storage/contract.py:206-207
    // @arc4.abimethod
    // def box_map_set(self, key: UInt64, value: String) -> None:
    proto 2 0

box_map_set_block@0:
    // box_storage/contract.py:208
    // self.box_map[key] = value
    frame_dig -2
    itob
    bytec_0 // ""
    swap
    concat
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.box_map_get(key: uint64) -> bytes:
box_map_get:
    // box_storage/contract.py:210-211
    // @arc4.abimethod
    // def box_map_get(self, key: UInt64) -> String:
    proto 1 1

box_map_get_block@0:
    // box_storage/contract.py:212
    // return self.box_map[key]
    frame_dig -1
    itob
    bytec_0 // ""
    swap
    concat
    box_get
    assert // check self.box_map entry exists
    retsub


// examples.box_storage.contract.BoxContract.box_map_del(key: uint64) -> void:
box_map_del:
    // box_storage/contract.py:214-215
    // @arc4.abimethod
    // def box_map_del(self, key: UInt64) -> None:
    proto 1 0

box_map_del_block@0:
    // box_storage/contract.py:216
    // del self.box_map[key]
    frame_dig -1
    itob
    bytec_0 // ""
    swap
    concat
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_exists(key: uint64) -> uint64:
box_map_exists:
    // box_storage/contract.py:218-219
    // @arc4.abimethod
    // def box_map_exists(self, key: UInt64) -> bool:
    proto 1 1

box_map_exists_block@0:
    // box_storage/contract.py:220
    // return key in self.box_map
    frame_dig -1
    itob
    bytec_0 // ""
    swap
    concat
    box_len
    bury 1
    retsub


// algopy.arc4.ARC4Contract.approval_program() -> uint64:
approval_program:

approval_program_block@0:

approval_program_block@1:
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txn NumAppArgs
    intc_0 // 0
    !=
    bz approval_program_bare_routing@18

approval_program_abi_routing@2:
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 0
    pushbytes 0x7d37296e // method "set_boxes(uint64,byte[],string)void"
    pushbytes 0x33325d3d // method "check_keys()void"
    pushbytes 0xd566c632 // method "delete_boxes()void"
    pushbytes 0xa6174812 // method "read_boxes()(uint64,byte[],string,uint64)"
    pushbytes 0xf13dd937 // method "boxes_exist()(bool,bool,bool,bool)"
    pushbytes 0x04ef4971 // method "slice_box()void"
    pushbytes 0x23ecb32c // method "arc4_box()void"
    pushbytes 0xeef75816 // method "test_box_ref()void"
    pushbytes 0xb532913a // method "box_map_test()void"
    pushbytes 0xc29f1669 // method "box_map_set(uint64,string)void"
    pushbytes 0x9c888c09 // method "box_map_get(uint64)string"
    pushbytes 0xe6f68506 // method "box_map_del(uint64)void"
    pushbytes 0x8ee2c364 // method "box_map_exists(uint64)bool"
    uncover 13
    match approval_program_set_boxes_route@3 approval_program_check_keys_route@4 approval_program_delete_boxes_route@5 approval_program_read_boxes_route@6 approval_program_boxes_exist_route@7 approval_program_slice_box_route@8 approval_program_arc4_box_route@9 approval_program_test_box_ref_route@10 approval_program_box_map_test_route@11 approval_program_box_map_set_route@12 approval_program_box_map_get_route@13 approval_program_box_map_del_route@14 approval_program_box_map_exists_route@15

approval_program_switch_case_default@16:

approval_program_switch_case_next@17:

approval_program_after_if_else@24:
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    intc_0 // 0

approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25:
    retsub

approval_program_box_map_exists_route@15:
    // box_storage/contract.py:218
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:218
    // @arc4.abimethod
    callsub box_map_exists
    bytec 10 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_box_map_del_route@14:
    // box_storage/contract.py:214
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:214
    // @arc4.abimethod
    callsub box_map_del
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_box_map_get_route@13:
    // box_storage/contract.py:210
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // box_storage/contract.py:210
    // @arc4.abimethod
    callsub box_map_get
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_box_map_set_route@12:
    // box_storage/contract.py:206
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // box_storage/contract.py:206
    // @arc4.abimethod
    callsub box_map_set
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_box_map_test_route@11:
    // box_storage/contract.py:182
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub box_map_test
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_test_box_ref_route@10:
    // box_storage/contract.py:134
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub test_box_ref
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_arc4_box_route@9:
    // box_storage/contract.py:124
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub arc4_box
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_slice_box_route@8:
    // box_storage/contract.py:115
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub slice_box
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_boxes_exist_route@7:
    // box_storage/contract.py:111
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub boxes_exist
    cover 3
    cover 2
    swap
    bytec 10 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x
    swap
    concat
    intc_1 // 1
    uncover 2
    setbit
    intc_2 // 2
    uncover 2
    setbit
    pushint 3 // 3
    uncover 2
    setbit
    bytec_0 // 0x
    concat
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_read_boxes_route@6:
    // box_storage/contract.py:98
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub read_boxes
    cover 3
    cover 2
    swap
    itob
    bytec_0 // 0x
    swap
    concat
    swap
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x
    dig 1
    concat
    swap
    len
    pushint 20 // 20
    +
    pushint 20 // 20
    itob
    extract 6 2
    uncover 3
    swap
    concat
    uncover 2
    uncover 3
    concat
    cover 2
    swap
    itob
    extract 6 2
    concat
    uncover 2
    itob
    concat
    swap
    concat
    bytec 11 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_delete_boxes_route@5:
    // box_storage/contract.py:85
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub delete_boxes
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_check_keys_route@4:
    // box_storage/contract.py:78
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub check_keys
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_set_boxes_route@3:
    // box_storage/contract.py:41
    // @arc4.abimethod
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // box_storage/contract.py:41
    // @arc4.abimethod
    uncover 2
    uncover 2
    uncover 2
    callsub set_boxes
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25

approval_program_bare_routing@18:
    // box_storage/contract.py:31
    // class BoxContract(arc4.ARC4Contract):
    txn OnCompletion
    intc_0 // 0
    swap
    match approval_program___algopy_default_create@19

approval_program_switch_case_default@22:

approval_program_switch_case_next@23:
    b approval_program_after_if_else@24

approval_program___algopy_default_create@19:
    txn ApplicationID
    intc_0 // 0
    ==
    assert // can only call when creating

approval_program_block@20:

approval_program_after_inlined_examples.box_storage.contract.BoxContract.__algopy_default_create@21:
    intc_1 // 1
    b approval_program_after_inlined_examples.box_storage.contract.BoxContract.__puya_arc4_router__@25
