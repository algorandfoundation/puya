#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 2 1 8 4098 4096 5000
    bytecblock 0x "dynamic_arr_struct" "box" 0x626c6f62 0x424f585f43 0x151f7c75 "dynamic_box" "box_d" 0x626f785f61 0x62 0x626f785f6c61726765 0x3432 "big_bytes" "too_many_bools" 0x64 0x68656c6c6f 0x00 "many_ints" "big_fixed_bytes" "0" 0x48656c6c6f "box_ref" "Hmmmmm" 0x068101 "default"
    b main_block@0

main_block@0:
    txn ApplicationID
    bnz main_after_if_else@2
    b main_call___init__@1

main_call___init__@1:
    callsub __init__
    b main_after_if_else@2

main_after_if_else@2:
    b main_block@3

main_block@3:
    // box_storage/contract.py:80
    // class BoxContract(arc4.ARC4Contract):
    txn NumAppArgs
    intc_0 // 0
    !=
    bz main___algopy_default_create@52
    b main_abi_routing@4

main_abi_routing@4:
    // box_storage/contract.py:80
    // class BoxContract(arc4.ARC4Contract):
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert
    txn ApplicationID
    intc_0 // 0
    !=
    bz main_create_NoOp@50
    b main_call_NoOp@5

main_call_NoOp@5:
    // box_storage/contract.py:80
    // class BoxContract(arc4.ARC4Contract):
    txna ApplicationArgs 0
    pushbytes 0x7d37296e // method "set_boxes(uint64,byte[],string)void"
    pushbytes 0x33325d3d // method "check_keys()void"
    pushbytes 0x0199408d // method "create_many_ints()void"
    pushbytes 0x772059ca // method "set_many_ints(uint64,uint64)void"
    pushbytes 0xaa68d894 // method "create_big_fixed_bytes()void"
    pushbytes 0x9b01ee56 // method "update_big_fixed_bytes(uint64,byte[])void"
    pushbytes 0x1d6f6daf // method "assert_big_fixed_bytes(uint64,byte[])void"
    pushbytes 0x2641daed // method "slice_big_fixed_bytes(uint64,uint64)byte[]"
    pushbytes 0x50c22157 // method "create_big_bytes(uint64)void"
    pushbytes 0x9d52ee88 // method "update_big_bytes(uint64,byte[])void"
    pushbytes 0x9fabe74e // method "assert_big_bytes(uint64,byte[])void"
    pushbytes 0xf09069ae // method "slice_big_bytes(uint64,uint64)byte[]"
    pushbytes 0x01263df6 // method "sum_many_ints()uint64"
    pushbytes 0xd566c632 // method "delete_boxes()void"
    pushbytes 0xfabcb885 // method "indirect_extract_and_replace()void"
    pushbytes 0xa6174812 // method "read_boxes()(uint64,byte[],string,uint64)"
    pushbytes 0xf13dd937 // method "boxes_exist()(bool,bool,bool,bool)"
    pushbytes 0x5ab60f2e // method "create_dynamic_arr_struct()void"
    pushbytes 0xf07a0064 // method "delete_dynamic_arr_struct()void"
    pushbytes 0x78f9af3f // method "append_dynamic_arr_struct(uint64)uint64"
    pushbytes 0x5cbb9dcc // method "pop_dynamic_arr_struct(uint64)uint64"
    pushbytes 0x996497ae // method "set_nested_struct((uint64,(uint64,uint64[][],uint64),(uint64,uint64[][],uint64)[],uint64))void"
    pushbytes 0x6cec72ff // method "nested_write(uint64,uint64)void"
    pushbytes 0x6f9d1075 // method "nested_read(uint64,uint64,uint64)uint64"
    pushbytes 0x0d22b441 // method "sum_dynamic_arr_struct()uint64"
    pushbytes 0x59ef3760 // method "create_bools()void"
    pushbytes 0xaa666b96 // method "set_bool(uint64,bool)void"
    pushbytes 0xdfbdd636 // method "sum_bools(uint64)uint64"
    pushbytes 0x41427cd1 // method "create_dynamic_box()void"
    pushbytes 0x2a141f6c // method "delete_dynamic_box()void"
    pushbytes 0x7e843744 // method "append_dynamic_box(uint64)uint64"
    pushbytes 0x25600b57 // method "pop_dynamic_box(uint64)uint64"
    pushbytes 0x29ea595d // method "sum_dynamic_box()uint64"
    pushbytes 0x11453152 // method "write_dynamic_box(uint64,uint64)void"
    pushbytes 0xced1221e // method "write_dynamic_arr_struct(uint64,uint64)void"
    pushbytes 0x04ef4971 // method "slice_box()void"
    pushbytes 0x23ecb32c // method "arc4_box()void"
    pushbytes 0xeef75816 // method "test_box_ref()void"
    pushbytes 0xb532913a // method "box_map_test()void"
    pushbytes 0xc29f1669 // method "box_map_set(uint64,string)void"
    pushbytes 0x9c888c09 // method "box_map_get(uint64)string"
    pushbytes 0xe6f68506 // method "box_map_del(uint64)void"
    pushbytes 0x8ee2c364 // method "box_map_exists(uint64)bool"
    uncover 43
    match main_set_boxes_route@6 main_check_keys_route@7 main_create_many_ints_route@8 main_set_many_ints_route@9 main_create_big_fixed_bytes_route@10 main_update_big_fixed_bytes_route@11 main_assert_big_fixed_bytes_route@12 main_slice_big_fixed_bytes_route@13 main_create_big_bytes_route@14 main_update_big_bytes_route@15 main_assert_big_bytes_route@16 main_slice_big_bytes_route@17 main_sum_many_ints_route@18 main_delete_boxes_route@19 main_indirect_extract_and_replace_route@20 main_read_boxes_route@21 main_boxes_exist_route@22 main_create_dynamic_arr_struct_route@23 main_delete_dynamic_arr_struct_route@24 main_append_dynamic_arr_struct_route@25 main_pop_dynamic_arr_struct_route@26 main_set_nested_struct_route@27 main_nested_write_route@28 main_nested_read_route@29 main_sum_dynamic_arr_struct_route@30 main_create_bools_route@31 main_set_bool_route@32 main_sum_bools_route@33 main_create_dynamic_box_route@34 main_delete_dynamic_box_route@35 main_append_dynamic_box_route@36 main_pop_dynamic_box_route@37 main_sum_dynamic_box_route@38 main_write_dynamic_box_route@39 main_write_dynamic_arr_struct_route@40 main_slice_box_route@41 main_arc4_box_route@42 main_test_box_ref_route@43 main_box_map_test_route@44 main_box_map_set_route@45 main_box_map_get_route@46 main_box_map_del_route@47 main_box_map_exists_route@48
    b main_switch_case_next@49

main_switch_case_next@49:
    b main_after_if_else@51

main_after_if_else@51:
    b main_after_if_else@53

main_after_if_else@53:
    // box_storage/contract.py:80
    // class BoxContract(arc4.ARC4Contract):
    err

main_box_map_exists_route@48:
    // box_storage/contract.py:504
    // @arc4.abimethod
    callsub box_map_exists
    b main_switch_case_next@49

main_box_map_del_route@47:
    // box_storage/contract.py:500
    // @arc4.abimethod
    callsub box_map_del
    b main_switch_case_next@49

main_box_map_get_route@46:
    // box_storage/contract.py:496
    // @arc4.abimethod
    callsub box_map_get
    b main_switch_case_next@49

main_box_map_set_route@45:
    // box_storage/contract.py:492
    // @arc4.abimethod
    callsub box_map_set
    b main_switch_case_next@49

main_box_map_test_route@44:
    // box_storage/contract.py:468
    // @arc4.abimethod
    callsub box_map_test
    b main_switch_case_next@49

main_test_box_ref_route@43:
    // box_storage/contract.py:420
    // @arc4.abimethod
    callsub test_box_ref
    b main_switch_case_next@49

main_arc4_box_route@42:
    // box_storage/contract.py:410
    // @arc4.abimethod
    callsub arc4_box
    b main_switch_case_next@49

main_slice_box_route@41:
    // box_storage/contract.py:401
    // @arc4.abimethod
    callsub slice_box
    b main_switch_case_next@49

main_write_dynamic_arr_struct_route@40:
    // box_storage/contract.py:397
    // @arc4.abimethod
    callsub write_dynamic_arr_struct
    b main_switch_case_next@49

main_write_dynamic_box_route@39:
    // box_storage/contract.py:393
    // @arc4.abimethod
    callsub write_dynamic_box
    b main_switch_case_next@49

main_sum_dynamic_box_route@38:
    // box_storage/contract.py:386
    // @arc4.abimethod
    callsub sum_dynamic_box
    b main_switch_case_next@49

main_pop_dynamic_box_route@37:
    // box_storage/contract.py:375
    // @arc4.abimethod
    callsub pop_dynamic_box
    b main_switch_case_next@49

main_append_dynamic_box_route@36:
    // box_storage/contract.py:360
    // @arc4.abimethod
    callsub append_dynamic_box
    b main_switch_case_next@49

main_delete_dynamic_box_route@35:
    // box_storage/contract.py:356
    // @arc4.abimethod
    callsub delete_dynamic_box
    b main_switch_case_next@49

main_create_dynamic_box_route@34:
    // box_storage/contract.py:352
    // @arc4.abimethod
    callsub create_dynamic_box
    b main_switch_case_next@49

main_sum_bools_route@33:
    // box_storage/contract.py:342
    // @arc4.abimethod()
    callsub sum_bools
    b main_switch_case_next@49

main_set_bool_route@32:
    // box_storage/contract.py:338
    // @arc4.abimethod
    callsub set_bool
    b main_switch_case_next@49

main_create_bools_route@31:
    // box_storage/contract.py:334
    // @arc4.abimethod
    callsub create_bools
    b main_switch_case_next@49

main_sum_dynamic_arr_struct_route@30:
    // box_storage/contract.py:323
    // @arc4.abimethod
    callsub sum_dynamic_arr_struct
    b main_switch_case_next@49

main_nested_read_route@29:
    // box_storage/contract.py:311
    // @arc4.abimethod()
    callsub nested_read
    b main_switch_case_next@49

main_nested_write_route@28:
    // box_storage/contract.py:301
    // @arc4.abimethod()
    callsub nested_write
    b main_switch_case_next@49

main_set_nested_struct_route@27:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    callsub set_nested_struct
    b main_switch_case_next@49

main_pop_dynamic_arr_struct_route@26:
    // box_storage/contract.py:265
    // @arc4.abimethod
    callsub pop_dynamic_arr_struct
    b main_switch_case_next@49

main_append_dynamic_arr_struct_route@25:
    // box_storage/contract.py:233
    // @arc4.abimethod
    callsub append_dynamic_arr_struct
    b main_switch_case_next@49

main_delete_dynamic_arr_struct_route@24:
    // box_storage/contract.py:229
    // @arc4.abimethod
    callsub delete_dynamic_arr_struct
    b main_switch_case_next@49

main_create_dynamic_arr_struct_route@23:
    // box_storage/contract.py:220
    // @arc4.abimethod
    callsub create_dynamic_arr_struct
    b main_switch_case_next@49

main_boxes_exist_route@22:
    // box_storage/contract.py:216
    // @arc4.abimethod
    callsub boxes_exist
    b main_switch_case_next@49

main_read_boxes_route@21:
    // box_storage/contract.py:207
    // @arc4.abimethod
    callsub read_boxes
    b main_switch_case_next@49

main_indirect_extract_and_replace_route@20:
    // box_storage/contract.py:201
    // @arc4.abimethod()
    callsub indirect_extract_and_replace
    b main_switch_case_next@49

main_delete_boxes_route@19:
    // box_storage/contract.py:188
    // @arc4.abimethod
    callsub delete_boxes
    b main_switch_case_next@49

main_sum_many_ints_route@18:
    // box_storage/contract.py:180
    // @arc4.abimethod()
    callsub sum_many_ints
    b main_switch_case_next@49

main_slice_big_bytes_route@17:
    // box_storage/contract.py:176
    // @arc4.abimethod()
    callsub slice_big_bytes
    b main_switch_case_next@49

main_assert_big_bytes_route@16:
    // box_storage/contract.py:172
    // @arc4.abimethod()
    callsub assert_big_bytes
    b main_switch_case_next@49

main_update_big_bytes_route@15:
    // box_storage/contract.py:168
    // @arc4.abimethod()
    callsub update_big_bytes
    b main_switch_case_next@49

main_create_big_bytes_route@14:
    // box_storage/contract.py:164
    // @arc4.abimethod()
    callsub create_big_bytes
    b main_switch_case_next@49

main_slice_big_fixed_bytes_route@13:
    // box_storage/contract.py:160
    // @arc4.abimethod()
    callsub slice_big_fixed_bytes
    b main_switch_case_next@49

main_assert_big_fixed_bytes_route@12:
    // box_storage/contract.py:156
    // @arc4.abimethod()
    callsub assert_big_fixed_bytes
    b main_switch_case_next@49

main_update_big_fixed_bytes_route@11:
    // box_storage/contract.py:152
    // @arc4.abimethod()
    callsub update_big_fixed_bytes
    b main_switch_case_next@49

main_create_big_fixed_bytes_route@10:
    // box_storage/contract.py:148
    // @arc4.abimethod()
    callsub create_big_fixed_bytes
    b main_switch_case_next@49

main_set_many_ints_route@9:
    // box_storage/contract.py:144
    // @arc4.abimethod()
    callsub set_many_ints
    b main_switch_case_next@49

main_create_many_ints_route@8:
    // box_storage/contract.py:140
    // @arc4.abimethod()
    callsub create_many_ints
    b main_switch_case_next@49

main_check_keys_route@7:
    // box_storage/contract.py:133
    // @arc4.abimethod
    callsub check_keys
    b main_switch_case_next@49

main_set_boxes_route@6:
    // box_storage/contract.py:97
    // @arc4.abimethod
    callsub set_boxes
    b main_switch_case_next@49

main_create_NoOp@50:
    b main_after_if_else@51

main___algopy_default_create@52:
    txn OnCompletion
    intc_0 // NoOp
    ==
    txn ApplicationID
    intc_0 // 0
    ==
    &&
    assert
    b main_block@55

main_block@55:
    b main_after_inlined_examples.box_storage.contract.BoxContract.__algopy_default_create@56

main_after_inlined_examples.box_storage.contract.BoxContract.__algopy_default_create@56:
    intc_2 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    b ensure_budget_block@0

ensure_budget_block@0:
    frame_dig -2
    pushint 10
    +
    b ensure_budget_while_top@1

ensure_budget_while_top@1:
    global OpcodeBudget
    frame_dig 0
    <
    bz ensure_budget_after_while@6
    b ensure_budget_while_body@2

ensure_budget_while_body@2:
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 23 // 0x068101
    itxn_field ApprovalProgram
    bytec 23 // 0x068101
    itxn_field ClearStateProgram
    intc_0 // 0
    intc_2 // 1
    frame_dig -1
    match ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// examples.box_storage.contract.get_box_value_plus_1(box: bytes) -> uint64:
get_box_value_plus_1:
    // box_storage/contract.py:509-510
    // @subroutine
    // def get_box_value_plus_1(box: Box[UInt64]) -> UInt64:
    proto 1 1
    b get_box_value_plus_1_block@0

get_box_value_plus_1_block@0:
    // box_storage/contract.py:511
    // return box.value + 1
    frame_dig -1
    box_get
    assert // check Box exists
    btoi
    intc_2 // 1
    +
    retsub


// examples.box_storage.contract.get_box_ref_length(ref: bytes) -> uint64:
get_box_ref_length:
    // box_storage/contract.py:514-515
    // @subroutine
    // def get_box_ref_length(ref: Box[Bytes]) -> UInt64:
    proto 1 1
    b get_box_ref_length_block@0

get_box_ref_length_block@0:
    // box_storage/contract.py:516
    // return ref.length
    frame_dig -1
    box_len
    assert // check Box exists
    retsub


// examples.box_storage.contract.get_box_map_value_from_key_plus_1(box_map: bytes, key: uint64) -> bytes:
get_box_map_value_from_key_plus_1:
    // box_storage/contract.py:519-520
    // @subroutine
    // def get_box_map_value_from_key_plus_1(box_map: BoxMap[UInt64, String], key: UInt64) -> String:
    proto 2 1
    b get_box_map_value_from_key_plus_1_block@0

get_box_map_value_from_key_plus_1_block@0:
    // box_storage/contract.py:521
    // return box_map[key + 1]
    frame_dig -1
    intc_2 // 1
    +
    itob
    frame_dig -2
    uncover 1
    concat
    box_get
    assert // check BoxMap entry exists
    retsub


// examples.box_storage.contract.BoxContract.set_boxes[routing]() -> void:
set_boxes:
    b set_boxes_block@0

set_boxes_block@0:
    // box_storage/contract.py:97
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    uncover 2
    uncover 2
    uncover 2
    callsub examples.box_storage.contract.BoxContract.set_boxes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.check_keys[routing]() -> void:
check_keys:
    b check_keys_block@0

check_keys_block@0:
    // box_storage/contract.py:133
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.check_keys
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_many_ints[routing]() -> void:
create_many_ints:
    b create_many_ints_block@0

create_many_ints_block@0:
    // box_storage/contract.py:140
    // @arc4.abimethod()
    callsub examples.box_storage.contract.BoxContract.create_many_ints
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.set_many_ints[routing]() -> void:
set_many_ints:
    b set_many_ints_block@0

set_many_ints_block@0:
    // box_storage/contract.py:144
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.set_many_ints
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_big_fixed_bytes[routing]() -> void:
create_big_fixed_bytes:
    b create_big_fixed_bytes_block@0

create_big_fixed_bytes_block@0:
    // box_storage/contract.py:148
    // @arc4.abimethod()
    callsub examples.box_storage.contract.BoxContract.create_big_fixed_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.update_big_fixed_bytes[routing]() -> void:
update_big_fixed_bytes:
    b update_big_fixed_bytes_block@0

update_big_fixed_bytes_block@0:
    // box_storage/contract.py:152
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub examples.box_storage.contract.BoxContract.update_big_fixed_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.assert_big_fixed_bytes[routing]() -> void:
assert_big_fixed_bytes:
    b assert_big_fixed_bytes_block@0

assert_big_fixed_bytes_block@0:
    // box_storage/contract.py:156
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub examples.box_storage.contract.BoxContract.assert_big_fixed_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.slice_big_fixed_bytes[routing]() -> void:
slice_big_fixed_bytes:
    b slice_big_fixed_bytes_block@0

slice_big_fixed_bytes_block@0:
    // box_storage/contract.py:160
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.slice_big_fixed_bytes
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_big_bytes[routing]() -> void:
create_big_bytes:
    b create_big_bytes_block@0

create_big_bytes_block@0:
    // box_storage/contract.py:164
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.create_big_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.update_big_bytes[routing]() -> void:
update_big_bytes:
    b update_big_bytes_block@0

update_big_bytes_block@0:
    // box_storage/contract.py:168
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub examples.box_storage.contract.BoxContract.update_big_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.assert_big_bytes[routing]() -> void:
assert_big_bytes:
    b assert_big_bytes_block@0

assert_big_bytes_block@0:
    // box_storage/contract.py:172
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub examples.box_storage.contract.BoxContract.assert_big_bytes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.slice_big_bytes[routing]() -> void:
slice_big_bytes:
    b slice_big_bytes_block@0

slice_big_bytes_block@0:
    // box_storage/contract.py:176
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.slice_big_bytes
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.sum_many_ints[routing]() -> void:
sum_many_ints:
    b sum_many_ints_block@0

sum_many_ints_block@0:
    // box_storage/contract.py:180
    // @arc4.abimethod()
    callsub examples.box_storage.contract.BoxContract.sum_many_ints
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.delete_boxes[routing]() -> void:
delete_boxes:
    b delete_boxes_block@0

delete_boxes_block@0:
    // box_storage/contract.py:188
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.delete_boxes
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.indirect_extract_and_replace[routing]() -> void:
indirect_extract_and_replace:
    b indirect_extract_and_replace_block@0

indirect_extract_and_replace_block@0:
    // box_storage/contract.py:201
    // @arc4.abimethod()
    callsub examples.box_storage.contract.BoxContract.indirect_extract_and_replace
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.read_boxes[routing]() -> void:
read_boxes:
    b read_boxes_block@0

read_boxes_block@0:
    // box_storage/contract.py:207
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.read_boxes
    cover 3
    cover 3
    cover 1
    itob
    bytec_0 // 0x
    uncover 1
    concat
    cover 1
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    pushint 20
    itob
    extract 6 2
    uncover 2
    uncover 1
    concat
    cover 1
    dup
    len
    pushint 20
    +
    itob
    extract 6 2
    uncover 2
    uncover 1
    concat
    uncover 2
    itob
    concat
    uncover 1
    concat
    uncover 1
    concat
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.boxes_exist[routing]() -> void:
boxes_exist:
    b boxes_exist_block@0

boxes_exist_block@0:
    // box_storage/contract.py:216
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.boxes_exist
    cover 3
    cover 2
    cover 1
    bytec 16 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_2 // 1
    uncover 2
    setbit
    intc_1 // 2
    uncover 2
    setbit
    pushint 3
    uncover 2
    setbit
    bytec_0 // 0x
    uncover 1
    concat
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_dynamic_arr_struct[routing]() -> void:
create_dynamic_arr_struct:
    b create_dynamic_arr_struct_block@0

create_dynamic_arr_struct_block@0:
    // box_storage/contract.py:220
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.create_dynamic_arr_struct
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct[routing]() -> void:
delete_dynamic_arr_struct:
    b delete_dynamic_arr_struct_block@0

delete_dynamic_arr_struct_block@0:
    // box_storage/contract.py:229
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.append_dynamic_arr_struct[routing]() -> void:
append_dynamic_arr_struct:
    b append_dynamic_arr_struct_block@0

append_dynamic_arr_struct_block@0:
    // box_storage/contract.py:233
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.append_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct[routing]() -> void:
pop_dynamic_arr_struct:
    b pop_dynamic_arr_struct_block@0

pop_dynamic_arr_struct_block@0:
    // box_storage/contract.py:265
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.set_nested_struct[routing]() -> void:
set_nested_struct:
    intc_0 // 0
    intc_0 // 0
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    b set_nested_struct_block@0

set_nested_struct_block@0:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dupn 2
    len
    dup
    cover 2
    cover 2
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 20
    ==
    assert // invalid tail pointer at index 1 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    uncover 2
    substring3
    dup
    len
    cover 1
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 2
    *
    cover 1
    dup
    len
    cover 1
    intc_1 // 2
    uncover 2
    substring3
    intc_0 // 0
    b set_nested_struct_for_header@1

set_nested_struct_for_header@1:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dup
    dig 4
    <
    bz set_nested_struct_after_for@4
    b set_nested_struct_for_body@2

set_nested_struct_for_body@2:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dup
    intc_1 // 2
    *
    dig 2
    dup
    cover 2
    uncover 1
    extract_uint16 // on error: invalid array encoding
    dup
    dig 5
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    cover 1
    uncover 2
    uncover 1
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    +
    bury 3
    b set_nested_struct_for_footer@3

set_nested_struct_for_footer@3:
    dup
    intc_2 // 1
    +
    bury 1
    b set_nested_struct_for_header@1

set_nested_struct_after_for@4:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 2
    intc_1 // 2
    +
    pushint 18
    +
    pushint 20
    +
    dup
    bury 14
    dig 6
    dup
    cover 2
    pushint 10
    extract_uint16 // on error: invalid tuple encoding
    dup
    uncover 2
    ==
    assert // invalid tail pointer at index 2 of (uint64,(uint64,(len+(len+uint64[])[]),uint64),(len+(uint64,(len+(len+uint64[])[]),uint64)[]),uint64)
    dig 6
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 12
    intc_1 // 2
    *
    bury 9
    dup
    len
    cover 1
    intc_1 // 2
    uncover 2
    substring3
    bury 15
    intc_0 // 0
    bury 12
    b set_nested_struct_for_header@5

set_nested_struct_for_header@5:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 11
    dig 10
    <
    bz set_nested_struct_after_for@12
    b set_nested_struct_for_body@6

set_nested_struct_for_body@6:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 11
    intc_1 // 2
    *
    dig 15
    dup
    cover 2
    uncover 1
    extract_uint16 // on error: invalid array encoding
    dup
    dig 10
    ==
    assert // invalid tail pointer for (len+(uint64,(len+(len+uint64[])[]),uint64)[])
    dig 1
    len
    cover 1
    uncover 2
    uncover 1
    uncover 2
    substring3
    dup
    len
    cover 1
    dup
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 18
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+(len+uint64[])[]),uint64)
    uncover 2
    substring3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 11
    intc_1 // 2
    *
    bury 8
    dup
    len
    cover 1
    intc_1 // 2
    uncover 2
    substring3
    bury 14
    intc_0 // 0
    bury 11
    b set_nested_struct_for_header@7

set_nested_struct_for_header@7:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 10
    dig 9
    <
    bz set_nested_struct_after_for@10
    b set_nested_struct_for_body@8

set_nested_struct_for_body@8:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 10
    intc_1 // 2
    *
    dig 14
    dup
    cover 2
    uncover 1
    extract_uint16 // on error: invalid array encoding
    dup
    dig 9
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    cover 1
    uncover 2
    uncover 1
    uncover 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    +
    bury 7
    b set_nested_struct_for_footer@9

set_nested_struct_for_footer@9:
    dig 10
    intc_2 // 1
    +
    bury 11
    b set_nested_struct_for_header@7

set_nested_struct_after_for@10:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 6
    intc_1 // 2
    +
    pushint 18
    +
    dig 8
    +
    bury 8
    b set_nested_struct_for_footer@11

set_nested_struct_for_footer@11:
    dig 11
    intc_2 // 1
    +
    bury 12
    b set_nested_struct_for_header@5

set_nested_struct_after_for@12:
    // box_storage/contract.py:287
    // @arc4.abimethod()
    dig 7
    intc_1 // 2
    +
    dig 13
    +
    dig 6
    dup
    cover 2
    len
    ==
    assert // invalid number of bytes for examples.box_storage.contract.NestedStruct
    callsub examples.box_storage.contract.BoxContract.set_nested_struct
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.nested_write[routing]() -> void:
nested_write:
    b nested_write_block@0

nested_write_block@0:
    // box_storage/contract.py:301
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.nested_write
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.nested_read[routing]() -> void:
nested_read:
    b nested_read_block@0

nested_read_block@0:
    // box_storage/contract.py:311
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    uncover 2
    uncover 2
    uncover 2
    callsub examples.box_storage.contract.BoxContract.nested_read
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct[routing]() -> void:
sum_dynamic_arr_struct:
    b sum_dynamic_arr_struct_block@0

sum_dynamic_arr_struct_block@0:
    // box_storage/contract.py:323
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_bools[routing]() -> void:
create_bools:
    b create_bools_block@0

create_bools_block@0:
    // box_storage/contract.py:334
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.create_bools
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.set_bool[routing]() -> void:
set_bool:
    b set_bool_block@0

set_bool_block@0:
    // box_storage/contract.py:338
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    callsub examples.box_storage.contract.BoxContract.set_bool
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.sum_bools[routing]() -> void:
sum_bools:
    b sum_bools_block@0

sum_bools_block@0:
    // box_storage/contract.py:342
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.sum_bools
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.create_dynamic_box[routing]() -> void:
create_dynamic_box:
    b create_dynamic_box_block@0

create_dynamic_box_block@0:
    // box_storage/contract.py:352
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.create_dynamic_box
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.delete_dynamic_box[routing]() -> void:
delete_dynamic_box:
    b delete_dynamic_box_block@0

delete_dynamic_box_block@0:
    // box_storage/contract.py:356
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.delete_dynamic_box
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.append_dynamic_box[routing]() -> void:
append_dynamic_box:
    b append_dynamic_box_block@0

append_dynamic_box_block@0:
    // box_storage/contract.py:360
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.append_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.pop_dynamic_box[routing]() -> void:
pop_dynamic_box:
    b pop_dynamic_box_block@0

pop_dynamic_box_block@0:
    // box_storage/contract.py:375
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.pop_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.sum_dynamic_box[routing]() -> void:
sum_dynamic_box:
    b sum_dynamic_box_block@0

sum_dynamic_box_block@0:
    // box_storage/contract.py:386
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.sum_dynamic_box
    itob
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.write_dynamic_box[routing]() -> void:
write_dynamic_box:
    b write_dynamic_box_block@0

write_dynamic_box_block@0:
    // box_storage/contract.py:393
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.write_dynamic_box
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.write_dynamic_arr_struct[routing]() -> void:
write_dynamic_arr_struct:
    b write_dynamic_arr_struct_block@0

write_dynamic_arr_struct_block@0:
    // box_storage/contract.py:397
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.write_dynamic_arr_struct
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.slice_box[routing]() -> void:
slice_box:
    b slice_box_block@0

slice_box_block@0:
    // box_storage/contract.py:401
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.slice_box
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.arc4_box[routing]() -> void:
arc4_box:
    b arc4_box_block@0

arc4_box_block@0:
    // box_storage/contract.py:410
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.arc4_box
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.test_box_ref[routing]() -> void:
test_box_ref:
    b test_box_ref_block@0

test_box_ref_block@0:
    // box_storage/contract.py:420
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.test_box_ref
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_test[routing]() -> void:
box_map_test:
    b box_map_test_block@0

box_map_test_block@0:
    // box_storage/contract.py:468
    // @arc4.abimethod
    callsub examples.box_storage.contract.BoxContract.box_map_test
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_set[routing]() -> void:
box_map_set:
    b box_map_set_block@0

box_map_set_block@0:
    // box_storage/contract.py:492
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 1
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub examples.box_storage.contract.BoxContract.box_map_set
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_get[routing]() -> void:
box_map_get:
    b box_map_get_block@0

box_map_get_block@0:
    // box_storage/contract.py:496
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.box_map_get
    dup
    len
    itob
    extract 6 2
    uncover 1
    concat
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_del[routing]() -> void:
box_map_del:
    b box_map_del_block@0

box_map_del_block@0:
    // box_storage/contract.py:500
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.box_map_del
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.box_map_exists[routing]() -> void:
box_map_exists:
    b box_map_exists_block@0

box_map_exists_block@0:
    // box_storage/contract.py:504
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub examples.box_storage.contract.BoxContract.box_map_exists
    bytec 16 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 5 // 0x151f7c75
    uncover 1
    concat
    log
    intc_2 // 1
    return


// examples.box_storage.contract.BoxContract.__init__() -> void:
__init__:
    b __init___block@0

__init___block@0:
    // box_storage/contract.py:90
    // assert size_of(ManyInts) > 4096, "expected ManyInts to exceed max bytes size"
    pushint 4104
    intc 5 // 4096
    >
    assert // expected ManyInts to exceed max bytes size
    retsub


// examples.box_storage.contract.BoxContract.set_boxes(a: uint64, b: bytes, c: bytes) -> void:
examples.box_storage.contract.BoxContract.set_boxes:
    // box_storage/contract.py:97-98
    // @arc4.abimethod
    // def set_boxes(self, a: UInt64, b: arc4.DynamicBytes, c: arc4.String) -> None:
    proto 3 0
    b examples.box_storage.contract.BoxContract.set_boxes_block@0

examples.box_storage.contract.BoxContract.set_boxes_block@0:
    // box_storage/contract.py:99
    // self.box_a.value = a
    frame_dig -3
    itob
    bytec 8 // "box_a"
    uncover 1
    box_put
    // box_storage/contract.py:100
    // self.box_b.value = b.copy()
    bytec 9 // "b"
    box_del
    pop
    bytec 9 // "b"
    frame_dig -2
    box_put
    // box_storage/contract.py:101
    // self.box_c.value = c
    bytec 4 // 0x424f585f43
    box_del
    pop
    bytec 4 // 0x424f585f43
    frame_dig -1
    box_put
    // box_storage/contract.py:102
    // self.box_d.value = b.native
    frame_dig -2
    extract 2 0
    bytec 7 // "box_d"
    box_del
    pop
    bytec 7 // "box_d"
    uncover 1
    box_put
    // box_storage/contract.py:103
    // self.box_large.create()
    bytec 10 // "box_large"
    pushint 6160
    box_create
    pop
    // box_storage/contract.py:104
    // self.box_large.value.e = UInt64(42)
    pushint 42
    itob
    intc_0 // 0
    intc 5 // 4096
    +
    bytec 10 // "box_large"
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:105
    // self.box_large.replace(size_of(Bytes1024) * 4, arc4.UInt64(42).bytes)
    pushint 1024
    pushint 4
    *
    bytec 10 // "box_large"
    uncover 1
    pushbytes 0x000000000000002a
    box_replace
    // box_storage/contract.py:107
    // b_value = self.box_b.value.copy()
    bytec 9 // "b"
    box_get
    assert // check self.box_b exists
    // box_storage/contract.py:108
    // assert self.box_b.value.length == b_value.length, "direct reference should match copy"
    bytec 9 // "b"
    intc_0 // 0
    intc_1 // 2
    box_extract
    btoi
    uncover 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    ==
    assert // direct reference should match copy
    // box_storage/contract.py:110
    // self.box_a.value += 3
    bytec 8 // "box_a"
    box_get
    assert // check self.box_a exists
    btoi
    pushint 3
    +
    itob
    bytec 8 // "box_a"
    uncover 1
    box_put
    // box_storage/contract.py:112-113
    // # test .length
    // assert self.box_a.length == 8
    bytec 8 // "box_a"
    box_len
    assert // check self.box_a exists
    intc_3 // 8
    ==
    assert
    // box_storage/contract.py:114
    // assert self.box_b.length == b.bytes.length
    bytec 9 // "b"
    box_len
    assert // check self.box_b exists
    frame_dig -2
    len
    ==
    assert
    // box_storage/contract.py:115
    // assert self.box_c.length == c.bytes.length
    bytec 4 // 0x424f585f43
    box_len
    assert // check self.box_c exists
    frame_dig -1
    len
    ==
    assert
    // box_storage/contract.py:116
    // assert self.box_d.length == b.native.length
    bytec 7 // "box_d"
    box_len
    assert // check self.box_d exists
    frame_dig -2
    extract 2 0
    len
    ==
    assert
    // box_storage/contract.py:118-119
    // # test .value.bytes
    // assert self.box_c.value.bytes[0] == c.bytes[0]
    bytec 4 // 0x424f585f43
    intc_0 // 0
    intc_2 // 1
    box_extract
    frame_dig -1
    intc_0 // 0
    intc_2 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:120
    // assert self.box_c.value.bytes[-1] == c.bytes[-1]
    bytec 4 // 0x424f585f43
    box_len
    cover 1
    intc_2 // 1
    -
    bytec 4 // 0x424f585f43
    uncover 1
    intc_2 // 1
    box_extract
    frame_dig -1
    len
    intc_2 // 1
    -
    frame_dig -1
    uncover 1
    intc_2 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:121
    // assert self.box_c.value.bytes[:-1] == c.bytes[:-1]
    bytec 4 // 0x424f585f43
    box_len
    cover 1
    intc_2 // 1
    dig 1
    >=
    intc_2 // 1
    dig 2
    uncover 2
    select
    -
    intc_0 // 0
    -
    bytec 4 // 0x424f585f43
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -1
    len
    intc_2 // 1
    dig 1
    >=
    intc_2 // 1
    dig 2
    uncover 2
    select
    -
    frame_dig -1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:122
    // assert self.box_c.value.bytes[:2] == c.bytes[:2]
    bytec 4 // 0x424f585f43
    box_len
    cover 1
    intc_1 // 2
    dig 1
    >=
    intc_1 // 2
    uncover 2
    uncover 2
    select
    intc_0 // 0
    -
    bytec 4 // 0x424f585f43
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -1
    len
    intc_1 // 2
    dig 1
    >=
    intc_1 // 2
    uncover 2
    uncover 2
    select
    frame_dig -1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:124-125
    // # test .value with Bytes type
    // assert self.box_d.value[0] == b.native[0]
    bytec 7 // "box_d"
    intc_0 // 0
    intc_2 // 1
    box_extract
    frame_dig -2
    extract 2 0
    intc_0 // 0
    intc_2 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:126
    // assert self.box_d.value[-1] == b.native[-1]
    bytec 7 // "box_d"
    box_len
    cover 1
    intc_2 // 1
    -
    bytec 7 // "box_d"
    uncover 1
    intc_2 // 1
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_2 // 1
    -
    intc_2 // 1
    extract3
    ==
    assert
    // box_storage/contract.py:127
    // assert self.box_d.value[:-1] == b.native[:-1]
    bytec 7 // "box_d"
    box_len
    cover 1
    intc_2 // 1
    dig 1
    >=
    intc_2 // 1
    dig 2
    uncover 2
    select
    -
    intc_0 // 0
    -
    bytec 7 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_2 // 1
    dig 1
    >=
    intc_2 // 1
    dig 2
    uncover 2
    select
    -
    uncover 1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:128
    // assert self.box_d.value[:5] == b.native[:5]
    bytec 7 // "box_d"
    box_len
    cover 1
    pushint 5
    dig 1
    >=
    pushint 5
    uncover 2
    uncover 2
    select
    intc_0 // 0
    -
    bytec 7 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    pushint 5
    dig 1
    >=
    pushint 5
    uncover 2
    uncover 2
    select
    uncover 1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:129
    // assert self.box_d.value[: UInt64(2)] == b.native[: UInt64(2)]
    bytec 7 // "box_d"
    box_len
    cover 1
    intc_1 // 2
    dig 1
    >=
    intc_1 // 2
    uncover 2
    uncover 2
    select
    intc_0 // 0
    -
    bytec 7 // "box_d"
    intc_0 // 0
    uncover 2
    box_extract
    frame_dig -2
    extract 2 0
    dup
    len
    intc_1 // 2
    dig 1
    >=
    intc_1 // 2
    uncover 2
    uncover 2
    select
    uncover 1
    intc_0 // 0
    uncover 2
    substring3
    ==
    assert
    // box_storage/contract.py:131
    // assert self.box_large.length == size_of(LargeStruct)
    bytec 10 // "box_large"
    box_len
    assert // check self.box_large exists
    pushint 6160
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.check_keys() -> void:
examples.box_storage.contract.BoxContract.check_keys:
    b examples.box_storage.contract.BoxContract.check_keys_block@0

examples.box_storage.contract.BoxContract.check_keys_block@0:
    // box_storage/contract.py:135
    // assert self.box_a.key == b"box_a", "box a key ok"
    bytec 8 // "box_a"
    bytec 8 // 0x626f785f61
    ==
    assert // box a key ok
    // box_storage/contract.py:136
    // assert self.box_b.key == b"b", "box b key ok"
    bytec 9 // "b"
    bytec 9 // 0x62
    ==
    assert // box b key ok
    // box_storage/contract.py:137
    // assert self.box_c.key == b"BOX_C", "box c key ok"
    bytec 4 // 0x424f585f43
    bytec 4 // 0x424f585f43
    ==
    assert // box c key ok
    // box_storage/contract.py:138
    // assert self.box_large.key == b"box_large", "box large key ok"
    bytec 10 // "box_large"
    bytec 10 // 0x626f785f6c61726765
    ==
    assert // box large key ok
    retsub


// examples.box_storage.contract.BoxContract.create_many_ints() -> void:
examples.box_storage.contract.BoxContract.create_many_ints:
    b examples.box_storage.contract.BoxContract.create_many_ints_block@0

examples.box_storage.contract.BoxContract.create_many_ints_block@0:
    // box_storage/contract.py:142
    // self.many_ints.create()
    bytec 17 // "many_ints"
    pushint 4104
    box_create
    pop
    retsub


// examples.box_storage.contract.BoxContract.set_many_ints(index: uint64, value: uint64) -> void:
examples.box_storage.contract.BoxContract.set_many_ints:
    // box_storage/contract.py:144-145
    // @arc4.abimethod()
    // def set_many_ints(self, index: UInt64, value: UInt64) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.set_many_ints_block@0

examples.box_storage.contract.BoxContract.set_many_ints_block@0:
    // box_storage/contract.py:146
    // self.many_ints.value[index] = value
    frame_dig -1
    itob
    frame_dig -2
    intc_3 // 8
    *
    intc_0 // 0
    +
    bytec 17 // "many_ints"
    uncover 1
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.create_big_fixed_bytes() -> void:
examples.box_storage.contract.BoxContract.create_big_fixed_bytes:
    b examples.box_storage.contract.BoxContract.create_big_fixed_bytes_block@0

examples.box_storage.contract.BoxContract.create_big_fixed_bytes_block@0:
    // box_storage/contract.py:150
    // self.big_fixed_bytes.create()
    bytec 18 // "big_fixed_bytes"
    intc 6 // 5000
    box_create
    pop
    retsub


// examples.box_storage.contract.BoxContract.update_big_fixed_bytes(start_index: uint64, value: bytes) -> void:
examples.box_storage.contract.BoxContract.update_big_fixed_bytes:
    // box_storage/contract.py:152-153
    // @arc4.abimethod()
    // def update_big_fixed_bytes(self, start_index: UInt64, value: Bytes) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.update_big_fixed_bytes_block@0

examples.box_storage.contract.BoxContract.update_big_fixed_bytes_block@0:
    // box_storage/contract.py:154
    // self.big_fixed_bytes.splice(start_index, value.length, value)
    frame_dig -1
    len
    bytec 18 // "big_fixed_bytes"
    frame_dig -2
    uncover 2
    frame_dig -1
    box_splice
    retsub


// examples.box_storage.contract.BoxContract.assert_big_fixed_bytes(index: uint64, value: bytes) -> void:
examples.box_storage.contract.BoxContract.assert_big_fixed_bytes:
    // box_storage/contract.py:156-157
    // @arc4.abimethod()
    // def assert_big_fixed_bytes(self, index: UInt64, value: Bytes) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.assert_big_fixed_bytes_block@0

examples.box_storage.contract.BoxContract.assert_big_fixed_bytes_block@0:
    // box_storage/contract.py:158
    // assert self.big_fixed_bytes.value[index] == value
    bytec 18 // "big_fixed_bytes"
    frame_dig -2
    intc_2 // 1
    box_extract
    frame_dig -1
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.slice_big_fixed_bytes(start: uint64, end: uint64) -> bytes:
examples.box_storage.contract.BoxContract.slice_big_fixed_bytes:
    // box_storage/contract.py:160-161
    // @arc4.abimethod()
    // def slice_big_fixed_bytes(self, start: UInt64, end: UInt64) -> Bytes:
    proto 2 1
    b examples.box_storage.contract.BoxContract.slice_big_fixed_bytes_block@0

examples.box_storage.contract.BoxContract.slice_big_fixed_bytes_block@0:
    // box_storage/contract.py:162
    // return self.big_fixed_bytes.value[start:end]
    frame_dig -2
    intc 6 // 5000
    >=
    frame_dig -2
    intc 6 // 5000
    uncover 2
    select
    frame_dig -1
    intc 6 // 5000
    >=
    frame_dig -1
    intc 6 // 5000
    uncover 2
    select
    dup
    dig 2
    <
    uncover 1
    dig 2
    uncover 2
    select
    dig 1
    -
    bytec 18 // "big_fixed_bytes"
    uncover 2
    uncover 2
    box_extract
    retsub


// examples.box_storage.contract.BoxContract.create_big_bytes(size: uint64) -> void:
examples.box_storage.contract.BoxContract.create_big_bytes:
    // box_storage/contract.py:164-165
    // @arc4.abimethod()
    // def create_big_bytes(self, size: UInt64) -> None:
    proto 1 0
    b examples.box_storage.contract.BoxContract.create_big_bytes_block@0

examples.box_storage.contract.BoxContract.create_big_bytes_block@0:
    // box_storage/contract.py:166
    // self.big_bytes.create(size=size)
    bytec 12 // "big_bytes"
    frame_dig -1
    box_create
    pop
    retsub


// examples.box_storage.contract.BoxContract.update_big_bytes(start_index: uint64, value: bytes) -> void:
examples.box_storage.contract.BoxContract.update_big_bytes:
    // box_storage/contract.py:168-169
    // @arc4.abimethod()
    // def update_big_bytes(self, start_index: UInt64, value: Bytes) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.update_big_bytes_block@0

examples.box_storage.contract.BoxContract.update_big_bytes_block@0:
    // box_storage/contract.py:170
    // self.big_bytes.splice(start_index, value.length, value)
    frame_dig -1
    len
    bytec 12 // "big_bytes"
    frame_dig -2
    uncover 2
    frame_dig -1
    box_splice
    retsub


// examples.box_storage.contract.BoxContract.assert_big_bytes(index: uint64, value: bytes) -> void:
examples.box_storage.contract.BoxContract.assert_big_bytes:
    // box_storage/contract.py:172-173
    // @arc4.abimethod()
    // def assert_big_bytes(self, index: UInt64, value: Bytes) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.assert_big_bytes_block@0

examples.box_storage.contract.BoxContract.assert_big_bytes_block@0:
    // box_storage/contract.py:174
    // assert self.big_bytes.value[index] == value
    bytec 12 // "big_bytes"
    frame_dig -2
    intc_2 // 1
    box_extract
    frame_dig -1
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.slice_big_bytes(start: uint64, end: uint64) -> bytes:
examples.box_storage.contract.BoxContract.slice_big_bytes:
    // box_storage/contract.py:176-177
    // @arc4.abimethod()
    // def slice_big_bytes(self, start: UInt64, end: UInt64) -> Bytes:
    proto 2 1
    b examples.box_storage.contract.BoxContract.slice_big_bytes_block@0

examples.box_storage.contract.BoxContract.slice_big_bytes_block@0:
    // box_storage/contract.py:178
    // return self.big_bytes.value[start:end]
    bytec 12 // "big_bytes"
    box_len
    cover 1
    frame_dig -2
    dig 1
    >=
    frame_dig -2
    dig 2
    uncover 2
    select
    cover 1
    frame_dig -1
    dig 1
    >=
    frame_dig -1
    uncover 2
    uncover 2
    select
    dup
    dig 2
    <
    uncover 1
    dig 2
    uncover 2
    select
    dig 1
    -
    bytec 12 // "big_bytes"
    uncover 2
    uncover 2
    box_extract
    uncover 1
    retsub


// examples.box_storage.contract.BoxContract.sum_many_ints() -> uint64:
examples.box_storage.contract.BoxContract.sum_many_ints:
    // box_storage/contract.py:180-181
    // @arc4.abimethod()
    // def sum_many_ints(self) -> UInt64:
    proto 0 1
    b examples.box_storage.contract.BoxContract.sum_many_ints_block@0

examples.box_storage.contract.BoxContract.sum_many_ints_block@0:
    // box_storage/contract.py:182
    // ensure_budget(10_500)
    pushint 10500
    intc_0 // 0
    callsub ensure_budget
    // box_storage/contract.py:183
    // total = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:184
    // for val in self.many_ints.value:
    bytec 17 // "many_ints"
    box_get
    assert // check self.many_ints exists
    intc_0 // 0
    b examples.box_storage.contract.BoxContract.sum_many_ints_for_header@1

examples.box_storage.contract.BoxContract.sum_many_ints_for_header@1:
    // box_storage/contract.py:184
    // for val in self.many_ints.value:
    frame_dig 2
    pushint 513
    <
    bz examples.box_storage.contract.BoxContract.sum_many_ints_after_for@4
    b examples.box_storage.contract.BoxContract.sum_many_ints_for_body@2

examples.box_storage.contract.BoxContract.sum_many_ints_for_body@2:
    // box_storage/contract.py:184
    // for val in self.many_ints.value:
    frame_dig 2
    intc_3 // 8
    *
    intc_0 // 0
    +
    bytec 17 // "many_ints"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:185
    // total = total + val
    frame_dig 0
    +
    frame_bury 0
    b examples.box_storage.contract.BoxContract.sum_many_ints_for_footer@3

examples.box_storage.contract.BoxContract.sum_many_ints_for_footer@3:
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    b examples.box_storage.contract.BoxContract.sum_many_ints_for_header@1

examples.box_storage.contract.BoxContract.sum_many_ints_after_for@4:
    // box_storage/contract.py:186
    // return total
    retsub


// examples.box_storage.contract.BoxContract.delete_boxes() -> void:
examples.box_storage.contract.BoxContract.delete_boxes:
    b examples.box_storage.contract.BoxContract.delete_boxes_block@0

examples.box_storage.contract.BoxContract.delete_boxes_block@0:
    // box_storage/contract.py:190
    // del self.box_a.value
    bytec 8 // "box_a"
    box_del
    pop
    // box_storage/contract.py:191
    // del self.box_b.value
    bytec 9 // "b"
    box_del
    pop
    // box_storage/contract.py:192
    // del self.box_c.value
    bytec 4 // 0x424f585f43
    box_del
    pop
    // box_storage/contract.py:193
    // assert self.box_a.get(default=UInt64(42)) == 42
    bytec 8 // "box_a"
    box_get
    cover 1
    btoi
    pushint 42
    uncover 1
    uncover 2
    select
    pushint 42
    ==
    assert
    // box_storage/contract.py:194
    // assert self.box_b.get(default=arc4.DynamicBytes(b"42")).native == b"42"
    bytec 11 // 0x3432
    len
    itob
    extract 6 2
    bytec 11 // 0x3432
    concat
    bytec 9 // "b"
    box_get
    cover 1
    uncover 2
    uncover 1
    uncover 2
    select
    extract 2 0
    bytec 11 // 0x3432
    ==
    assert
    // box_storage/contract.py:195
    // assert self.box_c.get(default=arc4.String("42")) == "42"
    bytec 11 // "42"
    len
    itob
    extract 6 2
    bytec 11 // "42"
    concat
    bytec 4 // 0x424f585f43
    box_get
    cover 1
    uncover 2
    uncover 1
    uncover 2
    select
    bytec 11 // "42"
    len
    itob
    extract 6 2
    bytec 11 // "42"
    concat
    ==
    assert
    // box_storage/contract.py:196
    // a, a_exists = self.box_a.maybe()
    bytec 8 // "box_a"
    box_get
    cover 1
    btoi
    cover 1
    // box_storage/contract.py:197
    // assert not a_exists
    !
    assert
    // box_storage/contract.py:198
    // assert a == 0
    intc_0 // 0
    ==
    assert
    // box_storage/contract.py:199
    // del self.box_large.value
    bytec 10 // "box_large"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.indirect_extract_and_replace() -> void:
examples.box_storage.contract.BoxContract.indirect_extract_and_replace:
    b examples.box_storage.contract.BoxContract.indirect_extract_and_replace_block@0

examples.box_storage.contract.BoxContract.indirect_extract_and_replace_block@0:
    // box_storage/contract.py:203
    // large = self.box_large.value.copy()
    bytec 10 // "box_large"
    box_get
    assert // check self.box_large exists
    // box_storage/contract.py:204
    // large.e += 1
    dup
    intc 5 // 4096
    intc_3 // 8
    extract3
    btoi
    intc_2 // 1
    +
    itob
    uncover 1
    intc 5 // 4096
    uncover 2
    replace3
    // box_storage/contract.py:205
    // self.box_large.value = large.copy()
    bytec 10 // "box_large"
    uncover 1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.read_boxes() -> uint64, bytes, bytes, uint64:
examples.box_storage.contract.BoxContract.read_boxes:
    b examples.box_storage.contract.BoxContract.read_boxes_block@0

examples.box_storage.contract.BoxContract.read_boxes_block@0:
    // box_storage/contract.py:210
    // get_box_value_plus_1(self.box_a) - 1,
    bytec 8 // "box_a"
    callsub get_box_value_plus_1
    intc_2 // 1
    -
    // box_storage/contract.py:211
    // self.box_b.value.native,
    bytec 9 // "b"
    box_get
    assert // check self.box_b exists
    extract 2 0
    // box_storage/contract.py:212
    // self.box_c.value,
    bytec 4 // 0x424f585f43
    box_get
    assert // check self.box_c exists
    // box_storage/contract.py:213
    // self.box_large.value.e,
    intc_0 // 0
    intc 5 // 4096
    +
    bytec 10 // "box_large"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:209-214
    // return (
    //     get_box_value_plus_1(self.box_a) - 1,
    //     self.box_b.value.native,
    //     self.box_c.value,
    //     self.box_large.value.e,
    // )
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    retsub


// examples.box_storage.contract.BoxContract.boxes_exist() -> uint64, uint64, uint64, uint64:
examples.box_storage.contract.BoxContract.boxes_exist:
    // box_storage/contract.py:216-217
    // @arc4.abimethod
    // def boxes_exist(self) -> tuple[bool, bool, bool, bool]:
    proto 0 4
    b examples.box_storage.contract.BoxContract.boxes_exist_block@0

examples.box_storage.contract.BoxContract.boxes_exist_block@0:
    // box_storage/contract.py:218
    // return bool(self.box_a), bool(self.box_b), bool(self.box_c), bool(self.box_large)
    bytec 8 // "box_a"
    box_len
    bytec 9 // "b"
    box_len
    cover 1
    cover 2
    bytec 4 // 0x424f585f43
    box_len
    cover 1
    cover 3
    bytec 10 // "box_large"
    box_len
    cover 1
    cover 4
    uncover 3
    uncover 3
    uncover 3
    uncover 3
    uncover 7
    uncover 7
    uncover 7
    uncover 7
    retsub


// examples.box_storage.contract.BoxContract.create_dynamic_arr_struct() -> void:
examples.box_storage.contract.BoxContract.create_dynamic_arr_struct:
    b examples.box_storage.contract.BoxContract.create_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.create_dynamic_arr_struct_block@0:
    // box_storage/contract.py:223
    // a=Txn.num_app_args,
    txn NumAppArgs
    // box_storage/contract.py:224
    // arr=Array[UInt64](),
    intc_0 // 0
    itob
    extract 6 2
    cover 1
    // box_storage/contract.py:225
    // b=Txn.num_app_args * 2,
    txn NumAppArgs
    intc_1 // 2
    *
    cover 2
    // box_storage/contract.py:226
    // arr2=Array[UInt64](),
    intc_0 // 0
    itob
    extract 6 2
    cover 3
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    itob
    bytec_0 // 0x
    uncover 1
    concat
    pushint 20
    itob
    extract 6 2
    concat
    dig 1
    len
    pushint 20
    +
    uncover 3
    itob
    uncover 2
    uncover 1
    concat
    uncover 1
    itob
    extract 6 2
    concat
    uncover 1
    concat
    uncover 1
    concat
    // box_storage/contract.py:222
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    box_del
    pop
    // box_storage/contract.py:222
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:222-227
    // self.dynamic_arr_struct.value = DynamicArrayInAStruct(
    //     a=Txn.num_app_args,
    //     arr=Array[UInt64](),
    //     b=Txn.num_app_args * 2,
    //     arr2=Array[UInt64](),
    // )
    uncover 1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct() -> void:
examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct:
    b examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.delete_dynamic_arr_struct_block@0:
    // box_storage/contract.py:231
    // del self.dynamic_arr_struct.value
    bytec_1 // "dynamic_arr_struct"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.append_dynamic_arr_struct(times: uint64) -> uint64:
examples.box_storage.contract.BoxContract.append_dynamic_arr_struct:
    // box_storage/contract.py:233-234
    // @arc4.abimethod
    // def append_dynamic_arr_struct(self, times: UInt64) -> UInt64:
    proto 1 1
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@0:
    // box_storage/contract.py:235-237
    // # TODO: support append using high level array operations, instead of
    // #       relying on struct layout tricks with FixedArrayInAStruct
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    intc_0 // 0
    pushint 10
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    intc_1 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:238
    // arr_len = self.dynamic_arr_struct.value.arr.length
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    dup
    // box_storage/contract.py:239
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    intc_0 // 0
    pushint 18
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    // box_storage/contract.py:243
    // get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    uncover 1
    frame_dig -1
    +
    cover 1
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@9

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@9:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 7
    frame_bury 0
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@10

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@10:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 0
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 1
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@11

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@11:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 1
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    frame_dig 8
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    frame_bury 3
    // box_storage/contract.py:243
    // get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@12

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@12:
    // box_storage/contract.py:241-242
    // # expand box
    // self.dynamic_arr_struct.resize(
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:241-244
    // # expand box
    // self.dynamic_arr_struct.resize(
    //     get_dynamic_arr2_struct_byte_index(arr_len + times, arr2_len)
    // )
    frame_dig 3
    box_resize
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    frame_dig 6
    frame_bury 0
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@13

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@13:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 0
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 4
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@14

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@14:
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    frame_dig -1
    intc_3 // 8
    *
    bzero
    // box_storage/contract.py:245-246
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:245-248
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    frame_dig 4
    // box_storage/contract.py:247
    // get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    intc_0 // 0
    // box_storage/contract.py:245-248
    // # splice in zero bytes so existing data is in correct location
    // self.dynamic_arr_struct.splice(
    //     get_dynamic_arr_struct_byte_index(arr_len), 0, op.bzero(times * size_of(UInt64))
    // )
    uncover 3
    box_splice
    // box_storage/contract.py:251
    // for i in urange(times):
    intc_2 // 1
    assert // Step cannot be zero
    intc_0 // 0
    frame_bury 5
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_header@1

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_header@1:
    // box_storage/contract.py:251
    // for i in urange(times):
    frame_dig 5
    frame_dig -1
    <
    bz examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_for@4
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_body@2

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_body@2:
    // box_storage/contract.py:251
    // for i in urange(times):
    frame_dig 5
    // box_storage/contract.py:252
    // box.value.arr.arr[arr_len] = i
    itob
    intc_0 // 0
    pushint 20
    +
    intc_1 // 2
    +
    frame_dig 6
    dup
    cover 2
    intc_3 // 8
    *
    +
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:252
    // box.value.arr.arr[arr_len] = i
    uncover 1
    uncover 3
    box_replace
    // box_storage/contract.py:253
    // arr_len += 1
    intc_2 // 1
    +
    frame_bury 6
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_footer@3

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_footer@3:
    // box_storage/contract.py:251
    // for i in urange(times):
    frame_dig 5
    intc_2 // 1
    +
    frame_bury 5
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_for_header@1

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_for@4:
    // box_storage/contract.py:254
    // box.value.arr.length = arc4.UInt16(arr_len)
    frame_dig 6
    dup
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    pushint 20
    +
    intc_0 // 0
    +
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:254
    // box.value.arr.length = arc4.UInt16(arr_len)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:255-256
    // # when calculating arr2_offset need to sub 2 from 0th index to account for length bytes
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    frame_bury 7
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@5

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@5:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 7
    frame_bury 0
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@6

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_block@6:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 0
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 1
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@7

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@7:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 1
    // box_storage/contract.py:255-256
    // # when calculating arr2_offset need to sub 2 from 0th index to account for length bytes
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_0 // 0
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    frame_bury 2
    // box_storage/contract.py:255-256
    // # when calculating arr2_offset need to sub 2 from 0th index to account for length bytes
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    b examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@8

examples.box_storage.contract.BoxContract.append_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@8:
    // box_storage/contract.py:255-256
    // # when calculating arr2_offset need to sub 2 from 0th index to account for length bytes
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    frame_dig 2
    intc_1 // 2
    -
    // box_storage/contract.py:257
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    pushint 18
    +
    // box_storage/contract.py:249-250
    // # update using a box typed as a FixedArray
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:257
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:260
    // self.dynamic_arr_struct.value.arr.length == arr_len
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig 6
    ==
    // box_storage/contract.py:259-261
    // assert (
    //     self.dynamic_arr_struct.value.arr.length == arr_len
    // ), "expected arr length to be correct"
    assert // expected arr length to be correct
    // box_storage/contract.py:262
    // assert self.dynamic_arr_struct.value.arr2.length == 0, "expected arr2 length to be correct"
    intc_0 // 0
    pushint 18
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    ==
    assert // expected arr2 length to be correct
    // box_storage/contract.py:263
    // return self.dynamic_arr_struct.value.arr.length
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct(times: uint64) -> uint64:
examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct:
    // box_storage/contract.py:265-266
    // @arc4.abimethod
    // def pop_dynamic_arr_struct(self, times: UInt64) -> UInt64:
    proto 1 1
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    bytec_0 // ""
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@0:
    // box_storage/contract.py:270
    // arr_len = self.dynamic_arr_struct.value.arr.length - times
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -1
    -
    dup
    // box_storage/contract.py:271
    // arr2_len = self.dynamic_arr_struct.value.arr2.length
    intc_0 // 0
    pushint 18
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    cover 1
    // box_storage/contract.py:274
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@1

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@1:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 8
    frame_bury 1
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@2

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@2:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 1
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 2
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@3

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@3:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 2
    // box_storage/contract.py:274
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    intc_0 // 0
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    frame_bury 3
    // box_storage/contract.py:274
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@4

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@4:
    // box_storage/contract.py:274
    // arr2_offset = get_dynamic_arr2_struct_byte_index(arr_len, UInt64(0)) - 2
    frame_dig 3
    intc_1 // 2
    -
    // box_storage/contract.py:275
    // box.value.arr.length = arc4.UInt16(arr_len)
    frame_dig 6
    dup
    cover 2
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    pushint 20
    +
    intc_0 // 0
    +
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:275
    // box.value.arr.length = arc4.UInt16(arr_len)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:276
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    pushint 18
    +
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:276
    // box.value.arr2_offset = arc4.UInt16(arr2_offset)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:277
    // index = get_dynamic_arr_struct_byte_index(arr_len)
    frame_bury 1
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@5

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@5:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 1
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 4
    // box_storage/contract.py:277
    // index = get_dynamic_arr_struct_byte_index(arr_len)
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@6

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@6:
    // box_storage/contract.py:277
    // index = get_dynamic_arr_struct_byte_index(arr_len)
    frame_dig 4
    // box_storage/contract.py:278
    // box.splice(index, times * size_of(UInt64), b"")
    frame_dig -1
    intc_3 // 8
    *
    // box_storage/contract.py:272-273
    // # resize array
    // box = Box(FixedArrayInAStruct, key=self.dynamic_arr_struct.key)
    bytec_1 // "dynamic_arr_struct"
    // box_storage/contract.py:278
    // box.splice(index, times * size_of(UInt64), b"")
    uncover 2
    uncover 2
    bytec_0 // 0x
    box_splice
    // box_storage/contract.py:279-282
    // # truncate box
    // # Note: this is currently the same as index, but could be different if there
    // #       were multiple dynamic arrays
    // size = get_dynamic_arr2_struct_byte_index(arr_len, arr2_len)
    frame_dig 6
    frame_bury 8
    frame_dig 7
    frame_bury 0
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@7

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@7:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 8
    frame_bury 1
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@8

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_block@8:
    // box_storage/contract.py:526
    // head = size_of(UInt64) + size_of(arc4.UInt16) + size_of(UInt64) + size_of(arc4.UInt16)
    intc_3 // 8
    intc_1 // 2
    +
    intc_3 // 8
    +
    intc_1 // 2
    +
    // box_storage/contract.py:527
    // dyn_arr_index = size_of(arc4.UInt16) + index * size_of(UInt64)
    frame_dig 1
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:528
    // return head + dyn_arr_index
    +
    frame_bury 2
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@9

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr_struct_byte_index@9:
    // box_storage/contract.py:533
    // head_and_dyn_arr = get_dynamic_arr_struct_byte_index(arr_size)
    frame_dig 2
    // box_storage/contract.py:534
    // dyn_arr2_index = size_of(arc4.UInt16) + arr2_index * size_of(UInt64)
    frame_dig 0
    intc_3 // 8
    *
    intc_1 // 2
    +
    // box_storage/contract.py:535
    // return head_and_dyn_arr + dyn_arr2_index
    +
    frame_bury 5
    // box_storage/contract.py:279-282
    // # truncate box
    // # Note: this is currently the same as index, but could be different if there
    // #       were multiple dynamic arrays
    // size = get_dynamic_arr2_struct_byte_index(arr_len, arr2_len)
    b examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@10

examples.box_storage.contract.BoxContract.pop_dynamic_arr_struct_after_inlined_examples.box_storage.contract.get_dynamic_arr2_struct_byte_index@10:
    // box_storage/contract.py:279-282
    // # truncate box
    // # Note: this is currently the same as index, but could be different if there
    // #       were multiple dynamic arrays
    // size = get_dynamic_arr2_struct_byte_index(arr_len, arr2_len)
    frame_dig 5
    // box_storage/contract.py:283
    // self.dynamic_arr_struct.resize(size)
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    box_resize
    // box_storage/contract.py:285
    // return self.dynamic_arr_struct.value.arr.length
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.set_nested_struct(struct: bytes) -> void:
examples.box_storage.contract.BoxContract.set_nested_struct:
    // box_storage/contract.py:287-288
    // @arc4.abimethod()
    // def set_nested_struct(self, struct: NestedStruct) -> None:
    proto 1 0
    b examples.box_storage.contract.BoxContract.set_nested_struct_block@0

examples.box_storage.contract.BoxContract.set_nested_struct_block@0:
    // box_storage/contract.py:290
    // assert struct.a, "struct.a is truthy"
    frame_dig -1
    intc_0 // 0
    intc_3 // 8
    extract3
    btoi
    intc_0 // 0
    !=
    assert // struct.a is truthy
    // box_storage/contract.py:291
    // struct_bytes = Txn.application_args(1)
    txna ApplicationArgs 1
    // box_storage/contract.py:292
    // struct_size = struct_bytes.length
    dup
    len
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 4 // 4098
    // box_storage/contract.py:294-295
    // # initialize box to zero
    // box.create(size=tail_offset + struct_size)
    +
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:294-295
    // # initialize box to zero
    // box.create(size=tail_offset + struct_size)
    uncover 1
    box_create
    pop
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 4 // 4098
    // box_storage/contract.py:296-297
    // # set correct offset for dynamic portion
    // box.replace(tail_offset - 2, arc4.UInt16(tail_offset).bytes)
    intc_1 // 2
    -
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 4 // 4098
    // box_storage/contract.py:296-297
    // # set correct offset for dynamic portion
    // box.replace(tail_offset - 2, arc4.UInt16(tail_offset).bytes)
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:296-297
    // # set correct offset for dynamic portion
    // box.replace(tail_offset - 2, arc4.UInt16(tail_offset).bytes)
    uncover 2
    uncover 2
    box_replace
    // box_storage/contract.py:289
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:293
    // tail_offset = UInt64(4096 + 2)
    intc 4 // 4098
    // box_storage/contract.py:298-299
    // # set dynamic data
    // box.replace(tail_offset, struct_bytes)
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.nested_write(index: uint64, value: uint64) -> void:
examples.box_storage.contract.BoxContract.nested_write:
    // box_storage/contract.py:301-302
    // @arc4.abimethod()
    // def nested_write(self, index: UInt64, value: UInt64) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.nested_write_block@0

examples.box_storage.contract.BoxContract.nested_write_block@0:
    // box_storage/contract.py:304
    // box.value.nested.a = value
    frame_dig -1
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    intc_0 // 0
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:304
    // box.value.nested.a = value
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:305
    // box.value.nested.b = value + 1
    frame_dig -1
    intc_2 // 1
    +
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 12
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:305
    // box.value.nested.b = value + 1
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    frame_dig -1
    intc_1 // 2
    +
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    pushint 18
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -2
    *
    dig 1
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    frame_dig -2
    intc_3 // 8
    *
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:306
    // box.value.nested.inner.arr_arr[index][index] = value + 2
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:307
    // box.value.nested.inner.c = value + 3
    frame_dig -1
    pushint 3
    +
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    intc_0 // 0
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:307
    // box.value.nested.inner.c = value + 3
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:308
    // box.value.nested.inner.d = value + 4
    frame_dig -1
    pushint 4
    +
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    pushint 10
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:308
    // box.value.nested.inner.d = value + 4
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    frame_dig -1
    pushint 5
    +
    itob
    intc_0 // 0
    intc 4 // 4098
    +
    dup
    pushint 10
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -2
    *
    dig 1
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -2
    *
    dig 1
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    frame_dig -2
    intc_3 // 8
    *
    +
    // box_storage/contract.py:303
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:309
    // box.value.nested.woah[index].arr_arr[index][index] = value + 5
    uncover 1
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.nested_read(i1: uint64, i2: uint64, i3: uint64) -> uint64:
examples.box_storage.contract.BoxContract.nested_read:
    // box_storage/contract.py:311-312
    // @arc4.abimethod()
    // def nested_read(self, i1: UInt64, i2: UInt64, i3: UInt64) -> UInt64:
    proto 3 1
    b examples.box_storage.contract.BoxContract.nested_read_block@0

examples.box_storage.contract.BoxContract.nested_read_block@0:
    // box_storage/contract.py:314
    // a = box.value.nested.a
    intc_0 // 0
    intc 4 // 4098
    +
    intc_0 // 0
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:314
    // a = box.value.nested.a
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:315
    // b = box.value.nested.b
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 12
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:315
    // b = box.value.nested.b
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    pushint 18
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -3
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -3
    *
    dig 1
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    frame_dig -2
    intc_3 // 8
    *
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:316
    // arr_arr = box.value.nested.inner.arr_arr[i1][i2]
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:317
    // c = box.value.nested.inner.c
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    intc_0 // 0
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:317
    // c = box.value.nested.inner.c
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:318
    // d = box.value.nested.inner.d
    intc_0 // 0
    intc 4 // 4098
    +
    pushint 20
    +
    pushint 10
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:318
    // d = box.value.nested.inner.d
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    intc_0 // 0
    intc 4 // 4098
    +
    dup
    pushint 10
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -3
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -3
    *
    dig 1
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    pushint 18
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    intc_1 // 2
    frame_dig -2
    *
    dig 1
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -1
    >
    assert // index out of bounds
    intc_1 // 2
    +
    frame_dig -1
    intc_3 // 8
    *
    +
    // box_storage/contract.py:313
    // box = Box(LargeNestedStruct, key="box")
    bytec_2 // "box"
    // box_storage/contract.py:319
    // woah_arr_arr = box.value.nested.woah[i1].arr_arr[i2][i3]
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:321
    // return a + b + arr_arr + c + d + woah_arr_arr
    uncover 5
    uncover 5
    +
    uncover 4
    +
    uncover 3
    +
    uncover 2
    +
    +
    retsub


// examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct() -> uint64:
examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct:
    // box_storage/contract.py:323-324
    // @arc4.abimethod
    // def sum_dynamic_arr_struct(self) -> UInt64:
    proto 0 1
    bytec_0 // ""
    bytec_0 // ""
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_block@0:
    // box_storage/contract.py:325
    // assert self.dynamic_arr_struct.value.a == 1, "expected 1"
    intc_0 // 0
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    intc_2 // 1
    ==
    assert // expected 1
    // box_storage/contract.py:326
    // assert self.dynamic_arr_struct.value.b == 2, "expected 2"
    intc_0 // 0
    pushint 10
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    intc_1 // 2
    ==
    assert // expected 2
    // box_storage/contract.py:327
    // total = self.dynamic_arr_struct.value.a + self.dynamic_arr_struct.value.b
    intc_0 // 0
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    intc_0 // 0
    pushint 10
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    +
    // box_storage/contract.py:328
    // for val in self.dynamic_arr_struct.value.arr:
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@1

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@1:
    // box_storage/contract.py:328
    // for val in self.dynamic_arr_struct.value.arr:
    frame_dig 4
    frame_dig 3
    <
    bz examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_after_for@4
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_body@2

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_body@2:
    // box_storage/contract.py:328
    // for val in self.dynamic_arr_struct.value.arr:
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig 4
    dup
    cover 2
    >
    assert // index out of bounds
    uncover 1
    intc_1 // 2
    +
    uncover 1
    intc_3 // 8
    *
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:329
    // total += val
    frame_dig 2
    +
    frame_bury 2
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_footer@3

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_footer@3:
    frame_dig 4
    intc_2 // 1
    +
    frame_bury 4
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@1

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_after_for@4:
    // box_storage/contract.py:330
    // for val in self.dynamic_arr_struct.value.arr2:
    intc_0 // 0
    pushint 18
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    intc_0 // 0
    frame_bury 1
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@5

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@5:
    // box_storage/contract.py:330
    // for val in self.dynamic_arr_struct.value.arr2:
    frame_dig 1
    frame_dig 0
    <
    bz examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_after_for@8
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_body@6

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_body@6:
    // box_storage/contract.py:330
    // for val in self.dynamic_arr_struct.value.arr2:
    intc_0 // 0
    pushint 18
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    +
    intc_1 // 2
    +
    frame_dig 1
    intc_3 // 8
    *
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:331
    // total += val
    frame_dig 2
    +
    frame_bury 2
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_footer@7

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_footer@7:
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_for_header@5

examples.box_storage.contract.BoxContract.sum_dynamic_arr_struct_after_for@8:
    // box_storage/contract.py:332
    // return total
    frame_dig 2
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.create_bools() -> void:
examples.box_storage.contract.BoxContract.create_bools:
    b examples.box_storage.contract.BoxContract.create_bools_block@0

examples.box_storage.contract.BoxContract.create_bools_block@0:
    // box_storage/contract.py:336
    // self.too_many_bools.create()
    bytec 13 // "too_many_bools"
    pushint 4125
    box_create
    pop
    retsub


// examples.box_storage.contract.BoxContract.set_bool(index: uint64, value: uint64) -> void:
examples.box_storage.contract.BoxContract.set_bool:
    // box_storage/contract.py:338-339
    // @arc4.abimethod
    // def set_bool(self, index: UInt64, value: bool) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.set_bool_block@0

examples.box_storage.contract.BoxContract.set_bool_block@0:
    // box_storage/contract.py:340
    // self.too_many_bools.value[index] = value
    frame_dig -1
    frame_dig -2
    intc_3 // 8
    /
    intc_0 // 0
    +
    frame_dig -2
    intc_3 // 8
    %
    cover 1
    bytec 13 // "too_many_bools"
    dig 1
    intc_2 // 1
    box_extract
    cover 1
    dig 2
    intc_3 // 8
    <
    assert // index access is out of bounds
    dig 2
    intc_3 // 8
    <
    assert // index access is out of bounds
    uncover 1
    uncover 2
    uncover 3
    setbit
    bytec 13 // "too_many_bools"
    uncover 2
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.sum_bools(stop_at_total: uint64) -> uint64:
examples.box_storage.contract.BoxContract.sum_bools:
    // box_storage/contract.py:342-343
    // @arc4.abimethod()
    // def sum_bools(self, stop_at_total: UInt64) -> UInt64:
    proto 1 1
    bytec_0 // ""
    b examples.box_storage.contract.BoxContract.sum_bools_block@0

examples.box_storage.contract.BoxContract.sum_bools_block@0:
    // box_storage/contract.py:344
    // total = UInt64()
    intc_0 // 0
    // box_storage/contract.py:345
    // for value in self.too_many_bools.value:
    bytec 13 // "too_many_bools"
    box_get
    assert // check self.too_many_bools exists
    intc_0 // 0
    b examples.box_storage.contract.BoxContract.sum_bools_for_header@1

examples.box_storage.contract.BoxContract.sum_bools_for_header@1:
    // box_storage/contract.py:345
    // for value in self.too_many_bools.value:
    frame_dig 3
    pushint 33000
    <
    frame_dig 1
    frame_bury 0
    bz examples.box_storage.contract.BoxContract.sum_bools_after_for@8
    b examples.box_storage.contract.BoxContract.sum_bools_for_body@2

examples.box_storage.contract.BoxContract.sum_bools_for_body@2:
    // box_storage/contract.py:345
    // for value in self.too_many_bools.value:
    frame_dig 3
    dup
    intc_3 // 8
    /
    intc_0 // 0
    +
    uncover 1
    intc_3 // 8
    %
    cover 1
    bytec 13 // "too_many_bools"
    uncover 1
    intc_2 // 1
    box_extract
    uncover 1
    getbit
    frame_dig 1
    frame_bury 0
    // box_storage/contract.py:346
    // if value:
    bz examples.box_storage.contract.BoxContract.sum_bools_after_if_else@4
    b examples.box_storage.contract.BoxContract.sum_bools_if_body@3

examples.box_storage.contract.BoxContract.sum_bools_if_body@3:
    // box_storage/contract.py:347
    // total += 1
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 0
    b examples.box_storage.contract.BoxContract.sum_bools_after_if_else@4

examples.box_storage.contract.BoxContract.sum_bools_after_if_else@4:
    // box_storage/contract.py:348
    // if total == stop_at_total:
    frame_dig 0
    frame_dig -1
    ==
    bz examples.box_storage.contract.BoxContract.sum_bools_after_if_else@6
    b examples.box_storage.contract.BoxContract.sum_bools_if_body@5

examples.box_storage.contract.BoxContract.sum_bools_if_body@5:
    // box_storage/contract.py:349
    // break
    b examples.box_storage.contract.BoxContract.sum_bools_after_for@8

examples.box_storage.contract.BoxContract.sum_bools_after_for@8:
    // box_storage/contract.py:350
    // return total
    retsub

examples.box_storage.contract.BoxContract.sum_bools_after_if_else@6:
    b examples.box_storage.contract.BoxContract.sum_bools_for_footer@7

examples.box_storage.contract.BoxContract.sum_bools_for_footer@7:
    frame_dig 3
    intc_2 // 1
    +
    frame_bury 3
    frame_dig 0
    frame_bury 1
    b examples.box_storage.contract.BoxContract.sum_bools_for_header@1


// examples.box_storage.contract.BoxContract.create_dynamic_box() -> void:
examples.box_storage.contract.BoxContract.create_dynamic_box:
    b examples.box_storage.contract.BoxContract.create_dynamic_box_block@0

examples.box_storage.contract.BoxContract.create_dynamic_box_block@0:
    // box_storage/contract.py:354
    // self.dynamic_box.value = Array[UInt64]()
    intc_0 // 0
    itob
    extract 6 2
    bytec 6 // "dynamic_box"
    box_del
    pop
    bytec 6 // "dynamic_box"
    uncover 1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.delete_dynamic_box() -> void:
examples.box_storage.contract.BoxContract.delete_dynamic_box:
    b examples.box_storage.contract.BoxContract.delete_dynamic_box_block@0

examples.box_storage.contract.BoxContract.delete_dynamic_box_block@0:
    // box_storage/contract.py:358
    // del self.dynamic_box.value
    bytec 6 // "dynamic_box"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.append_dynamic_box(times: uint64) -> uint64:
examples.box_storage.contract.BoxContract.append_dynamic_box:
    // box_storage/contract.py:360-361
    // @arc4.abimethod
    // def append_dynamic_box(self, times: UInt64) -> UInt64:
    proto 1 1
    b examples.box_storage.contract.BoxContract.append_dynamic_box_block@0

examples.box_storage.contract.BoxContract.append_dynamic_box_block@0:
    // box_storage/contract.py:365
    // arr_len = box.value.length.as_uint64()
    intc_0 // 0
    intc_0 // 0
    +
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec 6 // "dynamic_box"
    // box_storage/contract.py:365
    // arr_len = box.value.length.as_uint64()
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    dup
    // box_storage/contract.py:367
    // self.dynamic_box.resize(2 + (arr_len + times) * 8)
    frame_dig -1
    +
    intc_3 // 8
    *
    intc_1 // 2
    +
    bytec 6 // "dynamic_box"
    uncover 1
    box_resize
    // box_storage/contract.py:368
    // for i in urange(times):
    intc_2 // 1
    assert // Step cannot be zero
    intc_0 // 0
    b examples.box_storage.contract.BoxContract.append_dynamic_box_for_header@1

examples.box_storage.contract.BoxContract.append_dynamic_box_for_header@1:
    // box_storage/contract.py:368
    // for i in urange(times):
    frame_dig 1
    frame_dig -1
    <
    bz examples.box_storage.contract.BoxContract.append_dynamic_box_after_for@4
    b examples.box_storage.contract.BoxContract.append_dynamic_box_for_body@2

examples.box_storage.contract.BoxContract.append_dynamic_box_for_body@2:
    // box_storage/contract.py:368
    // for i in urange(times):
    frame_dig 1
    // box_storage/contract.py:369
    // box.value.arr[arr_len] = i
    itob
    intc_0 // 0
    intc_1 // 2
    +
    frame_dig 0
    dup
    cover 2
    intc_3 // 8
    *
    +
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec 6 // "dynamic_box"
    // box_storage/contract.py:369
    // box.value.arr[arr_len] = i
    uncover 1
    uncover 3
    box_replace
    // box_storage/contract.py:370
    // arr_len += 1
    intc_2 // 1
    +
    frame_bury 0
    b examples.box_storage.contract.BoxContract.append_dynamic_box_for_footer@3

examples.box_storage.contract.BoxContract.append_dynamic_box_for_footer@3:
    // box_storage/contract.py:368
    // for i in urange(times):
    frame_dig 1
    intc_2 // 1
    +
    frame_bury 1
    b examples.box_storage.contract.BoxContract.append_dynamic_box_for_header@1

examples.box_storage.contract.BoxContract.append_dynamic_box_after_for@4:
    // box_storage/contract.py:372
    // box.value.length = arc4.UInt16(arr_len)
    frame_dig 0
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    intc_0 // 0
    +
    // box_storage/contract.py:364
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec 6 // "dynamic_box"
    // box_storage/contract.py:372
    // box.value.length = arc4.UInt16(arr_len)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:373
    // return self.dynamic_box.value.length
    bytec 6 // "dynamic_box"
    intc_0 // 0
    intc_1 // 2
    box_extract
    btoi
    frame_bury 0
    retsub


// examples.box_storage.contract.BoxContract.pop_dynamic_box(times: uint64) -> uint64:
examples.box_storage.contract.BoxContract.pop_dynamic_box:
    // box_storage/contract.py:375-376
    // @arc4.abimethod
    // def pop_dynamic_box(self, times: UInt64) -> UInt64:
    proto 1 1
    b examples.box_storage.contract.BoxContract.pop_dynamic_box_block@0

examples.box_storage.contract.BoxContract.pop_dynamic_box_block@0:
    // box_storage/contract.py:380
    // arr_len = box.value.length.as_uint64() - times
    intc_0 // 0
    intc_0 // 0
    +
    // box_storage/contract.py:379
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec 6 // "dynamic_box"
    // box_storage/contract.py:380
    // arr_len = box.value.length.as_uint64() - times
    uncover 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -1
    -
    // box_storage/contract.py:381
    // box.value.length = arc4.UInt16(arr_len)
    dup
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    pushint 6
    intc_1 // 2
    extract3
    intc_0 // 0
    intc_0 // 0
    +
    // box_storage/contract.py:379
    // box = Box(FixedArrayUInt64, key=self.dynamic_box.key)
    bytec 6 // "dynamic_box"
    // box_storage/contract.py:381
    // box.value.length = arc4.UInt16(arr_len)
    uncover 1
    uncover 2
    box_replace
    // box_storage/contract.py:382
    // self.dynamic_box.resize(2 + arr_len * 8)
    intc_3 // 8
    *
    intc_1 // 2
    +
    bytec 6 // "dynamic_box"
    uncover 1
    box_resize
    // box_storage/contract.py:384
    // return self.dynamic_box.value.length
    bytec 6 // "dynamic_box"
    intc_0 // 0
    intc_1 // 2
    box_extract
    btoi
    retsub


// examples.box_storage.contract.BoxContract.sum_dynamic_box() -> uint64:
examples.box_storage.contract.BoxContract.sum_dynamic_box:
    // box_storage/contract.py:386-387
    // @arc4.abimethod
    // def sum_dynamic_box(self) -> UInt64:
    proto 0 1
    b examples.box_storage.contract.BoxContract.sum_dynamic_box_block@0

examples.box_storage.contract.BoxContract.sum_dynamic_box_block@0:
    // box_storage/contract.py:388
    // total = UInt64()
    intc_0 // 0
    // box_storage/contract.py:389
    // for val in self.dynamic_box.value:
    bytec 6 // "dynamic_box"
    intc_0 // 0
    intc_1 // 2
    box_extract
    btoi
    intc_0 // 0
    b examples.box_storage.contract.BoxContract.sum_dynamic_box_for_header@1

examples.box_storage.contract.BoxContract.sum_dynamic_box_for_header@1:
    // box_storage/contract.py:389
    // for val in self.dynamic_box.value:
    frame_dig 2
    frame_dig 1
    <
    bz examples.box_storage.contract.BoxContract.sum_dynamic_box_after_for@4
    b examples.box_storage.contract.BoxContract.sum_dynamic_box_for_body@2

examples.box_storage.contract.BoxContract.sum_dynamic_box_for_body@2:
    // box_storage/contract.py:389
    // for val in self.dynamic_box.value:
    intc_0 // 0
    intc_1 // 2
    +
    frame_dig 2
    intc_3 // 8
    *
    +
    bytec 6 // "dynamic_box"
    uncover 1
    intc_3 // 8
    box_extract
    btoi
    // box_storage/contract.py:390
    // total += val
    frame_dig 0
    +
    frame_bury 0
    b examples.box_storage.contract.BoxContract.sum_dynamic_box_for_footer@3

examples.box_storage.contract.BoxContract.sum_dynamic_box_for_footer@3:
    frame_dig 2
    intc_2 // 1
    +
    frame_bury 2
    b examples.box_storage.contract.BoxContract.sum_dynamic_box_for_header@1

examples.box_storage.contract.BoxContract.sum_dynamic_box_after_for@4:
    // box_storage/contract.py:391
    // return total
    retsub


// examples.box_storage.contract.BoxContract.write_dynamic_box(index: uint64, value: uint64) -> void:
examples.box_storage.contract.BoxContract.write_dynamic_box:
    // box_storage/contract.py:393-394
    // @arc4.abimethod
    // def write_dynamic_box(self, index: UInt64, value: UInt64) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.write_dynamic_box_block@0

examples.box_storage.contract.BoxContract.write_dynamic_box_block@0:
    // box_storage/contract.py:395
    // self.dynamic_box.value[index] = value
    frame_dig -1
    itob
    intc_0 // 0
    intc_1 // 2
    +
    frame_dig -2
    intc_3 // 8
    *
    +
    bytec 6 // "dynamic_box"
    uncover 1
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.write_dynamic_arr_struct(index: uint64, value: uint64) -> void:
examples.box_storage.contract.BoxContract.write_dynamic_arr_struct:
    // box_storage/contract.py:397-398
    // @arc4.abimethod
    // def write_dynamic_arr_struct(self, index: UInt64, value: UInt64) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.write_dynamic_arr_struct_block@0

examples.box_storage.contract.BoxContract.write_dynamic_arr_struct_block@0:
    // box_storage/contract.py:399
    // self.dynamic_arr_struct.value.arr[index] = value
    frame_dig -1
    itob
    intc_0 // 0
    pushint 20
    +
    bytec_1 // "dynamic_arr_struct"
    dig 1
    intc_1 // 2
    box_extract
    btoi
    frame_dig -2
    >
    assert // index out of bounds
    intc_1 // 2
    +
    frame_dig -2
    intc_3 // 8
    *
    +
    bytec_1 // "dynamic_arr_struct"
    uncover 1
    uncover 2
    box_replace
    retsub


// examples.box_storage.contract.BoxContract.slice_box() -> void:
examples.box_storage.contract.BoxContract.slice_box:
    // box_storage/contract.py:401-402
    // @arc4.abimethod
    // def slice_box(self) -> None:
    proto 0 0
    b examples.box_storage.contract.BoxContract.slice_box_block@0

examples.box_storage.contract.BoxContract.slice_box_block@0:
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 19 // "0"
    // box_storage/contract.py:404
    // box_0.value = Bytes(b"Testing testing 123")
    box_del
    pop
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 19 // "0"
    // box_storage/contract.py:404
    // box_0.value = Bytes(b"Testing testing 123")
    pushbytes 0x54657374696e672074657374696e6720313233
    box_put
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 19 // "0"
    // box_storage/contract.py:405
    // assert box_0.value[0:7] == b"Testing"
    box_len
    cover 1
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    cover 1
    pushint 7
    dig 1
    >=
    pushint 7
    uncover 2
    uncover 2
    select
    dig 1
    -
    // box_storage/contract.py:403
    // box_0 = Box(Bytes, key=String("0"))
    bytec 19 // "0"
    // box_storage/contract.py:405
    // assert box_0.value[0:7] == b"Testing"
    uncover 2
    uncover 2
    box_extract
    pushbytes 0x54657374696e67
    ==
    assert
    // box_storage/contract.py:407
    // self.box_c.value = arc4.String("Hello")
    bytec 20 // "Hello"
    len
    itob
    extract 6 2
    bytec 20 // "Hello"
    concat
    bytec 4 // 0x424f585f43
    box_del
    pop
    bytec 4 // 0x424f585f43
    uncover 1
    box_put
    // box_storage/contract.py:408
    // assert self.box_c.value.bytes[2:10] == b"Hello"
    bytec 4 // 0x424f585f43
    box_len
    cover 1
    intc_1 // 2
    dig 1
    >=
    intc_1 // 2
    dig 2
    uncover 2
    select
    cover 1
    pushint 10
    dig 1
    >=
    pushint 10
    uncover 2
    uncover 2
    select
    dig 1
    -
    bytec 4 // 0x424f585f43
    uncover 2
    uncover 2
    box_extract
    bytec 20 // 0x48656c6c6f
    ==
    assert
    retsub


// examples.box_storage.contract.BoxContract.arc4_box() -> void:
examples.box_storage.contract.BoxContract.arc4_box:
    b examples.box_storage.contract.BoxContract.arc4_box_block@0

examples.box_storage.contract.BoxContract.arc4_box_block@0:
    // box_storage/contract.py:413
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    bytec_0 // 0x
    bytec 16 // 0x00
    concat
    pushbytes 0x01
    concat
    pushbytes 0x02
    concat
    pushbytes 0x03
    concat
    // box_storage/contract.py:412
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 14 // 0x64
    // box_storage/contract.py:413
    // box_d.value = StaticInts(arc4.UInt8(0), arc4.UInt8(1), arc4.UInt8(2), arc4.UInt8(3))
    uncover 1
    box_put
    // box_storage/contract.py:412
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 14 // 0x64
    // box_storage/contract.py:415
    // assert box_d.value[0] == 0
    box_get
    assert // check Box exists
    intc_0 // 0
    intc_2 // 1
    *
    intc_2 // 1
    extract3 // on error: index access is out of bounds
    bytec 16 // 0x00
    b==
    assert
    // box_storage/contract.py:412
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 14 // 0x64
    // box_storage/contract.py:416
    // assert box_d.value[1] == 1
    box_get
    assert // check Box exists
    intc_2 // 1
    intc_2 // 1
    *
    intc_2 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x01
    b==
    assert
    // box_storage/contract.py:412
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 14 // 0x64
    // box_storage/contract.py:417
    // assert box_d.value[2] == 2
    box_get
    assert // check Box exists
    intc_1 // 2
    intc_2 // 1
    *
    intc_2 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x02
    b==
    assert
    // box_storage/contract.py:412
    // box_d = Box(StaticInts, key=Bytes(b"d"))
    bytec 14 // 0x64
    // box_storage/contract.py:418
    // assert box_d.value[3] == 3
    box_get
    assert // check Box exists
    pushint 3
    intc_2 // 1
    *
    intc_2 // 1
    extract3 // on error: index access is out of bounds
    pushbytes 0x03
    b==
    assert
    retsub


// examples.box_storage.contract.BoxContract.test_box_ref() -> void:
examples.box_storage.contract.BoxContract.test_box_ref:
    // box_storage/contract.py:420-421
    // @arc4.abimethod
    // def test_box_ref(self) -> None:
    proto 0 0
    b examples.box_storage.contract.BoxContract.test_box_ref_block@0

examples.box_storage.contract.BoxContract.test_box_ref_block@0:
    // box_storage/contract.py:422-423
    // # init ref, with valid key types
    // box_ref = Box(Bytes, key="blob")
    bytec_3 // "blob"
    // box_storage/contract.py:424
    // assert not box_ref, "no data"
    box_len
    !
    assert // no data
    // box_storage/contract.py:425
    // box_ref = Box(Bytes, key=b"blob")
    bytec_3 // 0x626c6f62
    // box_storage/contract.py:426
    // assert not box_ref, "no data"
    box_len
    !
    assert // no data
    // box_storage/contract.py:427
    // box_ref = Box(Bytes, key=Bytes(b"blob"))
    bytec_3 // 0x626c6f62
    // box_storage/contract.py:428
    // assert not box_ref, "no data"
    box_len
    !
    assert // no data
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:430
    // assert not box_ref, "no data"
    box_len
    !
    assert // no data
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:432-433
    // # create
    // assert box_ref.create(size=UInt64(32))
    pushint 32
    box_create
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:434
    // assert box_ref, "has data"
    box_len
    assert // has data
    // box_storage/contract.py:436-437
    // # manipulate data
    // sender_bytes = Txn.sender.bytes
    txn Sender
    // box_storage/contract.py:438
    // app_address = Global.current_application_address.bytes
    global CurrentApplicationAddress
    cover 1
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:440
    // box_ref.replace(0, sender_bytes)
    intc_0 // 0
    dig 2
    box_replace
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:441
    // box_ref.resize(8000)
    pushint 8000
    box_resize
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:442
    // box_ref.splice(0, 0, app_address)
    intc_0 // 0
    intc_0 // 0
    dig 4
    box_splice
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:443
    // box_ref.replace(64, value_3)
    pushint 64
    // box_storage/contract.py:439
    // value_3 = Bytes(b"hello")
    bytec 15 // 0x68656c6c6f
    // box_storage/contract.py:443
    // box_ref.replace(64, value_3)
    box_replace
    // box_storage/contract.py:439
    // value_3 = Bytes(b"hello")
    bytec 15 // 0x68656c6c6f
    // box_storage/contract.py:444
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    len
    pushint 64
    +
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:444
    // prefix = box_ref.extract(0, 32 * 2 + value_3.length)
    intc_0 // 0
    uncover 2
    box_extract
    // box_storage/contract.py:445
    // assert prefix == app_address + sender_bytes + value_3
    dig 2
    dig 2
    concat
    // box_storage/contract.py:439
    // value_3 = Bytes(b"hello")
    bytec 15 // 0x68656c6c6f
    // box_storage/contract.py:445
    // assert prefix == app_address + sender_bytes + value_3
    concat
    ==
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:447-448
    // # delete
    // del box_ref.value
    box_del
    pop
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:449
    // assert box_ref.key == b"blob"
    bytec_3 // 0x626c6f62
    ==
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:451-452
    // # query
    // value, exists = box_ref.maybe()
    box_get
    // box_storage/contract.py:453
    // assert not exists
    !
    assert
    // box_storage/contract.py:454
    // assert value == b""
    bytec_0 // 0x
    ==
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:455
    // assert box_ref.get(default=sender_bytes) == sender_bytes
    box_get
    cover 1
    dig 2
    uncover 1
    uncover 2
    select
    dig 1
    ==
    assert
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    uncover 1
    concat
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    box_del
    pop
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:457-458
    // # update
    // box_ref.value = sender_bytes + app_address
    uncover 1
    box_put
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:459
    // assert box_ref, "Blob exists"
    box_len
    assert // Blob exists
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:460
    // assert box_ref.length == 64
    box_len
    assert // check Box exists
    pushint 64
    ==
    assert
    // box_storage/contract.py:429
    // box_ref = Box(Bytes, key=String("blob"))
    bytec_3 // "blob"
    // box_storage/contract.py:461
    // assert get_box_ref_length(box_ref) == 64
    callsub get_box_ref_length
    pushint 64
    ==
    assert
    // box_storage/contract.py:463-464
    // # instance box ref
    // self.box_ref.create(size=UInt64(32))
    bytec 21 // "box_ref"
    pushint 32
    box_create
    pop
    // box_storage/contract.py:465
    // assert self.box_ref, "has data"
    bytec 21 // "box_ref"
    box_len
    assert // has data
    // box_storage/contract.py:466
    // del self.box_ref.value
    bytec 21 // "box_ref"
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_test() -> void:
examples.box_storage.contract.BoxContract.box_map_test:
    // box_storage/contract.py:468-469
    // @arc4.abimethod
    // def box_map_test(self) -> None:
    proto 0 0
    b examples.box_storage.contract.BoxContract.box_map_test_block@0

examples.box_storage.contract.BoxContract.box_map_test_block@0:
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:473
    // self.box_map[key_0] = value
    itob
    bytec_0 // ""
    uncover 1
    concat
    dup
    box_del
    pop
    // box_storage/contract.py:472
    // value = String("Hmmmmm")
    bytec 22 // "Hmmmmm"
    // box_storage/contract.py:473
    // self.box_map[key_0] = value
    box_put
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:474
    // box_0 = self.box_map.box(key_0)
    itob
    bytec_0 // ""
    uncover 1
    concat
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:476
    // assert self.box_map[key_0].bytes.length == value.bytes.length
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_len
    cover 2
    // box_storage/contract.py:472
    // value = String("Hmmmmm")
    bytec 22 // "Hmmmmm"
    // box_storage/contract.py:476
    // assert self.box_map[key_0].bytes.length == value.bytes.length
    len
    ==
    assert
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:477
    // assert self.box_map[key_0].bytes.length == box_0.length
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_len
    cover 2
    uncover 1
    box_len
    assert // check Box exists
    ==
    assert
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:478
    // assert self.box_map.length(key_0) == value.bytes.length
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_len
    assert // check self.box_map entry exists
    // box_storage/contract.py:472
    // value = String("Hmmmmm")
    bytec 22 // "Hmmmmm"
    // box_storage/contract.py:478
    // assert self.box_map.length(key_0) == value.bytes.length
    len
    ==
    assert
    // box_storage/contract.py:471
    // key_1 = UInt64(1)
    intc_2 // 1
    // box_storage/contract.py:480
    // assert self.box_map.get(key_1, default=String("default")) == String("default")
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_get
    cover 1
    bytec 24 // "default"
    uncover 1
    uncover 2
    select
    bytec 24 // "default"
    ==
    assert
    // box_storage/contract.py:471
    // key_1 = UInt64(1)
    intc_2 // 1
    // box_storage/contract.py:481
    // value, exists = self.box_map.maybe(key_1)
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_get
    // box_storage/contract.py:482
    // assert not exists
    !
    assert
    // box_storage/contract.py:470
    // key_0 = UInt64(0)
    intc_0 // 0
    // box_storage/contract.py:483
    // assert key_0 in self.box_map
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_len
    assert
    // box_storage/contract.py:484
    // assert self.box_map.key_prefix == b""
    bytec_0 // ""
    bytec_0 // 0x
    ==
    assert
    // box_storage/contract.py:471
    // key_1 = UInt64(1)
    intc_2 // 1
    // box_storage/contract.py:488
    // tmp_box_map[key_1] = String("hello")
    itob
    // box_storage/contract.py:486-487
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:488
    // tmp_box_map[key_1] = String("hello")
    uncover 1
    concat
    dup
    box_del
    pop
    bytec 15 // "hello"
    box_put
    // box_storage/contract.py:486-487
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:489
    // assert get_box_map_value_from_key_plus_1(tmp_box_map, UInt64(0)) == "hello"
    intc_0 // 0
    callsub get_box_map_value_from_key_plus_1
    bytec 15 // "hello"
    ==
    assert
    // box_storage/contract.py:471
    // key_1 = UInt64(1)
    intc_2 // 1
    // box_storage/contract.py:490
    // del tmp_box_map[key_1]
    itob
    // box_storage/contract.py:486-487
    // # test box map not assigned to the class and passed to subroutine
    // tmp_box_map = BoxMap(UInt64, String, key_prefix=Bytes())
    bytec_0 // 0x
    // box_storage/contract.py:490
    // del tmp_box_map[key_1]
    uncover 1
    concat
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_set(key: uint64, value: bytes) -> void:
examples.box_storage.contract.BoxContract.box_map_set:
    // box_storage/contract.py:492-493
    // @arc4.abimethod
    // def box_map_set(self, key: UInt64, value: String) -> None:
    proto 2 0
    b examples.box_storage.contract.BoxContract.box_map_set_block@0

examples.box_storage.contract.BoxContract.box_map_set_block@0:
    // box_storage/contract.py:494
    // self.box_map[key] = value
    frame_dig -2
    itob
    bytec_0 // ""
    uncover 1
    concat
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// examples.box_storage.contract.BoxContract.box_map_get(key: uint64) -> bytes:
examples.box_storage.contract.BoxContract.box_map_get:
    // box_storage/contract.py:496-497
    // @arc4.abimethod
    // def box_map_get(self, key: UInt64) -> String:
    proto 1 1
    b examples.box_storage.contract.BoxContract.box_map_get_block@0

examples.box_storage.contract.BoxContract.box_map_get_block@0:
    // box_storage/contract.py:498
    // return self.box_map[key]
    frame_dig -1
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_get
    assert // check self.box_map entry exists
    retsub


// examples.box_storage.contract.BoxContract.box_map_del(key: uint64) -> void:
examples.box_storage.contract.BoxContract.box_map_del:
    // box_storage/contract.py:500-501
    // @arc4.abimethod
    // def box_map_del(self, key: UInt64) -> None:
    proto 1 0
    b examples.box_storage.contract.BoxContract.box_map_del_block@0

examples.box_storage.contract.BoxContract.box_map_del_block@0:
    // box_storage/contract.py:502
    // del self.box_map[key]
    frame_dig -1
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_del
    pop
    retsub


// examples.box_storage.contract.BoxContract.box_map_exists(key: uint64) -> uint64:
examples.box_storage.contract.BoxContract.box_map_exists:
    // box_storage/contract.py:504-505
    // @arc4.abimethod
    // def box_map_exists(self, key: UInt64) -> bool:
    proto 1 1
    b examples.box_storage.contract.BoxContract.box_map_exists_block@0

examples.box_storage.contract.BoxContract.box_map_exists_block@0:
    // box_storage/contract.py:506
    // return key in self.box_map
    frame_dig -1
    itob
    bytec_0 // ""
    uncover 1
    concat
    box_len
    uncover 1
    retsub
