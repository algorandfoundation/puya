// Op                                                                                          Stack (out)
// algopy.arc4.ARC4Contract.approval_program() -> uint64:
subroutine main:
    block@0:
        // merkle/contract.py:9
        // class MerkleTree(arc4.ARC4Contract):
        txn OnCompletion                                                                       tmp%0#1
        !                                                                                      tmp%1#0
        assert // OnCompletion must be NoOp
        txn ApplicationID                                                                      tmp%2#0
        bz create_NoOp@6 ; b call_NoOp@2

    call_NoOp@2:
        // merkle/contract.py:9
        // class MerkleTree(arc4.ARC4Contract):
        txna ApplicationArgs 0                                                                 tmp%4#0
        method verify(byte[32][],byte[32])bool                                                 tmp%4#0,Method(verify(byte[32][],byte[32])bool)
        l-load tmp%4#0 1                                                                       Method(verify(byte[32][],byte[32])bool),tmp%4#0
        match verify_route@3 ; b after_if_else@10

    verify_route@3:
        // merkle/contract.py:14
        // @arc4.abimethod
        callsub verify
        b after_if_else@10

    create_NoOp@6:
        // merkle/contract.py:9
        // class MerkleTree(arc4.ARC4Contract):
        txna ApplicationArgs 0                                                                 tmp%5#0
        method create(byte[32])void                                                            tmp%5#0,Method(create(byte[32])void)
        l-load tmp%5#0 1                                                                       Method(create(byte[32])void),tmp%5#0
        match create_route@7 ; b after_if_else@10

    create_route@7:
        // merkle/contract.py:10
        // @arc4.abimethod(create="require")
        callsub create
        b after_if_else@10

    after_if_else@10:
        // merkle/contract.py:9
        // class MerkleTree(arc4.ARC4Contract):
        err


// examples.merkle.contract.MerkleTree.create[routing]() -> void:
subroutine create:
    create_block@0:
        // merkle/contract.py:10
        // @arc4.abimethod(create="require")
        txna ApplicationArgs 1                                                                 root#0
        // merkle/contract.py:12
        // self.root = root.bytes
        byte "root"                                                                            root#0,"root"
        l-load root#0 1                                                                        "root",root#0
        app_global_put
        // merkle/contract.py:10
        // @arc4.abimethod(create="require")
        int 1                                                                                  1
        return


// examples.merkle.contract.MerkleTree.verify[routing]() -> void:
subroutine verify:
    verify_block@0:
        // merkle/contract.py:14
        // @arc4.abimethod
        txna ApplicationArgs 1                                                                 proof#0
        l-store-copy proof#0 0                                                                 proof#0,proof#0 (copy)
        v-store proof#0                                                                        proof#0
        txna ApplicationArgs 2                                                                 proof#0,leaf#0
        // merkle/contract.py:16
        // return self.root == compute_root_hash(proof, leaf.bytes)
        int 0                                                                                  proof#0,leaf#0,0
        byte "root"                                                                            proof#0,leaf#0,0,"root"
        app_global_get_ex                                                                      proof#0,leaf#0,maybe_value%0#0,maybe_exists%0#0
        l-store maybe_exists%0#0 1                                                             proof#0,leaf#0,maybe_exists%0#0,maybe_value%0#0
        v-store maybe_value%0#0                                                                proof#0,leaf#0,maybe_exists%0#0
        l-load maybe_exists%0#0 0                                                              proof#0,leaf#0,maybe_exists%0#0
        assert // check self.root exists                                                       proof#0,leaf#0
        // merkle/contract.py:22
        // for idx in urange(proof.length):
        l-load proof#0 1                                                                       leaf#0,proof#0
        int 0                                                                                  leaf#0,proof#0,0
        extract_uint16                                                                         leaf#0,aggregate%array_length%0#0
        v-store aggregate%array_length%0#0                                                     leaf#0
        int 0                                                                                  leaf#0,0
        v-store idx#0                                                                          leaf#0
        l-load leaf#0 0                                                                        leaf#0
        v-store computed#1
        b verify_for_header@2

    verify_for_header@2:
        // merkle/contract.py:22
        // for idx in urange(proof.length):
        v-load idx#0                                                                           idx#0
        v-load aggregate%array_length%0#0                                                      idx#0,aggregate%array_length%0#0
        <                                                                                      continue_looping%0#0
        bz verify_after_for@7 ; b verify_for_body@3

    verify_for_body@3:
        // merkle/contract.py:23
        // computed = hash_pair(computed, proof[idx].bytes)
        v-load proof#0                                                                         proof#0
        extract 2 0                                                                            aggregate%array_trimmed%0#0
        v-load idx#0                                                                           aggregate%array_trimmed%0#0,idx#0
        int 32                                                                                 aggregate%array_trimmed%0#0,idx#0,32
        *                                                                                      aggregate%array_trimmed%0#0,aggregate%bytes_offset%0#0
        l-load aggregate%array_trimmed%0#0 1                                                   aggregate%bytes_offset%0#0,aggregate%array_trimmed%0#0
        l-load aggregate%bytes_offset%0#0 1                                                    aggregate%array_trimmed%0#0,aggregate%bytes_offset%0#0
        int 32                                                                                 aggregate%array_trimmed%0#0,aggregate%bytes_offset%0#0,32
        extract3 // on error: index access is out of bounds                                    b#0
        l-store-copy b#0 0                                                                     b#0,b#0
        x-store b#0                                                                            (ð•) b#0 | b#0
        // merkle/contract.py:29
        // return op.sha256(a + b if BigUInt.from_bytes(a) < BigUInt.from_bytes(b) else b + a)
        v-load computed#1                                                                      (ð•) b#0 | b#0,computed#1
        l-load b#0 1                                                                           (ð•) b#0 | computed#1,b#0
        b<                                                                                     (ð•) b#0 | tmp%0#1
        bz verify_ternary_false@5 ; b verify_ternary_true@4                                    (ð•) b#0 |

    verify_ternary_true@4:                                                                     (ð•) b#0 |
        // merkle/contract.py:29
        // return op.sha256(a + b if BigUInt.from_bytes(a) < BigUInt.from_bytes(b) else b + a)
        v-load computed#1                                                                      (ð•) b#0 | computed#1
        x-load b#0                                                                             computed#1,b#0
        concat                                                                                 ternary_result%0#0
        x-store ternary_result%0#0                                                             (ð•) ternary_result%0#0 |
        b verify_ternary_merge@6                                                               (ð•) ternary_result%0#0 |

    verify_ternary_false@5:                                                                    (ð•) b#0 |
        // merkle/contract.py:29
        // return op.sha256(a + b if BigUInt.from_bytes(a) < BigUInt.from_bytes(b) else b + a)
        x-load b#0                                                                             b#0
        v-load computed#1                                                                      b#0,computed#1
        concat                                                                                 ternary_result%0#0
        x-store ternary_result%0#0                                                             (ð•) ternary_result%0#0 |
        b verify_ternary_merge@6                                                               (ð•) ternary_result%0#0 |

    verify_ternary_merge@6:                                                                    (ð•) ternary_result%0#0 |
        // merkle/contract.py:29
        // return op.sha256(a + b if BigUInt.from_bytes(a) < BigUInt.from_bytes(b) else b + a)
        x-load ternary_result%0#0                                                              ternary_result%0#0
        sha256                                                                                 computed#1
        v-store computed#1
        // merkle/contract.py:22
        // for idx in urange(proof.length):
        v-load idx#0                                                                           idx#0
        int 1                                                                                  idx#0,1
        +                                                                                      idx#0
        v-store idx#0
        b verify_for_header@2

    verify_after_for@7:
        // merkle/contract.py:16
        // return self.root == compute_root_hash(proof, leaf.bytes)
        v-load maybe_value%0#0                                                                 maybe_value%0#0
        v-load computed#1                                                                      maybe_value%0#0,computed#1
        ==                                                                                     tmp%0#1
        // merkle/contract.py:14
        // @arc4.abimethod
        byte 0x00                                                                              tmp%0#1,0x00
        int 0                                                                                  tmp%0#1,0x00,0
        l-load tmp%0#1 2                                                                       0x00,0,tmp%0#1
        setbit                                                                                 aggregate%encoded_bool%0#0
        byte 0x151f7c75                                                                        aggregate%encoded_bool%0#0,0x151f7c75
        l-load aggregate%encoded_bool%0#0 1                                                    0x151f7c75,aggregate%encoded_bool%0#0
        concat                                                                                 tmp%2#0
        log
        int 1                                                                                  1
        return


