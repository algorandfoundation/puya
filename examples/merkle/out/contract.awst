contract MerkleTree
{
  globals {
    ['root']: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]
  }
  
  subroutine hash_pair(a: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]], b: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]): algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]
  {
    hash_bytes: algopy.Bytes = sha256((reinterpret_cast<algopy.BigUInt>(reinterpret_cast<algopy.Bytes>(a)) < reinterpret_cast<algopy.BigUInt>(reinterpret_cast<algopy.Bytes>(b))) ? (reinterpret_cast<algopy.Bytes>(a) + reinterpret_cast<algopy.Bytes>(b)) : (reinterpret_cast<algopy.Bytes>(b) + reinterpret_cast<algopy.Bytes>(a)))
    return reinterpret_cast<algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]>(hash_bytes)
  }
  
  subroutine compute_root_hash(proof: algopy.arc4.DynamicArray[algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]], leaf: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]): algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]
  {
    computed: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]] = leaf.copy()
    for proof_hash in proof {
      computed: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]] = this::hash_pair(computed, proof_hash)
    }
    return computed
  }
  
  abimethod create(root: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]): None
  {
    this.root: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]] = root.copy()
  }
  
  abimethod verify(proof: algopy.arc4.DynamicArray[algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]], leaf: algopy.arc4.StaticArray[algopy.arc4.Byte, typing.Literal[32]]): bool
  {
    return reinterpret_cast<algopy.Bytes>(this.root) == reinterpret_cast<algopy.Bytes>(this::compute_root_hash(proof, leaf))
  }
}