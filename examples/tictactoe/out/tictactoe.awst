EMPTY = 0
HOST = 1
CHALLENGER = 2
DRAW = 3

contract TicTacToeContract
{
  globals {
    ['host']: account
    ['game']: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3>
    ['turns']: uint64
    ['challenger']: account
    ['winner']: arc4.uint8
  }
  
  constructor()
  {
  }
  
  abimethod new_game(move: tuple<uint64,uint64>): void
  {
    if (reinterpret_cast<bool>(txn<ApplicationID>())) {
      if (STATE_EXISTS(this.challenger)) {
        assert(STATE_EXISTS(this.winner), comment="Game isn't over")
      }
      STATE_DELETE(this.challenger)
      STATE_DELETE(this.winner)
    }
    this.host: account = txn<Sender>()
    this.game: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3> = reinterpret_cast<arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3>>(bzero(9u))
    (column, row): tuple<uint64,uint64> = move
    assert(column < 3u and row < 3u, comment="Move must be in range")
    this.game[row][column]: arc4.uint8 = 1arc4u8
    this.turns: uint64 = 0u
  }
  
  abimethod join_game(move: tuple<uint64,uint64>): void
  {
    assert(!(STATE_EXISTS(this.challenger)), comment="Host already has a challenger")
    this.challenger: account = txn<Sender>()
    this::make_move(2arc4u8, move)
  }
  
  abimethod whose_turn(): arc4.uint8
  {
    return (reinterpret_cast<bool>(this.turns % 2u)) ? (1arc4u8) : (2arc4u8)
  }
  
  abimethod play(move: tuple<uint64,uint64>): void
  {
    assert(!(STATE_EXISTS(this.winner)), comment="Game is already finished")
    if (reinterpret_cast<bool>(this.turns % 2u)) {
      assert(txn<Sender>() == this.host, comment="It is the host's turn")
      player: arc4.uint8 = 1arc4u8
    } else {
      assert(txn<Sender>() == STATE_GET(this.challenger, default=global<ZeroAddress>()), comment="It is the challenger's turn")
      player: arc4.uint8 = 2arc4u8
    }
    this::make_move(player, move)
  }
  
  subroutine make_move(player: arc4.uint8, move: tuple<uint64,uint64>): void
  {
    (column, row): tuple<uint64,uint64> = move
    assert(column < 3u and row < 3u, comment="Move must be in range")
    assert(reinterpret_cast<biguint>(this.game[row][column]) == reinterpret_cast<biguint>(0arc4u8), comment="Square is already taken")
    this.game[row][column]: arc4.uint8 = player
    this.turns += 1u
    if (this::did_win(player, column=column, row=row)) {
      this.winner: arc4.uint8 = player
    } else {
      if (this.turns == 9u) {
        this.winner: arc4.uint8 = 3arc4u8
      }
    }
  }
  
  subroutine did_win(player: arc4.uint8, column: uint64, row: uint64): bool
  {
    g: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3> = this.game.copy()
    if (reinterpret_cast<biguint>(g[row][0u]) == reinterpret_cast<biguint>(SINGLE_EVAL(id=0, source=g[row][1u])) and reinterpret_cast<biguint>(SINGLE_EVAL(id=0, source=g[row][1u])) == reinterpret_cast<biguint>(g[row][2u])) {
      return true
    }
    if (reinterpret_cast<biguint>(g[0u][column]) == reinterpret_cast<biguint>(SINGLE_EVAL(id=1, source=g[1u][column])) and reinterpret_cast<biguint>(SINGLE_EVAL(id=1, source=g[1u][column])) == reinterpret_cast<biguint>(g[2u][column])) {
      return true
    }
    if (reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[1u][1u])) {
      if (reinterpret_cast<biguint>(g[0u][0u]) == reinterpret_cast<biguint>(player) and reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[2u][2u])) {
        return true
      }
      if (reinterpret_cast<biguint>(g[0u][2u]) == reinterpret_cast<biguint>(player) and reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[2u][0u])) {
        return true
      }
    }
    return false
  }
}