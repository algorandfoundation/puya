HOST = 1
CHALLENGER = 2
DRAW = 3

contract TicTacToeContract
{
  globals {
    ['game']: puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]]
    ['host']: puyapy.Account
    ['challenger']: puyapy.Account
    ['winner']: puyapy.arc4.UInt8
    ['turns']: puyapy.UInt64
  }
  
  abimethod new_game(move: tuple[puyapy.UInt64, puyapy.UInt64]): tuple[puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]], puyapy.arc4.UInt8]
  {
    this.game: puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]] = reinterpret_cast<puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]]>(bzero(9u))
    this.host: puyapy.Account = txn<Sender>()
    this.challenger: puyapy.Account = global<ZeroAddress>()
    this.winner: puyapy.arc4.UInt8 = 0arc4u8
    assert(move[0] < 3u and move[1] < 3u, comment="Move must be in range")
    this.game[move[1]][move[0]]: puyapy.arc4.UInt8 = 1arc4u8
    this.turns: puyapy.UInt64 = 0u
    return (this.game, this.winner)
  }
  
  abimethod join_game(move: tuple[puyapy.UInt64, puyapy.UInt64]): tuple[puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]], puyapy.arc4.UInt8]
  {
    assert(this.challenger == global<ZeroAddress>(), comment="Host already has a challenger")
    this.challenger: puyapy.Account = txn<Sender>()
    this::make_move(2arc4u8, move)
    return (this.game, this.winner)
  }
  
  abimethod whose_turn(): puyapy.arc4.UInt8
  {
    return (reinterpret_cast<bool>(this.turns % 2u)) ? (1arc4u8) : (2arc4u8)
  }
  
  abimethod play(move: tuple[puyapy.UInt64, puyapy.UInt64]): tuple[puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]], puyapy.arc4.UInt8]
  {
    assert(reinterpret_cast<puyapy.Bytes>(this.winner) == hex<"00">, comment="Game is already finished")
    if (this.turns % 2u == 1u) {
      assert(this.host == txn<Sender>(), comment="It is the host's turn")
      this::make_move(1arc4u8, move)
    } else {
      assert(this.challenger == txn<Sender>(), comment="It is the challenger's turn")
      this::make_move(2arc4u8, move)
    }
    return (this.game, this.winner)
  }
  
  subroutine make_move(piece: puyapy.arc4.UInt8, move: tuple[puyapy.UInt64, puyapy.UInt64]): None
  {
    assert(move[0] < 3u and move[1] < 3u, comment="Move must be in range")
    assert(reinterpret_cast<puyapy.BigUInt>(this.game[move[1]][move[0]]) == reinterpret_cast<puyapy.BigUInt>(0arc4u8), comment="Square is already taken")
    this.game[move[1]][move[0]]: puyapy.arc4.UInt8 = piece
    this.turns += 1u
    this::check_winner()
    if (this.turns == 9u and reinterpret_cast<puyapy.Bytes>(this.winner) == hex<"00">) {
      this.winner: puyapy.arc4.UInt8 = 3arc4u8
    }
  }
  
  subroutine check_winner(): None
  {
    g: puyapy.arc4.StaticArray[puyapy.arc4.StaticArray[puyapy.arc4.UInt8, typing.Literal[3]], typing.Literal[3]] = this.game.copy()
    for row in g {
      if (reinterpret_cast<puyapy.Bytes>(row[0u]) != hex<"00"> and reinterpret_cast<puyapy.BigUInt>(row[0u]) == reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=0, source=row[1u])) and reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=0, source=row[1u])) == reinterpret_cast<puyapy.BigUInt>(row[2u])) {
        this.winner: puyapy.arc4.UInt8 = row[0u]
        return
      }
    }
    for col in range(0u, 3u, 1u) {
      if (reinterpret_cast<puyapy.Bytes>(g[0u][col]) != hex<"00"> and reinterpret_cast<puyapy.BigUInt>(g[0u][col]) == reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=1, source=g[1u][col])) and reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=1, source=g[1u][col])) == reinterpret_cast<puyapy.BigUInt>(g[2u][col])) {
        this.winner: puyapy.arc4.UInt8 = g[0u][col]
        return
      }
    }
    if (reinterpret_cast<puyapy.Bytes>(g[1u][1u]) != hex<"00">) {
      if (reinterpret_cast<puyapy.BigUInt>(g[0u][0u]) == reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=2, source=g[1u][1u])) and reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=2, source=g[1u][1u])) == reinterpret_cast<puyapy.BigUInt>(g[2u][2u])) {
        this.winner: puyapy.arc4.UInt8 = g[0u][0u]
      } else {
        if (reinterpret_cast<puyapy.BigUInt>(g[0u][2u]) == reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=3, source=g[1u][1u])) and reinterpret_cast<puyapy.BigUInt>(SINGLE_EVAL(id=3, source=g[1u][1u])) == reinterpret_cast<puyapy.BigUInt>(g[2u][0u])) {
          this.winner: puyapy.arc4.UInt8 = g[0u][2u]
        }
      }
    }
  }
}