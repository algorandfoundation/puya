EMPTY = 0
HOST = 1
CHALLENGER = 2
DRAW = 3

contract TicTacToeContract
{
  globals {
    ['host']: account
    ['game']: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3>
    ['turns']: uint64
    ['challenger']: account
    ['winner']: arc4.uint8
  }
  
  constructor()
  {
  }
  
  abimethod new_game(move: tuple<uint64,uint64>): void
  {
    if (reinterpret_cast<bool>(txn<ApplicationID>())) {
      if (STATE_EXISTS(GlobalState['challenger'])) {
        assert(STATE_EXISTS(GlobalState['winner']), comment="Game isn't over")
      }
      STATE_DELETE(GlobalState['challenger'])
      STATE_DELETE(GlobalState['winner'])
    }
    GlobalState['host']: account = txn<Sender>()
    GlobalState['game']: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3> = reinterpret_cast<arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3>>(bzero(9u))
    (column, row): tuple<uint64,uint64> = move
    assert(column < 3u and row < 3u, comment="Move must be in range")
    GlobalState['game'][row][column]: arc4.uint8 = 1arc4u8
    GlobalState['turns']: uint64 = 0u
  }
  
  abimethod join_game(move: tuple<uint64,uint64>): void
  {
    assert(!(STATE_EXISTS(GlobalState['challenger'])), comment="Host already has a challenger")
    GlobalState['challenger']: account = txn<Sender>()
    this::make_move(2arc4u8, move)
  }
  
  abimethod whose_turn(): arc4.uint8
  {
    return (reinterpret_cast<bool>(GlobalState['turns'] % 2u)) ? (1arc4u8) : (2arc4u8)
  }
  
  abimethod play(move: tuple<uint64,uint64>): void
  {
    assert(!(STATE_EXISTS(GlobalState['winner'])), comment="Game is already finished")
    if (reinterpret_cast<bool>(GlobalState['turns'] % 2u)) {
      assert(txn<Sender>() == GlobalState['host'], comment="It is the host's turn")
      player: arc4.uint8 = 1arc4u8
    } else {
      assert(txn<Sender>() == STATE_GET(GlobalState['challenger'], default=global<ZeroAddress>()), comment="It is the challenger's turn")
      player: arc4.uint8 = 2arc4u8
    }
    this::make_move(player, move)
  }
  
  subroutine make_move(player: arc4.uint8, move: tuple<uint64,uint64>): void
  {
    (column, row): tuple<uint64,uint64> = move
    assert(column < 3u and row < 3u, comment="Move must be in range")
    assert(reinterpret_cast<biguint>(GlobalState['game'][row][column]) == reinterpret_cast<biguint>(0arc4u8), comment="Square is already taken")
    GlobalState['game'][row][column]: arc4.uint8 = player
    GlobalState['turns'] += 1u
    if (this::did_win(player, column=column, row=row)) {
      GlobalState['winner']: arc4.uint8 = player
    } else {
      if (GlobalState['turns'] == 9u) {
        GlobalState['winner']: arc4.uint8 = 3arc4u8
      }
    }
  }
  
  subroutine did_win(player: arc4.uint8, column: uint64, row: uint64): bool
  {
    g: arc4.static_array<arc4.static_array<arc4.uint8, 3>, 3> = GlobalState['game'].copy()
    if (reinterpret_cast<biguint>(g[row][0u]) == reinterpret_cast<biguint>(SINGLE_EVAL(id=0, source=g[row][1u])) and reinterpret_cast<biguint>(SINGLE_EVAL(id=0, source=g[row][1u])) == reinterpret_cast<biguint>(g[row][2u])) {
      return true
    }
    if (reinterpret_cast<biguint>(g[0u][column]) == reinterpret_cast<biguint>(SINGLE_EVAL(id=1, source=g[1u][column])) and reinterpret_cast<biguint>(SINGLE_EVAL(id=1, source=g[1u][column])) == reinterpret_cast<biguint>(g[2u][column])) {
      return true
    }
    if (reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[1u][1u])) {
      if (reinterpret_cast<biguint>(g[0u][0u]) == reinterpret_cast<biguint>(player) and reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[2u][2u])) {
        return true
      }
      if (reinterpret_cast<biguint>(g[0u][2u]) == reinterpret_cast<biguint>(player) and reinterpret_cast<biguint>(player) == reinterpret_cast<biguint>(g[2u][0u])) {
        return true
      }
    }
    return false
  }
}