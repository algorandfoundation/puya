# AUTO GENERATED BY scripts/generate_avm_ops.py, DO NOT EDIT
import enum
from collections.abc import Sequence

from puya.errors import InternalError
from puya.ir.avm_ops_models import (
    AVMOpData,
    DynamicSignatures,
    ImmediateKind,
    OpSignature,
    StackType,
)


class AVMOp(enum.StrEnum):
    code: str
    immediate_types: Sequence[ImmediateKind]
    _signature: OpSignature | DynamicSignatures
    cost: int | None

    def __new__(cls, data: AVMOpData | str) -> "AVMOp":
        # the weird union type on data && then assert,
        # is to shut mypy up when it wrongly infers the arg type of
        # e.g. AVMOp("+") to be invalid
        assert isinstance(data, AVMOpData)
        op_code = data.op_code
        obj = str.__new__(cls, op_code)
        obj._value_ = op_code
        obj.code = op_code
        obj.immediate_types = tuple(data.immediate_types)
        obj._signature = data.signature  # noqa: SLF001
        obj.cost = data.cost
        return obj

    def get_signature(self, immediates: Sequence[str | int]) -> OpSignature:
        if isinstance(self._signature, OpSignature):
            return self._signature
        im = immediates[self._signature.immediate_index]
        assert isinstance(im, str)
        try:
            return self._signature.signatures[im]
        except KeyError as ex:
            raise InternalError(f"Unknown immediate for {self.code}: {im}") from ex

    acct_params_get = AVMOpData(
        op_code="acct_params_get",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "AcctBalance": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctMinBalance": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctAuthAddr": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.address, StackType.bool]
                ),
                "AcctTotalNumUint": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalNumByteSlice": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalExtraAppPages": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalAppsCreated": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalAppsOptedIn": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalAssetsCreated": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalAssets": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalBoxes": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
                "AcctTotalBoxBytes": OpSignature(
                    args=[StackType.address_or_index], returns=[StackType.uint64, StackType.bool]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    X is field F from account A. Y is 1 if A owns positive algos, else 0
    """

    add = AVMOpData(
        op_code="+",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A plus B. Fail on overflow.

    Overflow is an error condition which halts execution and fails the transaction. Full precision
    is available from `addw`.
    """

    add_bytes = AVMOpData(
        op_code="b+",
        signature=OpSignature(
            args=[StackType.bigint, StackType.bigint], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=10,
    )
    """
    A plus B. A and B are interpreted as big-endian unsigned integers
    """

    addw = AVMOpData(
        op_code="addw",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64, StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.
    """

    and_ = AVMOpData(
        op_code="&&",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A is not zero and B is not zero => {0 or 1}
    """

    app_global_del = AVMOpData(
        op_code="app_global_del",
        signature=OpSignature(args=[StackType.bytes], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    delete key A from the global state of the current application

    params: state key.


    Deleting a key which is already absent has no effect on the application global state. (In
    particular, it does _not_ cause the program to fail.)
    """

    app_global_get = AVMOpData(
        op_code="app_global_get",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.any]),
        immediate_types=(),
        cost=1,
    )
    """
    global state of the key A in the current application

    params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.
    """

    app_global_get_ex = AVMOpData(
        op_code="app_global_get_ex",
        signature=OpSignature(
            args=[StackType.uint64, StackType.bytes], returns=[StackType.any, StackType.bool]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    X is the global state of application A, key B. Y is 1 if key existed, else 0

    params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key.
    Return: did_exist flag (top of the stack, 1 if the application and key existed and 0
    otherwise), value. The value is zero (of type uint64) if the key does not exist.
    """

    app_global_put = AVMOpData(
        op_code="app_global_put",
        signature=OpSignature(args=[StackType.bytes, StackType.any], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    write B to key A in the global state of the current application
    """

    app_local_del = AVMOpData(
        op_code="app_local_del",
        signature=OpSignature(args=[StackType.address_or_index, StackType.bytes], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    delete key B from account A's local state of the current application

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.


    Deleting a key which is already absent has no effect on the application local state. (In
    particular, it does _not_ cause the program to fail.)
    """

    app_local_get = AVMOpData(
        op_code="app_local_get",
        signature=OpSignature(
            args=[StackType.address_or_index, StackType.bytes], returns=[StackType.any]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    local state of the key B in the current application in account A

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return:
    value. The value is zero (of type uint64) if the key does not exist.
    """

    app_local_get_ex = AVMOpData(
        op_code="app_local_get_ex",
        signature=OpSignature(
            args=[StackType.address_or_index, StackType.uint64, StackType.bytes],
            returns=[StackType.any, StackType.bool],
        ),
        immediate_types=(),
        cost=1,
    )
    """
    X is the local state of application B, key C in account A. Y is 1 if key existed, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top
    of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero
    (of type uint64) if the key does not exist.
    """

    app_local_put = AVMOpData(
        op_code="app_local_put",
        signature=OpSignature(
            args=[StackType.address_or_index, StackType.bytes, StackType.any], returns=[]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    write C to key B in account A's local state of the current application

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.
    """

    app_opted_in = AVMOpData(
        op_code="app_opted_in",
        signature=OpSignature(
            args=[StackType.address_or_index, StackType.uint64], returns=[StackType.bool]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    1 if account A is opted in to application B, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.
    """

    app_params_get = AVMOpData(
        op_code="app_params_get",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "AppApprovalProgram": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes, StackType.bool]
                ),
                "AppClearStateProgram": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes, StackType.bool]
                ),
                "AppGlobalNumUint": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AppGlobalNumByteSlice": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AppLocalNumUint": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AppLocalNumByteSlice": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AppExtraProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AppCreator": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
                "AppAddress": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    X is field F from app A. Y is 1 if A exists, else 0

    params: Txn.ForeignApps offset or an _available_ app id. Return: did_exist flag (1 if the
    application existed and 0 otherwise), value.
    """

    arg = AVMOpData(
        op_code="arg",
        signature=OpSignature(args=[], returns=[StackType.bytes]),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
    )
    """
    Nth LogicSig argument
    """

    arg_0 = AVMOpData(
        op_code="arg_0",
        signature=OpSignature(args=[], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    LogicSig argument 0
    """

    arg_1 = AVMOpData(
        op_code="arg_1",
        signature=OpSignature(args=[], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    LogicSig argument 1
    """

    arg_2 = AVMOpData(
        op_code="arg_2",
        signature=OpSignature(args=[], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    LogicSig argument 2
    """

    arg_3 = AVMOpData(
        op_code="arg_3",
        signature=OpSignature(args=[], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    LogicSig argument 3
    """

    args = AVMOpData(
        op_code="args",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    Ath LogicSig argument
    """

    assert_ = AVMOpData(
        op_code="assert",
        signature=OpSignature(args=[StackType.uint64], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    immediately fail unless A is a non-zero number
    """

    asset_holding_get = AVMOpData(
        op_code="asset_holding_get",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "AssetBalance": OpSignature(
                    args=[StackType.address_or_index, StackType.uint64],
                    returns=[StackType.uint64, StackType.bool],
                ),
                "AssetFrozen": OpSignature(
                    args=[StackType.address_or_index, StackType.uint64],
                    returns=[StackType.bool, StackType.bool],
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    X is field F from account A's holding of asset B. Y is 1 if A is opted into B, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ address), asset id (or, since v4, a
    Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise),
    value.
    """

    asset_params_get = AVMOpData(
        op_code="asset_params_get",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "AssetTotal": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AssetDecimals": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64, StackType.bool]
                ),
                "AssetDefaultFrozen": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bool, StackType.bool]
                ),
                "AssetUnitName": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes, StackType.bool]
                ),
                "AssetName": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes, StackType.bool]
                ),
                "AssetURL": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes, StackType.bool]
                ),
                "AssetMetadataHash": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes_32, StackType.bool]
                ),
                "AssetManager": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
                "AssetReserve": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
                "AssetFreeze": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
                "AssetClawback": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
                "AssetCreator": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address, StackType.bool]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    X is field F from asset A. Y is 1 if A exists, else 0

    params: Txn.ForeignAssets offset (or, since v4, an _available_ asset id. Return: did_exist flag
    (1 if the asset existed and 0 otherwise), value.
    """

    balance = AVMOpData(
        op_code="balance",
        signature=OpSignature(args=[StackType.address_or_index], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    balance for account A, in microalgos. The balance is observed after the effects of previous
    transactions in the group, and after the fee for the current transaction is deducted. Changes
    caused by inner transactions are observable immediately following `itxn_submit`

    params: Txn.Accounts offset (or, since v4, an _available_ account address). Return: value.
    """

    base64_decode = AVMOpData(
        op_code="base64_decode",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
    )
    """
    decode A which was base64-encoded using _encoding_ E. Fail if A is not base64 encoded with
    encoding E

    *Warning*: Usage should be restricted to very rare use cases. In almost all cases, smart
    contracts should directly handle non-encoded byte-strings.     This opcode should only be used
    in cases where base64 is the only available option, e.g. interoperability with a third-party
    that only signs base64 strings.


     Decodes A using the base64 encoding E. Specify the encoding with an immediate arg either as
    URL and Filename Safe (`URLEncoding`) or Standard (`StdEncoding`). See [RFC 4648 sections 4 and
    5](https://rfc-editor.org/rfc/rfc4648.html#section-4). It is assumed that the encoding ends
    with the exact number of `=` padding characters as required by the RFC. When padding occurs,
    any unused pad bits in the encoding must be set to zero or the decoding will fail. The special
    cases of `\n` and `\r` are allowed but completely ignored. An error will result when attempting
    to decode a string with a character that is not in the encoding alphabet or not one of `=`,
    `\r`, or `\n`.
    """

    bitlen = AVMOpData(
        op_code="bitlen",
        signature=OpSignature(args=[StackType.any], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned
    integer. bitlen of 0 is 0, bitlen of 8 is 4

    bitlen interprets arrays as big-endian integers, unlike setbit/getbit
    """

    bitwise_and = AVMOpData(
        op_code="&",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A bitwise-and B
    """

    bitwise_and_bytes = AVMOpData(
        op_code="b&",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=6,
    )
    """
    A bitwise-and B. A and B are zero-left extended to the greater of their lengths
    """

    bitwise_not = AVMOpData(
        op_code="~",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    bitwise invert value A
    """

    bitwise_not_bytes = AVMOpData(
        op_code="b~",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=4,
    )
    """
    A with all bits inverted
    """

    bitwise_or = AVMOpData(
        op_code="|",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A bitwise-or B
    """

    bitwise_or_bytes = AVMOpData(
        op_code="b|",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=6,
    )
    """
    A bitwise-or B. A and B are zero-left extended to the greater of their lengths
    """

    bitwise_xor = AVMOpData(
        op_code="^",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A bitwise-xor B
    """

    bitwise_xor_bytes = AVMOpData(
        op_code="b^",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=6,
    )
    """
    A bitwise-xor B. A and B are zero-left extended to the greater of their lengths
    """

    block = AVMOpData(
        op_code="block",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "BlkSeed": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "BlkTimestamp": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    field F of block A. Fail unless A falls between txn.LastValid-1002 and txn.FirstValid
    (exclusive)
    """

    box_create = AVMOpData(
        op_code="box_create",
        signature=OpSignature(
            args=[StackType.box_name, StackType.uint64], returns=[StackType.bool]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    create a box named A, of length B. Fail if A is empty or B exceeds 32,768. Returns 0 if A
    already existed, else 1

    Newly created boxes are filled with 0 bytes. `box_create` will fail if the referenced box
    already exists with a different size. Otherwise, existing boxes are unchanged by `box_create`.
    """

    box_del = AVMOpData(
        op_code="box_del",
        signature=OpSignature(args=[StackType.box_name], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    delete box named A if it exists. Return 1 if A existed, 0 otherwise
    """

    box_extract = AVMOpData(
        op_code="box_extract",
        signature=OpSignature(
            args=[StackType.box_name, StackType.uint64, StackType.uint64],
            returns=[StackType.bytes],
        ),
        immediate_types=(),
        cost=1,
    )
    """
    read C bytes from box A, starting at offset B. Fail if A does not exist, or the byte range is
    outside A's size.
    """

    box_get = AVMOpData(
        op_code="box_get",
        signature=OpSignature(
            args=[StackType.box_name], returns=[StackType.bytes, StackType.bool]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    X is the contents of box A if A exists, else ''. Y is 1 if A exists, else 0.

    For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
    """

    box_len = AVMOpData(
        op_code="box_len",
        signature=OpSignature(
            args=[StackType.box_name], returns=[StackType.uint64, StackType.bool]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    X is the length of box A if A exists, else 0. Y is 1 if A exists, else 0.
    """

    box_put = AVMOpData(
        op_code="box_put",
        signature=OpSignature(args=[StackType.box_name, StackType.bytes], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    replaces the contents of box A with byte-array B. Fails if A exists and len(B) != len(box A).
    Creates A if it does not exist

    For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
    """

    box_replace = AVMOpData(
        op_code="box_replace",
        signature=OpSignature(
            args=[StackType.box_name, StackType.uint64, StackType.bytes], returns=[]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    write byte-array C into box A, starting at offset B. Fail if A does not exist, or the byte
    range is outside A's size.
    """

    bsqrt = AVMOpData(
        op_code="bsqrt",
        signature=OpSignature(args=[StackType.bigint], returns=[StackType.bigint]),
        immediate_types=(),
        cost=40,
    )
    """
    The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned
    integers
    """

    btoi = AVMOpData(
        op_code="btoi",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    converts big-endian byte array A to uint64. Fails if len(A) > 8. Padded by leading 0s if len(A)
    < 8.

    `btoi` fails if the input is longer than 8 bytes.
    """

    bzero = AVMOpData(
        op_code="bzero",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    zero filled byte-array of length A
    """

    concat = AVMOpData(
        op_code="concat",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    join A and B

    `concat` fails if the result would be greater than 4096 bytes.
    """

    div_floor = AVMOpData(
        op_code="/",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A divided by B (truncated division). Fail if B == 0.

    `divmodw` is available to divide the two-element values produced by `mulw` and `addw`.
    """

    div_floor_bytes = AVMOpData(
        op_code="b/",
        signature=OpSignature(
            args=[StackType.bigint, StackType.bigint], returns=[StackType.bigint]
        ),
        immediate_types=(),
        cost=20,
    )
    """
    A divided by B (truncated division). A and B are interpreted as big-endian unsigned integers.
    Fail if B is zero.
    """

    divmodw = AVMOpData(
        op_code="divmodw",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64, StackType.uint64, StackType.uint64],
            returns=[StackType.uint64, StackType.uint64, StackType.uint64, StackType.uint64],
        ),
        immediate_types=(),
        cost=20,
    )
    """
    W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)

    The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value,
    with J as the high uint64 and K the low.
    """

    divw = AVMOpData(
        op_code="divw",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A,B / C. Fail if C == 0 or if result overflows.

    The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high
    uint64 and B the low.
    """

    ecdsa_pk_decompress = AVMOpData(
        op_code="ecdsa_pk_decompress",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes, StackType.bytes]),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
    )
    """
    decompress pubkey A into components X, Y

    The 33 byte public key in a compressed form to be decompressed into X and Y (top) components.
    All values are big-endian encoded.
    """

    ecdsa_pk_recover = AVMOpData(
        op_code="ecdsa_pk_recover",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64, StackType.bytes, StackType.bytes],
            returns=[StackType.bytes, StackType.bytes],
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=2000,
    )
    """
    for (data A, recovery id B, signature C, D) recover a public key

    S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack
    and used to deriver a public key. All values are big-endian encoded. The signed data must be 32
    bytes long.
    """

    ecdsa_verify = AVMOpData(
        op_code="ecdsa_verify",
        signature=OpSignature(
            args=[
                StackType.bytes,
                StackType.bytes,
                StackType.bytes,
                StackType.bytes,
                StackType.bytes,
            ],
            returns=[StackType.bool],
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
    )
    """
    for (data A, signature B, C and pubkey D, E) verify the signature of the data against the
    pubkey => {0 or 1}

    The 32 byte Y-component of a public key is the last element on the stack, preceded by
    X-component of a pubkey, preceded by S and R components of a signature, preceded by the data
    that is fifth element on the stack. All values are big-endian encoded. The signed data must be
    32 bytes long, and signatures in lower-S form are only accepted.
    """

    ed25519verify = AVMOpData(
        op_code="ed25519verify",
        signature=OpSignature(
            args=[StackType.bytes, StackType.bytes, StackType.bytes], returns=[StackType.bool]
        ),
        immediate_types=(),
        cost=1900,
    )
    """
    for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash ||
    data) against the pubkey => {0 or 1}

    The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at
    the second-to-last element on the stack, preceded by the data which was signed at the third-to-
    last element on the stack.
    """

    ed25519verify_bare = AVMOpData(
        op_code="ed25519verify_bare",
        signature=OpSignature(
            args=[StackType.bytes, StackType.bytes, StackType.bytes], returns=[StackType.bool]
        ),
        immediate_types=(),
        cost=1900,
    )
    """
    for (data A, signature B, pubkey C) verify the signature of the data against the pubkey => {0
    or 1}
    """

    eq = AVMOpData(
        op_code="==",
        signature=OpSignature(args=[StackType.any, StackType.any], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A is equal to B => {0 or 1}
    """

    eq_bytes = AVMOpData(
        op_code="b==",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    1 if A is equal to B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    exp = AVMOpData(
        op_code="exp",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A raised to the Bth power. Fail if A == B == 0 and on overflow
    """

    expw = AVMOpData(
        op_code="expw",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64, StackType.uint64]
        ),
        immediate_types=(),
        cost=10,
    )
    """
    A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the
    low. Fail if A == B == 0 or if the results exceeds 2^128-1
    """

    extract = AVMOpData(
        op_code="extract",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
    )
    """
    A range of bytes from A starting at S up to but not including S+L. If L is 0, then extract to
    the end of the string. If S or S+L is larger than the array length, the program fails
    """

    extract3 = AVMOpData(
        op_code="extract3",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64, StackType.uint64], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the
    array length, the program fails

    `extract3` can be called using `extract` with no immediates.
    """

    extract_uint16 = AVMOpData(
        op_code="extract_uint16",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A uint16 formed from a range of big-endian bytes from A starting at B up to but not including
    B+2. If B+2 is larger than the array length, the program fails
    """

    extract_uint32 = AVMOpData(
        op_code="extract_uint32",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A uint32 formed from a range of big-endian bytes from A starting at B up to but not including
    B+4. If B+4 is larger than the array length, the program fails
    """

    extract_uint64 = AVMOpData(
        op_code="extract_uint64",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A uint64 formed from a range of big-endian bytes from A starting at B up to but not including
    B+8. If B+8 is larger than the array length, the program fails
    """

    gaid = AVMOpData(
        op_code="gaid",
        signature=OpSignature(args=[], returns=[StackType.uint64]),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
    )
    """
    ID of the asset or application created in the Tth transaction of the current group

    `gaid` fails unless the requested transaction created an asset or application and T <
    GroupIndex.
    """

    gaids = AVMOpData(
        op_code="gaids",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    ID of the asset or application created in the Ath transaction of the current group

    `gaids` fails unless the requested transaction created an asset or application and A <
    GroupIndex.
    """

    getbit = AVMOpData(
        op_code="getbit",
        signature=OpSignature(args=[StackType.any, StackType.uint64], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    Bth bit of (byte-array or integer) A. If B is greater than or equal to the bit length of the
    value (8*byte length), the program fails

    see explanation of bit ordering in setbit
    """

    getbyte = AVMOpData(
        op_code="getbyte",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    Bth byte of A, as an integer. If B is greater than or equal to the array length, the program
    fails
    """

    gitxn = AVMOpData(
        op_code="gitxn",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "Sender": OpSignature(args=[], returns=[StackType.address]),
                "Fee": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValid": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValidTime": OpSignature(args=[], returns=[StackType.uint64]),
                "LastValid": OpSignature(args=[], returns=[StackType.uint64]),
                "Note": OpSignature(args=[], returns=[StackType.bytes]),
                "Lease": OpSignature(args=[], returns=[StackType.bytes_32]),
                "Receiver": OpSignature(args=[], returns=[StackType.address]),
                "Amount": OpSignature(args=[], returns=[StackType.uint64]),
                "CloseRemainderTo": OpSignature(args=[], returns=[StackType.address]),
                "VotePK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "SelectionPK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "VoteFirst": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteLast": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteKeyDilution": OpSignature(args=[], returns=[StackType.uint64]),
                "Type": OpSignature(args=[], returns=[StackType.bytes]),
                "TypeEnum": OpSignature(args=[], returns=[StackType.uint64]),
                "XferAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetAmount": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetSender": OpSignature(args=[], returns=[StackType.address]),
                "AssetReceiver": OpSignature(args=[], returns=[StackType.address]),
                "AssetCloseTo": OpSignature(args=[], returns=[StackType.address]),
                "GroupIndex": OpSignature(args=[], returns=[StackType.uint64]),
                "TxID": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "OnCompletion": OpSignature(args=[], returns=[StackType.uint64]),
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumAppArgs": OpSignature(args=[], returns=[StackType.uint64]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "NumAccounts": OpSignature(args=[], returns=[StackType.uint64]),
                "ApprovalProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "RekeyTo": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetTotal": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDecimals": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDefaultFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "ConfigAssetUnitName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetURL": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetMetadataHash": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ConfigAssetManager": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetReserve": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetFreeze": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetClawback": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "FreezeAssetAccount": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAssetFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "NumAssets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "NumApplications": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "ExtraProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "Nonparticipation": OpSignature(args=[], returns=[StackType.bool]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumLogs": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedAssetID": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "LastLog": OpSignature(args=[], returns=[StackType.bytes]),
                "StateProofPK": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumApprovalProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumClearStateProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
    )
    """
    field F of the Tth transaction in the last inner group submitted
    """

    gitxna = AVMOpData(
        op_code="gitxna",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith value of the array field F from the Tth transaction in the last inner group submitted
    """

    gitxnas = AVMOpData(
        op_code="gitxnas",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
    )
    """
    Ath value of the array field F from the Tth transaction in the last inner group submitted
    """

    gload = AVMOpData(
        op_code="gload",
        signature=OpSignature(args=[], returns=[StackType.any]),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith scratch space value of the Tth transaction in the current group

    `gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.
    """

    gloads = AVMOpData(
        op_code="gloads",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.any]),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
    )
    """
    Ith scratch space value of the Ath transaction in the current group

    `gloads` fails unless the requested transaction is an ApplicationCall and A < GroupIndex.
    """

    gloadss = AVMOpData(
        op_code="gloadss",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.any]),
        immediate_types=(),
        cost=1,
    )
    """
    Bth scratch space value of the Ath transaction in the current group
    """

    global_ = AVMOpData(
        op_code="global",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "MinTxnFee": OpSignature(args=[], returns=[StackType.uint64]),
                "MinBalance": OpSignature(args=[], returns=[StackType.uint64]),
                "MaxTxnLife": OpSignature(args=[], returns=[StackType.uint64]),
                "ZeroAddress": OpSignature(args=[], returns=[StackType.address]),
                "GroupSize": OpSignature(args=[], returns=[StackType.uint64]),
                "LogicSigVersion": OpSignature(args=[], returns=[StackType.uint64]),
                "Round": OpSignature(args=[], returns=[StackType.uint64]),
                "LatestTimestamp": OpSignature(args=[], returns=[StackType.uint64]),
                "CurrentApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatorAddress": OpSignature(args=[], returns=[StackType.address]),
                "CurrentApplicationAddress": OpSignature(args=[], returns=[StackType.address]),
                "GroupID": OpSignature(args=[], returns=[StackType.bytes_32]),
                "OpcodeBudget": OpSignature(args=[], returns=[StackType.uint64]),
                "CallerApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "CallerApplicationAddress": OpSignature(args=[], returns=[StackType.address]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    global field F
    """

    gt = AVMOpData(
        op_code=">",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A greater than B => {0 or 1}
    """

    gt_bytes = AVMOpData(
        op_code="b>",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    1 if A is greater than B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    gte = AVMOpData(
        op_code=">=",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A greater than or equal to B => {0 or 1}
    """

    gte_bytes = AVMOpData(
        op_code="b>=",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    1 if A is greater than or equal to B, else 0. A and B are interpreted as big-endian unsigned
    integers
    """

    gtxn = AVMOpData(
        op_code="gtxn",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "Sender": OpSignature(args=[], returns=[StackType.address]),
                "Fee": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValid": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValidTime": OpSignature(args=[], returns=[StackType.uint64]),
                "LastValid": OpSignature(args=[], returns=[StackType.uint64]),
                "Note": OpSignature(args=[], returns=[StackType.bytes]),
                "Lease": OpSignature(args=[], returns=[StackType.bytes_32]),
                "Receiver": OpSignature(args=[], returns=[StackType.address]),
                "Amount": OpSignature(args=[], returns=[StackType.uint64]),
                "CloseRemainderTo": OpSignature(args=[], returns=[StackType.address]),
                "VotePK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "SelectionPK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "VoteFirst": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteLast": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteKeyDilution": OpSignature(args=[], returns=[StackType.uint64]),
                "Type": OpSignature(args=[], returns=[StackType.bytes]),
                "TypeEnum": OpSignature(args=[], returns=[StackType.uint64]),
                "XferAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetAmount": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetSender": OpSignature(args=[], returns=[StackType.address]),
                "AssetReceiver": OpSignature(args=[], returns=[StackType.address]),
                "AssetCloseTo": OpSignature(args=[], returns=[StackType.address]),
                "GroupIndex": OpSignature(args=[], returns=[StackType.uint64]),
                "TxID": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "OnCompletion": OpSignature(args=[], returns=[StackType.uint64]),
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumAppArgs": OpSignature(args=[], returns=[StackType.uint64]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "NumAccounts": OpSignature(args=[], returns=[StackType.uint64]),
                "ApprovalProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "RekeyTo": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetTotal": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDecimals": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDefaultFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "ConfigAssetUnitName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetURL": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetMetadataHash": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ConfigAssetManager": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetReserve": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetFreeze": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetClawback": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "FreezeAssetAccount": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAssetFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "NumAssets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "NumApplications": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "ExtraProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "Nonparticipation": OpSignature(args=[], returns=[StackType.bool]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumLogs": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedAssetID": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "LastLog": OpSignature(args=[], returns=[StackType.bytes]),
                "StateProofPK": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumApprovalProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumClearStateProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
    )
    """
    field F of the Tth transaction in the current group

    for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group,
    `gtxn i field` is equivalent to `txn field`.
    """

    gtxna = AVMOpData(
        op_code="gtxna",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith value of the array field F from the Tth transaction in the current group

    `gtxna` can be called using `gtxn` with 3 immediates.
    """

    gtxnas = AVMOpData(
        op_code="gtxnas",
        signature=DynamicSignatures(
            immediate_index=1,
            signatures={
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
    )
    """
    Ath value of the array field F from the Tth transaction in the current group
    """

    gtxns = AVMOpData(
        op_code="gtxns",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "Sender": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Fee": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "FirstValid": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "FirstValidTime": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "LastValid": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Note": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Lease": OpSignature(args=[StackType.uint64], returns=[StackType.bytes_32]),
                "Receiver": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Amount": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "CloseRemainderTo": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "VotePK": OpSignature(args=[StackType.uint64], returns=[StackType.bytes_32]),
                "SelectionPK": OpSignature(args=[StackType.uint64], returns=[StackType.bytes_32]),
                "VoteFirst": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "VoteLast": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "VoteKeyDilution": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "Type": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "TypeEnum": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "XferAsset": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "AssetAmount": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "AssetSender": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "AssetReceiver": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "AssetCloseTo": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "GroupIndex": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "TxID": OpSignature(args=[StackType.uint64], returns=[StackType.bytes_32]),
                "ApplicationID": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "OnCompletion": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "NumAppArgs": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "NumAccounts": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "ApprovalProgram": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ClearStateProgram": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "RekeyTo": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "ConfigAsset": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "ConfigAssetTotal": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "ConfigAssetDecimals": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "ConfigAssetDefaultFrozen": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bool]
                ),
                "ConfigAssetUnitName": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ConfigAssetName": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ConfigAssetURL": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ConfigAssetMetadataHash": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes_32]
                ),
                "ConfigAssetManager": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "ConfigAssetReserve": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "ConfigAssetFreeze": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "ConfigAssetClawback": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "FreezeAsset": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "FreezeAssetAccount": OpSignature(
                    args=[StackType.uint64], returns=[StackType.address]
                ),
                "FreezeAssetFrozen": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bool]
                ),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "NumAssets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "NumApplications": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "GlobalNumUint": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "GlobalNumByteSlice": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "LocalNumUint": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "LocalNumByteSlice": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "ExtraProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "Nonparticipation": OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "NumLogs": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "CreatedAssetID": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "CreatedApplicationID": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "LastLog": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "StateProofPK": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "NumApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "NumClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.uint64]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    field F of the Ath transaction in the current group

    for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is
    equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the
    index of the current transaction.
    """

    gtxnsa = AVMOpData(
        op_code="gtxnsa",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith value of the array field F from the Ath transaction in the current group

    `gtxnsa` can be called using `gtxns` with 2 immediates.
    """

    gtxnsas = AVMOpData(
        op_code="gtxnsas",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                ),
                "Accounts": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.address]
                ),
                "Assets": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
                ),
                "Applications": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
                ),
                "Logs": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                ),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    Bth value of the array field F from the Ath transaction in the current group
    """

    itob = AVMOpData(
        op_code="itob",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
        immediate_types=(),
        cost=1,
    )
    """
    converts uint64 A to big-endian byte array, always of length 8
    """

    itxn = AVMOpData(
        op_code="itxn",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "Sender": OpSignature(args=[], returns=[StackType.address]),
                "Fee": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValid": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValidTime": OpSignature(args=[], returns=[StackType.uint64]),
                "LastValid": OpSignature(args=[], returns=[StackType.uint64]),
                "Note": OpSignature(args=[], returns=[StackType.bytes]),
                "Lease": OpSignature(args=[], returns=[StackType.bytes_32]),
                "Receiver": OpSignature(args=[], returns=[StackType.address]),
                "Amount": OpSignature(args=[], returns=[StackType.uint64]),
                "CloseRemainderTo": OpSignature(args=[], returns=[StackType.address]),
                "VotePK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "SelectionPK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "VoteFirst": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteLast": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteKeyDilution": OpSignature(args=[], returns=[StackType.uint64]),
                "Type": OpSignature(args=[], returns=[StackType.bytes]),
                "TypeEnum": OpSignature(args=[], returns=[StackType.uint64]),
                "XferAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetAmount": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetSender": OpSignature(args=[], returns=[StackType.address]),
                "AssetReceiver": OpSignature(args=[], returns=[StackType.address]),
                "AssetCloseTo": OpSignature(args=[], returns=[StackType.address]),
                "GroupIndex": OpSignature(args=[], returns=[StackType.uint64]),
                "TxID": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "OnCompletion": OpSignature(args=[], returns=[StackType.uint64]),
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumAppArgs": OpSignature(args=[], returns=[StackType.uint64]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "NumAccounts": OpSignature(args=[], returns=[StackType.uint64]),
                "ApprovalProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "RekeyTo": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetTotal": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDecimals": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDefaultFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "ConfigAssetUnitName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetURL": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetMetadataHash": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ConfigAssetManager": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetReserve": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetFreeze": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetClawback": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "FreezeAssetAccount": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAssetFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "NumAssets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "NumApplications": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "ExtraProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "Nonparticipation": OpSignature(args=[], returns=[StackType.bool]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumLogs": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedAssetID": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "LastLog": OpSignature(args=[], returns=[StackType.bytes]),
                "StateProofPK": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumApprovalProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumClearStateProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    field F of the last inner transaction
    """

    itxn_begin = AVMOpData(
        op_code="itxn_begin",
        signature=OpSignature(args=[], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    begin preparation of a new inner transaction in a new transaction group

    `itxn_begin` initializes Sender to the application address; Fee to the minimum allowable,
    taking into account MinTxnFee and credit from overpaying in earlier transactions;
    FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or
    empty values.
    """

    itxn_field = AVMOpData(
        op_code="itxn_field",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "Sender": OpSignature(args=[StackType.address], returns=[]),
                "Fee": OpSignature(args=[StackType.uint64], returns=[]),
                "Note": OpSignature(args=[StackType.bytes], returns=[]),
                "Receiver": OpSignature(args=[StackType.address], returns=[]),
                "Amount": OpSignature(args=[StackType.uint64], returns=[]),
                "CloseRemainderTo": OpSignature(args=[StackType.address], returns=[]),
                "VotePK": OpSignature(args=[StackType.bytes_32], returns=[]),
                "SelectionPK": OpSignature(args=[StackType.bytes_32], returns=[]),
                "VoteFirst": OpSignature(args=[StackType.uint64], returns=[]),
                "VoteLast": OpSignature(args=[StackType.uint64], returns=[]),
                "VoteKeyDilution": OpSignature(args=[StackType.uint64], returns=[]),
                "Type": OpSignature(args=[StackType.bytes], returns=[]),
                "TypeEnum": OpSignature(args=[StackType.uint64], returns=[]),
                "XferAsset": OpSignature(args=[StackType.uint64], returns=[]),
                "AssetAmount": OpSignature(args=[StackType.uint64], returns=[]),
                "AssetSender": OpSignature(args=[StackType.address], returns=[]),
                "AssetReceiver": OpSignature(args=[StackType.address], returns=[]),
                "AssetCloseTo": OpSignature(args=[StackType.address], returns=[]),
                "ApplicationID": OpSignature(args=[StackType.uint64], returns=[]),
                "OnCompletion": OpSignature(args=[StackType.uint64], returns=[]),
                "ApplicationArgs": OpSignature(args=[StackType.bytes], returns=[]),
                "Accounts": OpSignature(args=[StackType.address], returns=[]),
                "ApprovalProgram": OpSignature(args=[StackType.bytes], returns=[]),
                "ClearStateProgram": OpSignature(args=[StackType.bytes], returns=[]),
                "RekeyTo": OpSignature(args=[StackType.address], returns=[]),
                "ConfigAsset": OpSignature(args=[StackType.uint64], returns=[]),
                "ConfigAssetTotal": OpSignature(args=[StackType.uint64], returns=[]),
                "ConfigAssetDecimals": OpSignature(args=[StackType.uint64], returns=[]),
                "ConfigAssetDefaultFrozen": OpSignature(args=[StackType.bool], returns=[]),
                "ConfigAssetUnitName": OpSignature(args=[StackType.bytes], returns=[]),
                "ConfigAssetName": OpSignature(args=[StackType.bytes], returns=[]),
                "ConfigAssetURL": OpSignature(args=[StackType.bytes], returns=[]),
                "ConfigAssetMetadataHash": OpSignature(args=[StackType.bytes_32], returns=[]),
                "ConfigAssetManager": OpSignature(args=[StackType.address], returns=[]),
                "ConfigAssetReserve": OpSignature(args=[StackType.address], returns=[]),
                "ConfigAssetFreeze": OpSignature(args=[StackType.address], returns=[]),
                "ConfigAssetClawback": OpSignature(args=[StackType.address], returns=[]),
                "FreezeAsset": OpSignature(args=[StackType.uint64], returns=[]),
                "FreezeAssetAccount": OpSignature(args=[StackType.address], returns=[]),
                "FreezeAssetFrozen": OpSignature(args=[StackType.bool], returns=[]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[]),
                "GlobalNumUint": OpSignature(args=[StackType.uint64], returns=[]),
                "GlobalNumByteSlice": OpSignature(args=[StackType.uint64], returns=[]),
                "LocalNumUint": OpSignature(args=[StackType.uint64], returns=[]),
                "LocalNumByteSlice": OpSignature(args=[StackType.uint64], returns=[]),
                "ExtraProgramPages": OpSignature(args=[StackType.uint64], returns=[]),
                "Nonparticipation": OpSignature(args=[StackType.bool], returns=[]),
                "StateProofPK": OpSignature(args=[StackType.bytes], returns=[]),
                "ApprovalProgramPages": OpSignature(args=[StackType.bytes], returns=[]),
                "ClearStateProgramPages": OpSignature(args=[StackType.bytes], returns=[]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    set field F of the current inner transaction to A

    `itxn_field` fails if A is of the wrong type for F, including a byte array of the wrong size
    for use as an address when F is an address field. `itxn_field` also fails if A is an account,
    asset, or app that is not _available_, or an attempt is made extend an array field beyond the
    limit imposed by consensus parameters. (Addresses set into asset params of acfg transactions
    need not be _available_.)
    """

    itxn_next = AVMOpData(
        op_code="itxn_next", signature=OpSignature(args=[], returns=[]), immediate_types=(), cost=1
    )
    """
    begin preparation of a new inner transaction in the same transaction group

    `itxn_next` initializes the transaction exactly as `itxn_begin` does
    """

    itxn_submit = AVMOpData(
        op_code="itxn_submit",
        signature=OpSignature(args=[], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    execute the current inner transaction group. Fail if executing this group would exceed the
    inner transaction limit, or if any transaction in the group fails.

    `itxn_submit` resets the current transaction so that it can not be resubmitted. A new
    `itxn_begin` is required to prepare another inner transaction.
    """

    itxna = AVMOpData(
        op_code="itxna",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith value of the array field F of the last inner transaction
    """

    itxnas = AVMOpData(
        op_code="itxnas",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    Ath value of the array field F of the last inner transaction
    """

    json_ref = AVMOpData(
        op_code="json_ref",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "JSONString": OpSignature(
                    args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
                ),
                "JSONUint64": OpSignature(
                    args=[StackType.bytes, StackType.bytes], returns=[StackType.uint64]
                ),
                "JSONObject": OpSignature(
                    args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
    )
    """
    key B's value, of type R, from a [valid](jsonspec.md) utf-8 encoded json object A

    *Warning*: Usage should be restricted to very rare use cases, as JSON decoding is expensive and
    quite limited. In addition, JSON objects are large and not optimized for size.


    Almost all smart contracts should use simpler and smaller methods (such as the
    [ABI](https://arc.algorand.foundation/ARCs/arc-0004). This opcode should only be used in cases
    where JSON is only available option, e.g. when a third-party only signs JSON.
    """

    keccak256 = AVMOpData(
        op_code="keccak256",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes_32]),
        immediate_types=(),
        cost=130,
    )
    """
    Keccak256 hash of value A, yields [32]byte
    """

    len_ = AVMOpData(
        op_code="len",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    yields length of byte value A
    """

    log = AVMOpData(
        op_code="log",
        signature=OpSignature(args=[StackType.bytes], returns=[]),
        immediate_types=(),
        cost=1,
    )
    """
    write A to log state of the current application

    `log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes
    exceeds 1024 bytes.
    """

    lt = AVMOpData(
        op_code="<",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A less than B => {0 or 1}
    """

    lt_bytes = AVMOpData(
        op_code="b<",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    1 if A is less than B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    lte = AVMOpData(
        op_code="<=",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A less than or equal to B => {0 or 1}
    """

    lte_bytes = AVMOpData(
        op_code="b<=",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    1 if A is less than or equal to B, else 0. A and B are interpreted as big-endian unsigned
    integers
    """

    min_balance = AVMOpData(
        op_code="min_balance",
        signature=OpSignature(args=[StackType.address_or_index], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    minimum required balance for account A, in microalgos. Required balance is affected by ASA,
    App, and Box usage. When creating or opting into an app, the minimum balance grows before the
    app code runs, therefore the increase is visible there. When deleting or closing out, the
    minimum balance decreases after the app executes. Changes caused by inner transactions or box
    usage are observable immediately following the opcode effecting the change.

    params: Txn.Accounts offset (or, since v4, an _available_ account address). Return: value.
    """

    mod = AVMOpData(
        op_code="%",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A modulo B. Fail if B == 0.
    """

    mod_bytes = AVMOpData(
        op_code="b%",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=20,
    )
    """
    A modulo B. A and B are interpreted as big-endian unsigned integers. Fail if B is zero.
    """

    mul = AVMOpData(
        op_code="*",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A times B. Fail on overflow.

    Overflow is an error condition which halts execution and fails the transaction. Full precision
    is available from `mulw`.
    """

    mul_bytes = AVMOpData(
        op_code="b*",
        signature=OpSignature(
            args=[StackType.bigint, StackType.bigint], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=20,
    )
    """
    A times B. A and B are interpreted as big-endian unsigned integers.
    """

    mulw = AVMOpData(
        op_code="mulw",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64, StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low
    """

    neq = AVMOpData(
        op_code="!=",
        signature=OpSignature(args=[StackType.any, StackType.any], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A is not equal to B => {0 or 1}
    """

    neq_bytes = AVMOpData(
        op_code="b!=",
        signature=OpSignature(args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers
    """

    not_ = AVMOpData(
        op_code="!",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
        immediate_types=(),
        cost=1,
    )
    """
    A == 0 yields 1; else 0
    """

    or_ = AVMOpData(
        op_code="||",
        signature=OpSignature(args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]),
        immediate_types=(),
        cost=1,
    )
    """
    A is not zero or B is not zero => {0 or 1}
    """

    replace2 = AVMOpData(
        op_code="replace2",
        signature=OpSignature(args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
    )
    """
    Copy of A with the bytes starting at S replaced by the bytes of B. Fails if S+len(B) exceeds
    len(A)

    `replace2` can be called using `replace` with 1 immediate.
    """

    replace3 = AVMOpData(
        op_code="replace3",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64, StackType.bytes], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    Copy of A with the bytes starting at B replaced by the bytes of C. Fails if B+len(C) exceeds
    len(A)

    `replace3` can be called using `replace` with no immediates.
    """

    select = AVMOpData(
        op_code="select",
        signature=OpSignature(
            args=[StackType.any, StackType.any, StackType.uint64], returns=[StackType.any]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    selects one of two values based on top-of-stack: B if C != 0, else A
    """

    setbit = AVMOpData(
        op_code="setbit",
        signature=OpSignature(
            args=[StackType.any, StackType.uint64, StackType.uint64], returns=[StackType.any]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C. If B is greater than or
    equal to the bit length of the value (8*byte length), the program fails

    When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0
    yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte.
    Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000.
    Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.
    """

    setbyte = AVMOpData(
        op_code="setbyte",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64, StackType.uint64], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    Copy of A with the Bth byte set to small integer (between 0..255) C. If B is greater than or
    equal to the array length, the program fails
    """

    sha256 = AVMOpData(
        op_code="sha256",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes_32]),
        immediate_types=(),
        cost=35,
    )
    """
    SHA256 hash of value A, yields [32]byte
    """

    sha3_256 = AVMOpData(
        op_code="sha3_256",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(),
        cost=130,
    )
    """
    SHA3_256 hash of value A, yields [32]byte
    """

    sha512_256 = AVMOpData(
        op_code="sha512_256",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes_32]),
        immediate_types=(),
        cost=45,
    )
    """
    SHA512_256 hash of value A, yields [32]byte
    """

    shl = AVMOpData(
        op_code="shl",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A times 2^B, modulo 2^64
    """

    shr = AVMOpData(
        op_code="shr",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A divided by 2^B
    """

    sqrt = AVMOpData(
        op_code="sqrt",
        signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
        immediate_types=(),
        cost=4,
    )
    """
    The largest integer I such that I^2 <= A
    """

    sub = AVMOpData(
        op_code="-",
        signature=OpSignature(
            args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A minus B. Fail if B > A.
    """

    sub_bytes = AVMOpData(
        op_code="b-",
        signature=OpSignature(
            args=[StackType.bigint, StackType.bigint], returns=[StackType.bigint]
        ),
        immediate_types=(),
        cost=10,
    )
    """
    A minus B. A and B are interpreted as big-endian unsigned integers. Fail on underflow.
    """

    substring = AVMOpData(
        op_code="substring",
        signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
    )
    """
    A range of bytes from A starting at S up to but not including E. If E < S, or either is larger
    than the array length, the program fails
    """

    substring3 = AVMOpData(
        op_code="substring3",
        signature=OpSignature(
            args=[StackType.bytes, StackType.uint64, StackType.uint64], returns=[StackType.bytes]
        ),
        immediate_types=(),
        cost=1,
    )
    """
    A range of bytes from A starting at B up to but not including C. If C < B, or either is larger
    than the array length, the program fails
    """

    txn = AVMOpData(
        op_code="txn",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "Sender": OpSignature(args=[], returns=[StackType.address]),
                "Fee": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValid": OpSignature(args=[], returns=[StackType.uint64]),
                "FirstValidTime": OpSignature(args=[], returns=[StackType.uint64]),
                "LastValid": OpSignature(args=[], returns=[StackType.uint64]),
                "Note": OpSignature(args=[], returns=[StackType.bytes]),
                "Lease": OpSignature(args=[], returns=[StackType.bytes_32]),
                "Receiver": OpSignature(args=[], returns=[StackType.address]),
                "Amount": OpSignature(args=[], returns=[StackType.uint64]),
                "CloseRemainderTo": OpSignature(args=[], returns=[StackType.address]),
                "VotePK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "SelectionPK": OpSignature(args=[], returns=[StackType.bytes_32]),
                "VoteFirst": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteLast": OpSignature(args=[], returns=[StackType.uint64]),
                "VoteKeyDilution": OpSignature(args=[], returns=[StackType.uint64]),
                "Type": OpSignature(args=[], returns=[StackType.bytes]),
                "TypeEnum": OpSignature(args=[], returns=[StackType.uint64]),
                "XferAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetAmount": OpSignature(args=[], returns=[StackType.uint64]),
                "AssetSender": OpSignature(args=[], returns=[StackType.address]),
                "AssetReceiver": OpSignature(args=[], returns=[StackType.address]),
                "AssetCloseTo": OpSignature(args=[], returns=[StackType.address]),
                "GroupIndex": OpSignature(args=[], returns=[StackType.uint64]),
                "TxID": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "OnCompletion": OpSignature(args=[], returns=[StackType.uint64]),
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumAppArgs": OpSignature(args=[], returns=[StackType.uint64]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "NumAccounts": OpSignature(args=[], returns=[StackType.uint64]),
                "ApprovalProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgram": OpSignature(args=[], returns=[StackType.bytes]),
                "RekeyTo": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetTotal": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDecimals": OpSignature(args=[], returns=[StackType.uint64]),
                "ConfigAssetDefaultFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "ConfigAssetUnitName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetName": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetURL": OpSignature(args=[], returns=[StackType.bytes]),
                "ConfigAssetMetadataHash": OpSignature(args=[], returns=[StackType.bytes_32]),
                "ConfigAssetManager": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetReserve": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetFreeze": OpSignature(args=[], returns=[StackType.address]),
                "ConfigAssetClawback": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAsset": OpSignature(args=[], returns=[StackType.uint64]),
                "FreezeAssetAccount": OpSignature(args=[], returns=[StackType.address]),
                "FreezeAssetFrozen": OpSignature(args=[], returns=[StackType.bool]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "NumAssets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "NumApplications": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "GlobalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumUint": OpSignature(args=[], returns=[StackType.uint64]),
                "LocalNumByteSlice": OpSignature(args=[], returns=[StackType.uint64]),
                "ExtraProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "Nonparticipation": OpSignature(args=[], returns=[StackType.bool]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "NumLogs": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedAssetID": OpSignature(args=[], returns=[StackType.uint64]),
                "CreatedApplicationID": OpSignature(args=[], returns=[StackType.uint64]),
                "LastLog": OpSignature(args=[], returns=[StackType.bytes]),
                "StateProofPK": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumApprovalProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "NumClearStateProgramPages": OpSignature(args=[], returns=[StackType.uint64]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    field F of current transaction
    """

    txna = AVMOpData(
        op_code="txna",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(args=[], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[], returns=[StackType.address]),
                "Assets": OpSignature(args=[], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
                "ClearStateProgramPages": OpSignature(args=[], returns=[StackType.bytes]),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
    )
    """
    Ith value of the array field F of the current transaction

    `txna` can be called using `txn` with 2 immediates.
    """

    txnas = AVMOpData(
        op_code="txnas",
        signature=DynamicSignatures(
            immediate_index=0,
            signatures={
                "ApplicationArgs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "Accounts": OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                "Assets": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Applications": OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                "Logs": OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                "ApprovalProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
                "ClearStateProgramPages": OpSignature(
                    args=[StackType.uint64], returns=[StackType.bytes]
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
    )
    """
    Ath value of the array field F of the current transaction
    """

    vrf_verify = AVMOpData(
        op_code="vrf_verify",
        signature=OpSignature(
            args=[StackType.bytes, StackType.bytes, StackType.bytes],
            returns=[StackType.bytes, StackType.bool],
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=5700,
    )
    """
    Verify the proof B of message A against pubkey C. Returns vrf output and verification flag.

    `VrfAlgorand` is the VRF used in Algorand. It is ECVRF-ED25519-SHA512-Elligator2, specified in
    the IETF internet draft [draft-irtf-cfrg-vrf-03](https://datatracker.ietf.org/doc/draft-irtf-
    cfrg-vrf/03/).
    """
