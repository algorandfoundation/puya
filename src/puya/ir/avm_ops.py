# AUTO GENERATED BY scripts/generate_avm_ops.py, DO NOT EDIT
import enum
from collections.abc import Sequence

from puya.errors import InternalError
from puya.ir.avm_ops_models import (
    AVMOpData,
    DynamicVariants,
    ImmediateKind,
    OpSignature,
    RunMode,
    StackType,
    Variant,
)


class AVMOp(enum.StrEnum):
    code: str
    immediate_types: Sequence[ImmediateKind]
    _variants: Variant | DynamicVariants
    cost: int | None
    min_avm_version: int

    def __new__(cls, data: AVMOpData | str) -> "AVMOp":
        # the weird union type on data && then assert,
        # is to shut mypy up when it wrongly infers the arg type of
        # e.g. AVMOp("+") to be invalid
        assert isinstance(data, AVMOpData)
        op_code = data.op_code
        obj = str.__new__(cls, op_code)
        obj._value_ = op_code
        obj.code = op_code
        obj.immediate_types = tuple(data.immediate_types)
        obj._variants = data.variants  # noqa: SLF001
        obj.cost = data.cost
        obj.min_avm_version = data.min_avm_version
        return obj

    def get_variant(self, immediates: Sequence[str | int]) -> Variant:
        if isinstance(self._variants, Variant):
            return self._variants
        im = immediates[self._variants.immediate_index]
        assert isinstance(im, str)
        try:
            return self._variants.variant_map[im]
        except KeyError as ex:
            raise InternalError(f"Unknown immediate for {self.code}: {im}") from ex

    acct_params_get = AVMOpData(
        op_code="acct_params_get",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "AcctBalance": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctMinBalance": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctAuthAddr": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.address, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalNumUint": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalNumByteSlice": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalExtraAppPages": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalAppsCreated": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalAppsOptedIn": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalAssetsCreated": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalAssets": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalBoxes": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AcctTotalBoxBytes": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    X is field F from account A. Y is 1 if A owns positive algos, else 0
    """

    add = AVMOpData(
        op_code="+",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A plus B. Fail on overflow.

    Overflow is an error condition which halts execution and fails the transaction. Full precision
    is available from `addw`.
    """

    add_bytes = AVMOpData(
        op_code="b+",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=10,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A plus B. A and B are interpreted as big-endian unsigned integers
    """

    addw = AVMOpData(
        op_code="addw",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64],
                returns=[StackType.uint64, StackType.uint64],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.
    """

    and_ = AVMOpData(
        op_code="&&",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A is not zero and B is not zero => {0 or 1}
    """

    app_global_del = AVMOpData(
        op_code="app_global_del",
        variants=Variant(
            signature=OpSignature(args=[StackType.state_key], returns=[]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    delete key A from the global state of the current application

    params: state key.


    Deleting a key which is already absent has no effect on the application global state. (In
    particular, it does _not_ cause the program to fail.)
    """

    app_global_get = AVMOpData(
        op_code="app_global_get",
        variants=Variant(
            signature=OpSignature(args=[StackType.state_key], returns=[StackType.any]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    global state of the key A in the current application

    params: state key. Return: value. The value is zero (of type uint64) if the key does not exist.
    """

    app_global_get_ex = AVMOpData(
        op_code="app_global_get_ex",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.application, StackType.state_key],
                returns=[StackType.any, StackType.bool],
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    X is the global state of application A, key B. Y is 1 if key existed, else 0

    params: Txn.ForeignApps offset (or, since v4, an _available_ application id), state key.
    Return: did_exist flag (top of the stack, 1 if the application and key existed and 0
    otherwise), value. The value is zero (of type uint64) if the key does not exist.
    """

    app_global_put = AVMOpData(
        op_code="app_global_put",
        variants=Variant(
            signature=OpSignature(args=[StackType.state_key, StackType.any], returns=[]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    write B to key A in the global state of the current application
    """

    app_local_del = AVMOpData(
        op_code="app_local_del",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.address_or_index, StackType.state_key], returns=[]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    delete key B from account A's local state of the current application

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key.


    Deleting a key which is already absent has no effect on the application local state. (In
    particular, it does _not_ cause the program to fail.)
    """

    app_local_get = AVMOpData(
        op_code="app_local_get",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.address_or_index, StackType.state_key], returns=[StackType.any]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    local state of the key B in the current application in account A

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key. Return:
    value. The value is zero (of type uint64) if the key does not exist.
    """

    app_local_get_ex = AVMOpData(
        op_code="app_local_get_ex",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.address_or_index, StackType.application, StackType.state_key],
                returns=[StackType.any, StackType.bool],
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    X is the local state of application B, key C in account A. Y is 1 if key existed, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset), state key. Return: did_exist flag (top
    of the stack, 1 if the application and key existed and 0 otherwise), value. The value is zero
    (of type uint64) if the key does not exist.
    """

    app_local_put = AVMOpData(
        op_code="app_local_put",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.address_or_index, StackType.state_key, StackType.any], returns=[]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    write C to key B in account A's local state of the current application

    params: Txn.Accounts offset (or, since v4, an _available_ account address), state key, value.
    """

    app_opted_in = AVMOpData(
        op_code="app_opted_in",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.address_or_index, StackType.application], returns=[StackType.bool]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    1 if account A is opted in to application B, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset). Return: 1 if opted in and 0 otherwise.
    """

    app_params_get = AVMOpData(
        op_code="app_params_get",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "AppApprovalProgram": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppClearStateProgram": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppGlobalNumUint": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppGlobalNumByteSlice": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppLocalNumUint": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppLocalNumByteSlice": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppExtraProgramPages": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppCreator": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AppAddress": Variant(
                    signature=OpSignature(
                        args=[StackType.application], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    X is field F from app A. Y is 1 if A exists, else 0

    params: Txn.ForeignApps offset or an _available_ app id. Return: did_exist flag (1 if the
    application existed and 0 otherwise), value.
    """

    arg = AVMOpData(
        op_code="arg",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.bytes]), supported_modes=RunMode.lsig
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.lsig,
    )
    """
    Nth LogicSig argument
    """

    arg_0 = AVMOpData(
        op_code="arg_0",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.bytes]), supported_modes=RunMode.lsig
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.lsig,
    )
    """
    LogicSig argument 0
    """

    arg_1 = AVMOpData(
        op_code="arg_1",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.bytes]), supported_modes=RunMode.lsig
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.lsig,
    )
    """
    LogicSig argument 1
    """

    arg_2 = AVMOpData(
        op_code="arg_2",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.bytes]), supported_modes=RunMode.lsig
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.lsig,
    )
    """
    LogicSig argument 2
    """

    arg_3 = AVMOpData(
        op_code="arg_3",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.bytes]), supported_modes=RunMode.lsig
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.lsig,
    )
    """
    LogicSig argument 3
    """

    args = AVMOpData(
        op_code="args",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
            supported_modes=RunMode.lsig,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.lsig,
    )
    """
    Ath LogicSig argument
    """

    assert_ = AVMOpData(
        op_code="assert",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[]), supported_modes=RunMode.any
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    immediately fail unless A is a non-zero number
    """

    asset_holding_get = AVMOpData(
        op_code="asset_holding_get",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "AssetBalance": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index, StackType.asset],
                        returns=[StackType.uint64, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetFrozen": Variant(
                    signature=OpSignature(
                        args=[StackType.address_or_index, StackType.asset],
                        returns=[StackType.bool, StackType.bool],
                    ),
                    supported_modes=RunMode.app,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    X is field F from account A's holding of asset B. Y is 1 if A is opted into B, else 0

    params: Txn.Accounts offset (or, since v4, an _available_ address), asset id (or, since v4, a
    Txn.ForeignAssets offset). Return: did_exist flag (1 if the asset existed and 0 otherwise),
    value.
    """

    asset_params_get = AVMOpData(
        op_code="asset_params_get",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "AssetTotal": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetDecimals": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.uint64, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetDefaultFrozen": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.bool, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetUnitName": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetName": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetURL": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetMetadataHash": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.bytes, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetManager": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetReserve": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetFreeze": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetClawback": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
                "AssetCreator": Variant(
                    signature=OpSignature(
                        args=[StackType.asset], returns=[StackType.address, StackType.bool]
                    ),
                    supported_modes=RunMode.app,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    X is field F from asset A. Y is 1 if A exists, else 0

    params: Txn.ForeignAssets offset (or, since v4, an _available_ asset id. Return: did_exist flag
    (1 if the asset existed and 0 otherwise), value.
    """

    balance = AVMOpData(
        op_code="balance",
        variants=Variant(
            signature=OpSignature(args=[StackType.address_or_index], returns=[StackType.uint64]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.app,
    )
    """
    balance for account A, in microalgos. The balance is observed after the effects of previous
    transactions in the group, and after the fee for the current transaction is deducted. Changes
    caused by inner transactions are observable immediately following `itxn_submit`

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset). Return: value.
    """

    base64_decode = AVMOpData(
        op_code="base64_decode",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    decode A which was base64-encoded using _encoding_ E. Fail if A is not base64 encoded with
    encoding E

    *Warning*: Usage should be restricted to very rare use cases. In almost all cases, smart
    contracts should directly handle non-encoded byte-strings.     This opcode should only be used
    in cases where base64 is the only available option, e.g. interoperability with a third-party
    that only signs base64 strings.


     Decodes A using the base64 encoding E. Specify the encoding with an immediate arg either as
    URL and Filename Safe (`URLEncoding`) or Standard (`StdEncoding`). See [RFC 4648 sections 4 and
    5](https://rfc-editor.org/rfc/rfc4648.html#section-4). It is assumed that the encoding ends
    with the exact number of `=` padding characters as required by the RFC. When padding occurs,
    any unused pad bits in the encoding must be set to zero or the decoding will fail. The special
    cases of `\n` and `\r` are allowed but completely ignored. An error will result when attempting
    to decode a string with a character that is not in the encoding alphabet or not one of `=`,
    `\r`, or `\n`.
    """

    bitlen = AVMOpData(
        op_code="bitlen",
        variants=Variant(
            signature=OpSignature(args=[StackType.any], returns=[StackType.uint64]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned
    integer. bitlen of 0 is 0, bitlen of 8 is 4

    bitlen interprets arrays as big-endian integers, unlike setbit/getbit
    """

    bitwise_and = AVMOpData(
        op_code="&",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-and B
    """

    bitwise_and_bytes = AVMOpData(
        op_code="b&",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=6,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-and B. A and B are zero-left extended to the greater of their lengths
    """

    bitwise_not = AVMOpData(
        op_code="~",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    bitwise invert value A
    """

    bitwise_not_bytes = AVMOpData(
        op_code="b~",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=4,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A with all bits inverted
    """

    bitwise_or = AVMOpData(
        op_code="|",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-or B
    """

    bitwise_or_bytes = AVMOpData(
        op_code="b|",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=6,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-or B. A and B are zero-left extended to the greater of their lengths
    """

    bitwise_xor = AVMOpData(
        op_code="^",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-xor B
    """

    bitwise_xor_bytes = AVMOpData(
        op_code="b^",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=6,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A bitwise-xor B. A and B are zero-left extended to the greater of their lengths
    """

    block = AVMOpData(
        op_code="block",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "BlkSeed": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "BlkTimestamp": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    field F of block A. Fail unless A falls between txn.LastValid-1002 and txn.FirstValid
    (exclusive)
    """

    box_create = AVMOpData(
        op_code="box_create",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    create a box named A, of length B. Fail if the name A is empty or B exceeds 32,768. Returns 0
    if A already existed, else 1

    Newly created boxes are filled with 0 bytes. `box_create` will fail if the referenced box
    already exists with a different size. Otherwise, existing boxes are unchanged by `box_create`.
    """

    box_del = AVMOpData(
        op_code="box_del",
        variants=Variant(
            signature=OpSignature(args=[StackType.box_name], returns=[StackType.bool]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    delete box named A if it exists. Return 1 if A existed, 0 otherwise
    """

    box_extract = AVMOpData(
        op_code="box_extract",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name, StackType.uint64, StackType.uint64],
                returns=[StackType.bytes],
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    read C bytes from box A, starting at offset B. Fail if A does not exist, or the byte range is
    outside A's size.
    """

    box_get = AVMOpData(
        op_code="box_get",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name], returns=[StackType.bytes, StackType.bool]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    X is the contents of box A if A exists, else ''. Y is 1 if A exists, else 0.

    For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
    """

    box_len = AVMOpData(
        op_code="box_len",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name], returns=[StackType.uint64, StackType.bool]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    X is the length of box A if A exists, else 0. Y is 1 if A exists, else 0.
    """

    box_put = AVMOpData(
        op_code="box_put",
        variants=Variant(
            signature=OpSignature(args=[StackType.box_name, StackType.bytes], returns=[]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    replaces the contents of box A with byte-array B. Fails if A exists and len(B) != len(box A).
    Creates A if it does not exist

    For boxes that exceed 4,096 bytes, consider `box_create`, `box_extract`, and `box_replace`
    """

    box_replace = AVMOpData(
        op_code="box_replace",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name, StackType.uint64, StackType.bytes], returns=[]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=8,
        supported_modes=RunMode.app,
    )
    """
    write byte-array C into box A, starting at offset B. Fail if A does not exist, or the byte
    range is outside A's size.
    """

    box_resize = AVMOpData(
        op_code="box_resize",
        variants=Variant(
            signature=OpSignature(args=[StackType.box_name, StackType.uint64], returns=[]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=10,
        supported_modes=RunMode.app,
    )
    """
    change the size of box named A to be of length B, adding zero bytes to end or removing bytes
    from the end, as needed. Fail if the name A is empty, A is not an existing box, or B exceeds
    32,768.
    """

    box_splice = AVMOpData(
        op_code="box_splice",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.box_name, StackType.uint64, StackType.uint64, StackType.bytes],
                returns=[],
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=10,
        supported_modes=RunMode.app,
    )
    """
    set box A to contain its previous bytes up to index B, followed by D, followed by the original
    bytes of A that began at index B+C.

    Boxes are of constant length. If C < len(D), then len(D)-C bytes will be removed from the end.
    If C > len(D), zero bytes will be appended to the end to reach the box length.
    """

    bsqrt = AVMOpData(
        op_code="bsqrt",
        variants=Variant(
            signature=OpSignature(args=[StackType.bigint], returns=[StackType.bigint]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=40,
        min_avm_version=6,
        supported_modes=RunMode.any,
    )
    """
    The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned
    integers
    """

    btoi = AVMOpData(
        op_code="btoi",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.uint64]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    converts big-endian byte array A to uint64. Fails if len(A) > 8. Padded by leading 0s if len(A)
    < 8.

    `btoi` fails if the input is longer than 8 bytes.
    """

    bzero = AVMOpData(
        op_code="bzero",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    zero filled byte-array of length A
    """

    concat = AVMOpData(
        op_code="concat",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    join A and B

    `concat` fails if the result would be greater than 4096 bytes.
    """

    div_floor = AVMOpData(
        op_code="/",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A divided by B (truncated division). Fail if B == 0.

    `divmodw` is available to divide the two-element values produced by `mulw` and `addw`.
    """

    div_floor_bytes = AVMOpData(
        op_code="b/",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bigint]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=20,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A divided by B (truncated division). A and B are interpreted as big-endian unsigned integers.
    Fail if B is zero.
    """

    divmodw = AVMOpData(
        op_code="divmodw",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64, StackType.uint64, StackType.uint64],
                returns=[StackType.uint64, StackType.uint64, StackType.uint64, StackType.uint64],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=20,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)

    The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value,
    with J as the high uint64 and K the low.
    """

    divw = AVMOpData(
        op_code="divw",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64, StackType.uint64],
                returns=[StackType.uint64],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.any,
    )
    """
    A,B / C. Fail if C == 0 or if result overflows.

    The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high
    uint64 and B the low.
    """

    ec_add = AVMOpData(
        op_code="ec_add",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    for curve points A and B, return the curve point A + B

    A and B are curve points in affine representation: field element X concatenated with field
    element Y. Field element `Z` is encoded as follows.

    For the base field elements (Fp), `Z` is encoded as a big-endian number and must be lower than
    the field modulus.

    For the quadratic field extension (Fp2), `Z` is encoded as the concatenation of the individual
    encoding of the coefficients. For an Fp2 element of the form `Z = Z0 + Z1 i`, where `i` is a
    formal quadratic non-residue, the encoding of Z is the concatenation of the encoding of `Z0`
    and `Z1` in this order. (`Z0` and `Z1` must be less than the field modulus).


    The point at infinity is encoded as `(X,Y) = (0,0)`.

    Groups G1 and G2 are denoted additively.


    Fails if A or B is not in G.

    A and/or B are allowed to be the point at infinity.

    Does _not_ check if A and B are in the main prime-order subgroup.
    """

    ec_map_to = AVMOpData(
        op_code="ec_map_to",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    maps field element A to group G

    BN254 points are mapped by the SVDW map. BLS12-381 points are mapped by the SSWU map.

    G1 element inputs are base field elements and G2 element inputs are quadratic field elements,
    with nearly the same encoding rules (for field elements) as defined in `ec_add`. There is one
    difference of encoding rule: G1 element inputs do not need to be 0-padded if they fit in less
    than 32 bytes for BN254 and less than 48 bytes for BLS12-381. (As usual, the empty byte array
    represents 0.) G2 elements inputs need to be always have the required size.
    """

    ec_multi_scalar_mul = AVMOpData(
        op_code="ec_multi_scalar_mul",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    for curve points A and scalars B, return curve point B0A0 + B1A1 + B2A2 + ... + BnAn

    A is a list of concatenated points, encoded and checked as described in `ec_add`. B is a list
    of concatenated scalars which, unlike ec_scalar_mul, must all be exactly 32 bytes long.

    The name `ec_multi_scalar_mul` was chosen to reflect common usage, but a more consistent name
    would be `ec_multi_scalar_mul`. AVM values are limited to 4096 bytes, so `ec_multi_scalar_mul`
    is limited by the size of the points in the group being operated upon.
    """

    ec_pairing_check = AVMOpData(
        op_code="ec_pairing_check",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    1 if the product of the pairing of each point in A with its respective point in B is equal to
    the identity element of the target group Gt, else 0

    A and B are concatenated points, encoded and checked as described in `ec_add`. A contains
    points of the group G, B contains points of the associated group (G2 if G is G1, and vice
    versa). Fails if A and B have a different number of points, or if any point is not in its
    described group or outside the main prime-order subgroup - a stronger condition than other
    opcodes. AVM values are limited to 4096 bytes, so `ec_pairing_check` is limited by the size of
    the points in the groups being operated upon.
    """

    ec_scalar_mul = AVMOpData(
        op_code="ec_scalar_mul",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    for curve point A and scalar B, return the curve point BA, the point A multiplied by the scalar
    B.

    A is a curve point encoded and checked as described in `ec_add`. Scalar B is interpreted as a
    big-endian unsigned integer. Fails if B exceeds 32 bytes.
    """

    ec_subgroup_check = AVMOpData(
        op_code="ec_subgroup_check",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bool]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=10,
        supported_modes=RunMode.any,
    )
    """
    1 if A is in the main prime-order subgroup of G (including the point at infinity) else 0.
    Program fails if A is not in G at all.
    """

    ecdsa_pk_decompress = AVMOpData(
        op_code="ecdsa_pk_decompress",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes], returns=[StackType.bytes, StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    decompress pubkey A into components X, Y

    The 33 byte public key in a compressed form to be decompressed into X and Y (top) components.
    All values are big-endian encoded.
    """

    ecdsa_pk_recover = AVMOpData(
        op_code="ecdsa_pk_recover",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64, StackType.bytes, StackType.bytes],
                returns=[StackType.bytes, StackType.bytes],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=2000,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    for (data A, recovery id B, signature C, D) recover a public key

    S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack
    and used to deriver a public key. All values are big-endian encoded. The signed data must be 32
    bytes long.
    """

    ecdsa_verify = AVMOpData(
        op_code="ecdsa_verify",
        variants=Variant(
            signature=OpSignature(
                args=[
                    StackType.bytes,
                    StackType.bytes,
                    StackType.bytes,
                    StackType.bytes,
                    StackType.bytes,
                ],
                returns=[StackType.bool],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    for (data A, signature B, C and pubkey D, E) verify the signature of the data against the
    pubkey => {0 or 1}

    The 32 byte Y-component of a public key is the last element on the stack, preceded by
    X-component of a pubkey, preceded by S and R components of a signature, preceded by the data
    that is fifth element on the stack. All values are big-endian encoded. The signed data must be
    32 bytes long, and signatures in lower-S form are only accepted.
    """

    ed25519verify = AVMOpData(
        op_code="ed25519verify",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes, StackType.bytes], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1900,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash ||
    data) against the pubkey => {0 or 1}

    The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at
    the second-to-last element on the stack, preceded by the data which was signed at the third-to-
    last element on the stack.
    """

    ed25519verify_bare = AVMOpData(
        op_code="ed25519verify_bare",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes, StackType.bytes], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1900,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    for (data A, signature B, pubkey C) verify the signature of the data against the pubkey => {0
    or 1}
    """

    eq = AVMOpData(
        op_code="==",
        variants=Variant(
            signature=OpSignature(args=[StackType.any, StackType.any], returns=[StackType.bool]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A is equal to B => {0 or 1}
    """

    eq_bytes = AVMOpData(
        op_code="b==",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    1 if A is equal to B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    exp = AVMOpData(
        op_code="exp",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A raised to the Bth power. Fail if A == B == 0 and on overflow
    """

    expw = AVMOpData(
        op_code="expw",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64],
                returns=[StackType.uint64, StackType.uint64],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=10,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the
    low. Fail if A == B == 0 or if the results exceeds 2^128-1
    """

    extract = AVMOpData(
        op_code="extract",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    A range of bytes from A starting at S up to but not including S+L. If L is 0, then extract to
    the end of the string. If S or S+L is larger than the array length, the program fails
    """

    extract3 = AVMOpData(
        op_code="extract3",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64, StackType.uint64],
                returns=[StackType.bytes],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the
    array length, the program fails

    `extract3` can be called using `extract` with no immediates.
    """

    extract_uint16 = AVMOpData(
        op_code="extract_uint16",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    A uint16 formed from a range of big-endian bytes from A starting at B up to but not including
    B+2. If B+2 is larger than the array length, the program fails
    """

    extract_uint32 = AVMOpData(
        op_code="extract_uint32",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    A uint32 formed from a range of big-endian bytes from A starting at B up to but not including
    B+4. If B+4 is larger than the array length, the program fails
    """

    extract_uint64 = AVMOpData(
        op_code="extract_uint64",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    A uint64 formed from a range of big-endian bytes from A starting at B up to but not including
    B+8. If B+8 is larger than the array length, the program fails
    """

    gaid = AVMOpData(
        op_code="gaid",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.application]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.app,
    )
    """
    ID of the asset or application created in the Tth transaction of the current group

    `gaid` fails unless the requested transaction created an asset or application and T <
    GroupIndex.
    """

    gaids = AVMOpData(
        op_code="gaids",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.application]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.app,
    )
    """
    ID of the asset or application created in the Ath transaction of the current group

    `gaids` fails unless the requested transaction created an asset or application and A <
    GroupIndex.
    """

    getbit = AVMOpData(
        op_code="getbit",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.any, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    Bth bit of (byte-array or integer) A. If B is greater than or equal to the bit length of the
    value (8*byte length), the program fails

    see explanation of bit ordering in setbit
    """

    getbyte = AVMOpData(
        op_code="getbyte",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    Bth byte of A, as an integer. If B is greater than or equal to the array length, the program
    fails
    """

    gitxn = AVMOpData(
        op_code="gitxn",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValidTime": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LastValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Lease": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupIndex": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "TxID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumAppArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "NumAccounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumAssets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumApplications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "NumLogs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CreatedAssetID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.app,
                ),
                "CreatedApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.app,
                ),
                "LastLog": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    field F of the Tth transaction in the last inner group submitted
    """

    gitxna = AVMOpData(
        op_code="gitxna",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    Ith value of the array field F from the Tth transaction in the last inner group submitted
    """

    gitxnas = AVMOpData(
        op_code="gitxnas",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    Ath value of the array field F from the Tth transaction in the last inner group submitted
    """

    gload = AVMOpData(
        op_code="gload",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.any]), supported_modes=RunMode.app
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.app,
    )
    """
    Ith scratch space value of the Tth transaction in the current group

    `gload` fails unless the requested transaction is an ApplicationCall and T < GroupIndex.
    """

    gloads = AVMOpData(
        op_code="gloads",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.any]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.app,
    )
    """
    Ith scratch space value of the Ath transaction in the current group

    `gloads` fails unless the requested transaction is an ApplicationCall and A < GroupIndex.
    """

    gloadss = AVMOpData(
        op_code="gloadss",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.any]
            ),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    Bth scratch space value of the Ath transaction in the current group
    """

    global_ = AVMOpData(
        op_code="global",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "MinTxnFee": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "MinBalance": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "MaxTxnLife": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ZeroAddress": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupSize": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LogicSigVersion": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Round": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "LatestTimestamp": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CurrentApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.app,
                ),
                "CreatorAddress": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.app,
                ),
                "CurrentApplicationAddress": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.app,
                ),
                "GroupID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "OpcodeBudget": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CallerApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CallerApplicationAddress": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.app,
                ),
                "AssetCreateMinBalance": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetOptInMinBalance": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GenesisHash": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    global field F
    """

    gt = AVMOpData(
        op_code=">",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A greater than B => {0 or 1}
    """

    gt_bytes = AVMOpData(
        op_code="b>",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    1 if A is greater than B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    gte = AVMOpData(
        op_code=">=",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A greater than or equal to B => {0 or 1}
    """

    gte_bytes = AVMOpData(
        op_code="b>=",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    1 if A is greater than or equal to B, else 0. A and B are interpreted as big-endian unsigned
    integers
    """

    gtxn = AVMOpData(
        op_code="gtxn",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValidTime": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LastValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Lease": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupIndex": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "TxID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumAppArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "NumAccounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumAssets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumApplications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "NumLogs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CreatedAssetID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.app,
                ),
                "CreatedApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.app,
                ),
                "LastLog": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    field F of the Tth transaction in the current group

    for notes on transaction fields available, see `txn`. If this transaction is _i_ in the group,
    `gtxn i field` is equivalent to `txn field`.
    """

    gtxna = AVMOpData(
        op_code="gtxna",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    Ith value of the array field F from the Tth transaction in the current group

    `gtxna` can be called using `gtxn` with 3 immediates.
    """

    gtxnas = AVMOpData(
        op_code="gtxnas",
        variants=DynamicVariants(
            immediate_index=1,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.arg_enum),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    Ath value of the array field F from the Tth transaction in the current group
    """

    gtxns = AVMOpData(
        op_code="gtxns",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValid": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValidTime": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LastValid": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Lease": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupIndex": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "TxID": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumAppArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "NumAccounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumAssets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumApplications": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "NumLogs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CreatedAssetID": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.app,
                ),
                "CreatedApplicationID": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.app,
                ),
                "LastLog": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    field F of the Ath transaction in the current group

    for notes on transaction fields available, see `txn`. If top of stack is _i_, `gtxns field` is
    equivalent to `gtxn _i_ field`. gtxns exists so that _i_ can be calculated, often based on the
    index of the current transaction.
    """

    gtxnsa = AVMOpData(
        op_code="gtxnsa",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    Ith value of the array field F from the Ath transaction in the current group

    `gtxnsa` can be called using `gtxns` with 2 immediates.
    """

    gtxnsas = AVMOpData(
        op_code="gtxnsas",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.address]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.asset]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64, StackType.uint64], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    Bth value of the array field F from the Ath transaction in the current group
    """

    itob = AVMOpData(
        op_code="itob",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    converts uint64 A to big-endian byte array, always of length 8
    """

    itxn = AVMOpData(
        op_code="itxn",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValidTime": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LastValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Lease": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupIndex": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "TxID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumAppArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "NumAccounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumAssets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumApplications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "NumLogs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CreatedAssetID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.app,
                ),
                "CreatedApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.app,
                ),
                "LastLog": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    field F of the last inner transaction
    """

    itxn_begin = AVMOpData(
        op_code="itxn_begin",
        variants=Variant(signature=OpSignature(args=[], returns=[]), supported_modes=RunMode.app),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    begin preparation of a new inner transaction in a new transaction group

    `itxn_begin` initializes Sender to the application address; Fee to the minimum allowable,
    taking into account MinTxnFee and credit from overpaying in earlier transactions;
    FirstValid/LastValid to the values in the invoking transaction, and all other fields to zero or
    empty values.
    """

    itxn_field = AVMOpData(
        op_code="itxn_field",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[StackType.asset], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(args=[StackType.application], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[StackType.asset], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[StackType.bool], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[StackType.asset], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[StackType.address], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[StackType.bool], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[StackType.bool], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.bytes], returns=[]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    set field F of the current inner transaction to A

    `itxn_field` fails if A is of the wrong type for F, including a byte array of the wrong size
    for use as an address when F is an address field. `itxn_field` also fails if A is an account,
    asset, or app that is not _available_, or an attempt is made extend an array field beyond the
    limit imposed by consensus parameters. (Addresses set into asset params of acfg transactions
    need not be _available_.)
    """

    itxn_next = AVMOpData(
        op_code="itxn_next",
        variants=Variant(signature=OpSignature(args=[], returns=[]), supported_modes=RunMode.app),
        immediate_types=(),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    begin preparation of a new inner transaction in the same transaction group

    `itxn_next` initializes the transaction exactly as `itxn_begin` does
    """

    itxn_submit = AVMOpData(
        op_code="itxn_submit",
        variants=Variant(signature=OpSignature(args=[], returns=[]), supported_modes=RunMode.app),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    execute the current inner transaction group. Fail if executing this group would exceed the
    inner transaction limit, or if any transaction in the group fails.

    `itxn_submit` resets the current transaction so that it can not be resubmitted. A new
    `itxn_begin` is required to prepare another inner transaction.
    """

    itxna = AVMOpData(
        op_code="itxna",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    Ith value of the array field F of the last inner transaction
    """

    itxnas = AVMOpData(
        op_code="itxnas",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=6,
        supported_modes=RunMode.app,
    )
    """
    Ath value of the array field F of the last inner transaction
    """

    json_ref = AVMOpData(
        op_code="json_ref",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "JSONString": Variant(
                    signature=OpSignature(
                        args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.any,
                ),
                "JSONUint64": Variant(
                    signature=OpSignature(
                        args=[StackType.bytes, StackType.bytes], returns=[StackType.uint64]
                    ),
                    supported_modes=RunMode.any,
                ),
                "JSONObject": Variant(
                    signature=OpSignature(
                        args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
                    ),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=None,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    key B's value, of type R, from a [valid](jsonspec.md) utf-8 encoded json object A

    *Warning*: Usage should be restricted to very rare use cases, as JSON decoding is expensive and
    quite limited. In addition, JSON objects are large and not optimized for size.


    Almost all smart contracts should use simpler and smaller methods (such as the
    [ABI](https://arc.algorand.foundation/ARCs/arc-0004). This opcode should only be used in cases
    where JSON is only available option, e.g. when a third-party only signs JSON.
    """

    keccak256 = AVMOpData(
        op_code="keccak256",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=130,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    Keccak256 hash of value A, yields [32]byte
    """

    len_ = AVMOpData(
        op_code="len",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.uint64]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    yields length of byte value A
    """

    load = AVMOpData(
        op_code="load",
        variants=Variant(
            signature=OpSignature(args=[], returns=[StackType.any]), supported_modes=RunMode.any
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    Ith scratch space value. All scratch spaces are 0 at program start.
    """

    loads = AVMOpData(
        op_code="loads",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.any]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    Ath scratch space value.  All scratch spaces are 0 at program start.
    """

    log = AVMOpData(
        op_code="log",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[]), supported_modes=RunMode.app
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.app,
    )
    """
    write A to log state of the current application

    `log` fails if called more than MaxLogCalls times in a program, or if the sum of logged bytes
    exceeds 1024 bytes.
    """

    lt = AVMOpData(
        op_code="<",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A less than B => {0 or 1}
    """

    lt_bytes = AVMOpData(
        op_code="b<",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    1 if A is less than B, else 0. A and B are interpreted as big-endian unsigned integers
    """

    lte = AVMOpData(
        op_code="<=",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A less than or equal to B => {0 or 1}
    """

    lte_bytes = AVMOpData(
        op_code="b<=",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    1 if A is less than or equal to B, else 0. A and B are interpreted as big-endian unsigned
    integers
    """

    min_balance = AVMOpData(
        op_code="min_balance",
        variants=Variant(
            signature=OpSignature(args=[StackType.address_or_index], returns=[StackType.uint64]),
            supported_modes=RunMode.app,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.app,
    )
    """
    minimum required balance for account A, in microalgos. Required balance is affected by ASA,
    App, and Box usage. When creating or opting into an app, the minimum balance grows before the
    app code runs, therefore the increase is visible there. When deleting or closing out, the
    minimum balance decreases after the app executes. Changes caused by inner transactions or box
    usage are observable immediately following the opcode effecting the change.

    params: Txn.Accounts offset (or, since v4, an _available_ account address), _available_
    application id (or, since v4, a Txn.ForeignApps offset). Return: value.
    """

    mod = AVMOpData(
        op_code="%",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A modulo B. Fail if B == 0.
    """

    mod_bytes = AVMOpData(
        op_code="b%",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bigint]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=20,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A modulo B. A and B are interpreted as big-endian unsigned integers. Fail if B is zero.
    """

    mul = AVMOpData(
        op_code="*",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A times B. Fail on overflow.

    Overflow is an error condition which halts execution and fails the transaction. Full precision
    is available from `mulw`.
    """

    mul_bytes = AVMOpData(
        op_code="b*",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=20,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A times B. A and B are interpreted as big-endian unsigned integers.
    """

    mulw = AVMOpData(
        op_code="mulw",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64],
                returns=[StackType.uint64, StackType.uint64],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low
    """

    neq = AVMOpData(
        op_code="!=",
        variants=Variant(
            signature=OpSignature(args=[StackType.any, StackType.any], returns=[StackType.bool]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A is not equal to B => {0 or 1}
    """

    neq_bytes = AVMOpData(
        op_code="b!=",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    0 if A is equal to B, else 1. A and B are interpreted as big-endian unsigned integers
    """

    not_ = AVMOpData(
        op_code="!",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.bool]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A == 0 yields 1; else 0
    """

    or_ = AVMOpData(
        op_code="||",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.bool]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A is not zero or B is not zero => {0 or 1}
    """

    replace2 = AVMOpData(
        op_code="replace2",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes], returns=[StackType.bytes]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    Copy of A with the bytes starting at S replaced by the bytes of B. Fails if S+len(B) exceeds
    len(A)

    `replace2` can be called using `replace` with 1 immediate.
    """

    replace3 = AVMOpData(
        op_code="replace3",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64, StackType.bytes],
                returns=[StackType.bytes],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    Copy of A with the bytes starting at B replaced by the bytes of C. Fails if B+len(C) exceeds
    len(A)

    `replace3` can be called using `replace` with no immediates.
    """

    select = AVMOpData(
        op_code="select",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.any, StackType.any, StackType.bool], returns=[StackType.any]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    selects one of two values based on top-of-stack: B if C != 0, else A
    """

    setbit = AVMOpData(
        op_code="setbit",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.any, StackType.uint64, StackType.uint64], returns=[StackType.any]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    Copy of (byte-array or integer) A, with the Bth bit set to (0 or 1) C. If B is greater than or
    equal to the bit length of the value (8*byte length), the program fails

    When A is a uint64, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0
    yields 8, or 2^3. When A is a byte array, index 0 is the leftmost bit of the leftmost byte.
    Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000.
    Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.
    """

    setbyte = AVMOpData(
        op_code="setbyte",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64, StackType.uint64],
                returns=[StackType.bytes],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=3,
        supported_modes=RunMode.any,
    )
    """
    Copy of A with the Bth byte set to small integer (between 0..255) C. If B is greater than or
    equal to the array length, the program fails
    """

    sha256 = AVMOpData(
        op_code="sha256",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=35,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    SHA256 hash of value A, yields [32]byte
    """

    sha3_256 = AVMOpData(
        op_code="sha3_256",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=130,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    SHA3_256 hash of value A, yields [32]byte
    """

    sha512_256 = AVMOpData(
        op_code="sha512_256",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=45,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    SHA512_256 hash of value A, yields [32]byte
    """

    shl = AVMOpData(
        op_code="shl",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A times 2^B, modulo 2^64
    """

    shr = AVMOpData(
        op_code="shr",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A divided by 2^B
    """

    sqrt = AVMOpData(
        op_code="sqrt",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64], returns=[StackType.uint64]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=4,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    The largest integer I such that I^2 <= A
    """

    store = AVMOpData(
        op_code="store",
        variants=Variant(
            signature=OpSignature(args=[StackType.any], returns=[]), supported_modes=RunMode.any
        ),
        immediate_types=(ImmediateKind.uint8,),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    store A to the Ith scratch space
    """

    stores = AVMOpData(
        op_code="stores",
        variants=Variant(
            signature=OpSignature(args=[StackType.uint64, StackType.any], returns=[]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    store B to the Ath scratch space
    """

    sub = AVMOpData(
        op_code="-",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.uint64, StackType.uint64], returns=[StackType.uint64]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    A minus B. Fail if B > A.
    """

    sub_bytes = AVMOpData(
        op_code="b-",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bigint, StackType.bigint], returns=[StackType.bigint]
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=10,
        min_avm_version=4,
        supported_modes=RunMode.any,
    )
    """
    A minus B. A and B are interpreted as big-endian unsigned integers. Fail on underflow.
    """

    substring = AVMOpData(
        op_code="substring",
        variants=Variant(
            signature=OpSignature(args=[StackType.bytes], returns=[StackType.bytes]),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.uint8, ImmediateKind.uint8),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    A range of bytes from A starting at S up to but not including E. If E < S, or either is larger
    than the array length, the program fails
    """

    substring3 = AVMOpData(
        op_code="substring3",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.uint64, StackType.uint64],
                returns=[StackType.bytes],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    A range of bytes from A starting at B up to but not including C. If C < B, or either is larger
    than the array length, the program fails
    """

    txn = AVMOpData(
        op_code="txn",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "Sender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Fee": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "FirstValidTime": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LastValid": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Note": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Lease": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Receiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Amount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "CloseRemainderTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "VotePK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "SelectionPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "VoteFirst": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteLast": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "VoteKeyDilution": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Type": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "TypeEnum": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "XferAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "AssetAmount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "AssetSender": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetReceiver": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "AssetCloseTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "GroupIndex": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "TxID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "OnCompletion": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumAppArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "NumAccounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgram": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "RekeyTo": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetTotal": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDecimals": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetDefaultFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetUnitName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetName": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetURL": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetMetadataHash": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetManager": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetReserve": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetFreeze": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "ConfigAssetClawback": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAsset": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetAccount": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "FreezeAssetFrozen": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumAssets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "NumApplications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "GlobalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumUint": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "LocalNumByteSlice": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ExtraProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "Nonparticipation": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bool]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "NumLogs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.app,
                ),
                "CreatedAssetID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.app,
                ),
                "CreatedApplicationID": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.app,
                ),
                "LastLog": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "StateProofPK": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "NumClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.uint64]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=1,
        supported_modes=RunMode.any,
    )
    """
    field F of current transaction
    """

    txna = AVMOpData(
        op_code="txna",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(args=[], returns=[StackType.application]),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum, ImmediateKind.uint8),
        cost=1,
        min_avm_version=2,
        supported_modes=RunMode.any,
    )
    """
    Ith value of the array field F of the current transaction

    `txna` can be called using `txn` with 2 immediates.
    """

    txnas = AVMOpData(
        op_code="txnas",
        variants=DynamicVariants(
            immediate_index=0,
            variant_map={
                "ApplicationArgs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "Accounts": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.address]),
                    supported_modes=RunMode.any,
                ),
                "Assets": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.asset]),
                    supported_modes=RunMode.any,
                ),
                "Applications": Variant(
                    signature=OpSignature(
                        args=[StackType.uint64], returns=[StackType.application]
                    ),
                    supported_modes=RunMode.any,
                ),
                "Logs": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.app,
                ),
                "ApprovalProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
                "ClearStateProgramPages": Variant(
                    signature=OpSignature(args=[StackType.uint64], returns=[StackType.bytes]),
                    supported_modes=RunMode.any,
                ),
            },
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=1,
        min_avm_version=5,
        supported_modes=RunMode.any,
    )
    """
    Ath value of the array field F of the current transaction
    """

    vrf_verify = AVMOpData(
        op_code="vrf_verify",
        variants=Variant(
            signature=OpSignature(
                args=[StackType.bytes, StackType.bytes, StackType.bytes],
                returns=[StackType.bytes, StackType.bool],
            ),
            supported_modes=RunMode.any,
        ),
        immediate_types=(ImmediateKind.arg_enum,),
        cost=5700,
        min_avm_version=7,
        supported_modes=RunMode.any,
    )
    """
    Verify the proof B of message A against pubkey C. Returns vrf output and verification flag.

    `VrfAlgorand` is the VRF used in Algorand. It is ECVRF-ED25519-SHA512-Elligator2, specified in
    the IETF internet draft [draft-irtf-cfrg-vrf-03](https://datatracker.ietf.org/doc/draft-irtf-
    cfrg-vrf/03/).
    """
