from __future__ import annotations

import typing

from puya import log
from puya.awst import wtypes
from puya.awst.nodes import (
    BoolConstant,
    BytesAugmentedAssignment,
    BytesBinaryOperation,
    BytesBinaryOperator,
    BytesComparisonExpression,
    CallArg,
    ConditionalExpression,
    EqualityComparison,
    Expression,
    FreeSubroutineTarget,
    Literal,
    ReinterpretCast,
    SingleEvaluation,
    Statement,
    StringConstant,
    SubroutineCallExpression,
    TupleItemExpression,
    UInt64Constant,
)
from puya.awst_build import intrinsic_factory
from puya.awst_build.eb.base import (
    BuilderBinaryOp,
    BuilderComparisonOp,
    ExpressionBuilder,
    IntermediateExpressionBuilder,
    ValueExpressionBuilder,
)
from puya.awst_build.eb.bytes_backed import BytesBackedClassExpressionBuilder
from puya.awst_build.eb.var_factory import var_expression
from puya.awst_build.utils import convert_literal_to_expr, expect_operand_wtype
from puya.errors import CodeError

if typing.TYPE_CHECKING:
    from collections.abc import Sequence

    import mypy.nodes

    from puya.parse import SourceLocation

logger = log.get_logger(__name__)


class StringClassExpressionBuilder(BytesBackedClassExpressionBuilder):
    def produces(self) -> wtypes.WType:
        return wtypes.string_wtype

    def call(
        self,
        args: Sequence[ExpressionBuilder | Literal],
        arg_kinds: list[mypy.nodes.ArgKind],
        arg_names: list[str | None],
        location: SourceLocation,
    ) -> ExpressionBuilder:
        match args:
            case []:
                value = ""
            case [Literal(value=str(value))]:
                pass
            case _:
                logger.error("Invalid/unhandled arguments", location=location)
                # dummy value to continue with
                value = ""
        str_const = StringConstant(value=value, source_location=location)
        return var_expression(str_const)


class StringExpressionBuilder(ValueExpressionBuilder):
    wtype = wtypes.string_wtype

    def member_access(self, name: str, location: SourceLocation) -> ExpressionBuilder:
        match name:
            case "bytes":
                return _get_bytes_expr_builder(self.expr)
            case "startswith":
                return _StringStartsOrEndsWith(self.expr, location, at_start=True)
            case "endswith":
                return _StringStartsOrEndsWith(self.expr, location, at_start=False)
            case "join":
                return _StringJoin(self.expr, location)
            case _:
                raise CodeError(f"Unrecognised member of {self.wtype}: {name}", location)

    def augmented_assignment(
        self, op: BuilderBinaryOp, rhs: ExpressionBuilder | Literal, location: SourceLocation
    ) -> Statement:
        match op:
            case BuilderBinaryOp.add:
                return BytesAugmentedAssignment(
                    target=self.lvalue(),
                    op=BytesBinaryOperator.add,
                    value=expect_operand_wtype(rhs, self.wtype),
                    source_location=location,
                )
            case _:
                raise CodeError(
                    f"Unsupported augmented assignment operation on {self.wtype}: {op.value}=",
                    location,
                )

    def binary_op(
        self,
        other: ExpressionBuilder | Literal,
        op: BuilderBinaryOp,
        location: SourceLocation,
        *,
        reverse: bool,
    ) -> ExpressionBuilder:
        match op:
            case BuilderBinaryOp.add:
                lhs = self.expr
                rhs = expect_operand_wtype(other, self.wtype)
                if reverse:
                    (lhs, rhs) = (rhs, lhs)
                return var_expression(
                    BytesBinaryOperation(
                        left=lhs,
                        op=BytesBinaryOperator.add,
                        right=rhs,
                        source_location=location,
                    )
                )
            case _:
                return NotImplemented

    def compare(
        self, other: ExpressionBuilder | Literal, op: BuilderComparisonOp, location: SourceLocation
    ) -> ExpressionBuilder:
        other_expr = convert_literal_to_expr(other, self.wtype)
        if other_expr.wtype == self.wtype:
            pass
        else:
            return NotImplemented
        cmp = BytesComparisonExpression(
            source_location=location,
            lhs=self.expr,
            operator=EqualityComparison(op.value),
            rhs=other_expr,
        )
        return var_expression(cmp)

    def bool_eval(self, location: SourceLocation, *, negate: bool = False) -> ExpressionBuilder:
        bytes_expr = _get_bytes_expr(self.expr)
        len_expr = intrinsic_factory.bytes_len(bytes_expr, location)
        len_builder = var_expression(len_expr)
        return len_builder.bool_eval(location, negate=negate)

    def contains(
        self, item: ExpressionBuilder | Literal, location: SourceLocation
    ) -> ExpressionBuilder:
        item_expr = _get_bytes_expr(expect_operand_wtype(item, wtypes.string_wtype))
        this_expr = _get_bytes_expr(self.expr)
        is_substring_expr = SubroutineCallExpression(
            target=FreeSubroutineTarget(module_name="algopy_lib_bytes", name="is_substring"),
            args=[
                CallArg(value=item_expr, name="item"),
                CallArg(value=this_expr, name="sequence"),
            ],
            wtype=wtypes.bool_wtype,
            source_location=location,
        )
        return var_expression(is_substring_expr)


class _StringStartsOrEndsWith(IntermediateExpressionBuilder):
    def __init__(self, base: Expression, location: SourceLocation, *, at_start: bool):
        super().__init__(location)
        self._base = base
        self._at_start = at_start

    def call(
        self,
        args: Sequence[ExpressionBuilder | Literal],
        arg_kinds: list[mypy.nodes.ArgKind],
        arg_names: list[str | None],
        location: SourceLocation,
    ) -> ExpressionBuilder:
        if len(args) != 1:
            raise CodeError(f"Expected 1 argument, got {len(args)}", location)
        arg = _get_bytes_expr_builder(
            SingleEvaluation(expect_operand_wtype(args[0], wtypes.string_wtype))
        )
        this = _get_bytes_expr_builder(SingleEvaluation(self._base))

        this_length = this.member_access("length", location)
        assert isinstance(this_length, ExpressionBuilder)
        arg_length = arg.member_access("length", location)
        assert isinstance(arg_length, ExpressionBuilder)

        arg_length_gt_this_length = arg_length.compare(
            this_length, op=BuilderComparisonOp.gt, location=location
        )

        if self._at_start:
            extracted = intrinsic_factory.extract3(
                this.rvalue(),
                start=UInt64Constant(source_location=location, value=0),
                length=arg_length.rvalue(),
            )
        else:
            extracted = intrinsic_factory.extract3(
                this.rvalue(),
                start=this_length.binary_op(
                    arg_length, BuilderBinaryOp.sub, location, reverse=False
                ).rvalue(),
                length=arg_length.rvalue(),
            )
        this_substr = var_expression(extracted)

        cond = ConditionalExpression(
            condition=arg_length_gt_this_length.rvalue(),
            true_expr=BoolConstant(location, value=False),
            false_expr=this_substr.compare(arg, BuilderComparisonOp.eq, location).rvalue(),
            wtype=wtypes.bool_wtype,
            source_location=location,
        )
        return var_expression(cond)


class _StringJoin(IntermediateExpressionBuilder):
    def __init__(self, base: Expression, location: SourceLocation):
        super().__init__(location)
        self._base = base

    def call(
        self,
        args: Sequence[ExpressionBuilder | Literal],
        arg_kinds: list[mypy.nodes.ArgKind],
        arg_names: list[str | None],
        location: SourceLocation,
    ) -> ExpressionBuilder:
        match args:
            case [
                ExpressionBuilder(value_type=wtypes.WTuple(types=tuple_item_types)) as eb
            ] if all(tt == wtypes.string_wtype for tt in tuple_item_types):
                tuple_arg = SingleEvaluation(eb.rvalue())
            case _:
                raise CodeError("Invalid/unhandled arguments", location)
        sep = _get_bytes_expr_builder(SingleEvaluation(self._base))
        joined_value: Expression | None = None
        for idx, _ in enumerate(tuple_item_types):
            item_expr = TupleItemExpression(tuple_arg, index=idx, source_location=location)
            bytes_expr = _get_bytes_expr(item_expr)
            if joined_value is None:
                joined_value = bytes_expr
            else:
                joined_value = intrinsic_factory.concat(
                    intrinsic_factory.concat(joined_value, sep.rvalue(), location),
                    bytes_expr,
                    location,
                )
        if joined_value is None:
            joined_value = StringConstant(value="", source_location=location)
        return StringExpressionBuilder(
            ReinterpretCast(expr=joined_value, wtype=wtypes.string_wtype, source_location=location)
        )


def _get_bytes_expr(expr: Expression) -> ReinterpretCast:
    return ReinterpretCast(
        expr=expr, wtype=wtypes.bytes_wtype, source_location=expr.source_location
    )


def _get_bytes_expr_builder(expr: Expression) -> ExpressionBuilder:
    return var_expression(_get_bytes_expr(expr))
