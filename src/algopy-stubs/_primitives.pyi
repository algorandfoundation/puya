# ruff: noqa: PYI034
import typing as t

class UInt64:
    # ~~~ https://docs.python.org/3/reference/datamodel.html#basic-customization ~~~
    def __init__(self, value: int, /) -> None: ...
    # ==
    # TODO: mypy suggests due to Liskov below should be other: object
    #       need to consider ramifications here, ignoring it for now
    def __eq__(self, other: UInt64 | int) -> bool: ...  # type: ignore[override]
    # !=
    def __ne__(self, other: UInt64 | int) -> bool: ...  # type: ignore[override]
    # <=
    def __le__(self, other: UInt64 | int) -> bool: ...
    # <
    def __lt__(self, other: UInt64 | int) -> bool: ...
    # >=
    def __ge__(self, other: UInt64 | int) -> bool: ...
    # >
    def __gt__(self, other: UInt64 | int) -> bool: ...
    # truthiness
    def __bool__(self) -> bool: ...

    # ~~~ https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types ~~~
    # +
    def __add__(self, other: UInt64 | int) -> UInt64: ...
    def __radd__(self, other: UInt64 | int) -> UInt64: ...
    def __iadd__(self, other: UInt64 | int) -> UInt64: ...
    # -
    def __sub__(self, other: UInt64 | int) -> UInt64: ...
    def __rsub__(self, other: UInt64 | int) -> UInt64: ...
    def __isub__(self, other: UInt64 | int) -> UInt64: ...
    # *
    def __mul__(self, other: UInt64 | int) -> UInt64: ...
    def __rmul__(self, other: UInt64 | int) -> UInt64: ...
    def __imul__(self, other: UInt64 | int) -> UInt64: ...
    # //
    def __floordiv__(self, other: UInt64 | int) -> UInt64: ...
    def __rfloordiv__(self, other: UInt64 | int) -> UInt64: ...
    def __ifloordiv__(self, other: UInt64 | int) -> UInt64: ...
    # %
    def __mod__(self, other: UInt64 | int) -> UInt64: ...
    def __rmod__(self, other: UInt64 | int) -> UInt64: ...
    def __imod__(self, other: UInt64 | int) -> UInt64: ...
    # TODO: __divmod__? only supported as single op via divmodw though ðŸ¤”
    # **, pow
    def __pow__(self, power: UInt64 | int) -> UInt64: ...
    def __rpow__(self, power: UInt64 | int) -> UInt64: ...
    def __ipow__(self, power: UInt64 | int) -> UInt64: ...
    # <<
    def __lshift__(self, other: UInt64 | int) -> UInt64: ...
    def __rlshift__(self, other: UInt64 | int) -> UInt64: ...
    def __ilshift__(self, other: UInt64 | int) -> UInt64: ...
    # >>
    def __rshift__(self, other: UInt64 | int) -> UInt64: ...
    def __rrshift__(self, other: UInt64 | int) -> UInt64: ...
    def __irshift__(self, other: UInt64 | int) -> UInt64: ...
    # &
    def __and__(self, other: UInt64 | int) -> UInt64: ...
    def __rand__(self, other: UInt64 | int) -> UInt64: ...
    def __iand__(self, other: UInt64 | int) -> UInt64: ...
    # ^
    def __xor__(self, other: UInt64 | int) -> UInt64: ...
    def __rxor__(self, other: UInt64 | int) -> UInt64: ...
    def __ixor__(self, other: UInt64 | int) -> UInt64: ...
    # |
    def __or__(self, other: UInt64 | int) -> UInt64: ...
    def __ror__(self, other: UInt64 | int) -> UInt64: ...
    def __ior__(self, other: UInt64 | int) -> UInt64: ...
    # ~
    def __invert__(self) -> UInt64: ...
    # used to turn this into an index e.g. to a list

class Bytes(t.Iterable[Bytes]):
    @t.overload
    def __init__(self) -> None: ...
    @t.overload
    def __init__(self, value: bytes, /): ...
    @staticmethod
    def from_base32(value: t.LiteralString, /) -> Bytes: ...
    @staticmethod
    def from_base64(value: t.LiteralString, /) -> Bytes: ...
    @staticmethod
    def from_hex(value: t.LiteralString, /) -> Bytes: ...
    def __add__(self, other: Bytes | bytes) -> Bytes: ...
    def __radd__(self, other: Bytes | bytes) -> Bytes: ...
    def __iadd__(self, other: Bytes | bytes) -> Bytes: ...
    # NOTE: __len__ is enforced to return int at runtime (not even a subtype is allowed)
    @property
    def length(self) -> UInt64: ...
    # truthiness
    def __bool__(self) -> bool: ...  # returns True iff length() > 0
    def __getitem__(
        self, index: UInt64 | int | slice
    ) -> Bytes: ...  # maps to substring/substring3 if slice, extract/extract3 otherwise?
    def __iter__(self) -> t.Iterator[Bytes]: ...
    # mypy suggests due to Liskov below should be other: object
    # need to consider ramifications here, ignoring it for now
    def __eq__(self, other: Bytes | bytes) -> bool: ...  # type: ignore[override]
    def __ne__(self, other: Bytes | bytes) -> bool: ...  # type: ignore[override]
    # bitwise operators
    # &
    def __and__(self, other: Bytes | bytes) -> Bytes: ...
    def __iand__(self, other: Bytes | bytes) -> Bytes: ...
    # ^
    def __xor__(self, other: Bytes | bytes) -> Bytes: ...
    def __ixor__(self, other: Bytes | bytes) -> Bytes: ...
    # |
    def __or__(self, other: Bytes | bytes) -> Bytes: ...
    def __ior__(self, other: Bytes | bytes) -> Bytes: ...
    # ~
    def __invert__(self) -> Bytes: ...

class BigUInt:
    # TODO: consider how to handle cases where sizes exceeds 512, which can happen on + or *,
    #       but the result is no longer usable with any further ops.
    # ~~~ https://docs.python.org/3/reference/datamodel.html#basic-customization ~~~
    def __init__(self, value: UInt64 | int, /) -> None: ...
    # ==
    # TODO: mypy suggests due to Liskov below should be other: object
    #       need to consider ramifications here, ignoring it for now
    def __eq__(self, other: BigUInt | UInt64 | int) -> bool: ...  # type: ignore[override]
    # !=
    def __ne__(self, other: BigUInt | UInt64 | int) -> bool: ...  # type: ignore[override]
    # <=
    def __le__(self, other: BigUInt | UInt64 | int) -> bool: ...
    # <
    def __lt__(self, other: BigUInt | UInt64 | int) -> bool: ...
    # >=
    def __ge__(self, other: BigUInt | UInt64 | int) -> bool: ...
    # >
    def __gt__(self, other: BigUInt | UInt64 | int) -> bool: ...
    # truthiness
    def __bool__(self) -> bool: ...
    # ~~~ https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types ~~~
    # +
    def __add__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __radd__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __iadd__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # -
    def __sub__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rsub__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __isub__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # *
    def __mul__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rmul__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __imul__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # //
    def __floordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rfloordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __ifloordiv__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # %
    def __mod__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rmod__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __imod__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # &
    def __and__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rand__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __iand__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # ^
    def __xor__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __rxor__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __ixor__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    # |
    def __or__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __ror__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    def __ior__(self, other: BigUInt | UInt64 | int) -> BigUInt: ...
    @property
    def bytes(self) -> Bytes:
        """Get the byte[] backing this value. Note that Bytes is immutable"""
    @classmethod
    def from_bytes(cls, value: Bytes) -> BigUInt:
        """no validation happens here wrt length"""
